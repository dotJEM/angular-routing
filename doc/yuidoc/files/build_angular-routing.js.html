<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>build\angular-routing.js - angular-routing</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="angular-routing"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: build\angular-routing.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;* THIS IS A BANNER *&#x2F; 
(function(window, document, undefined) {
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;..&#x2F;lib&#x2F;angular&#x2F;angular-1.0.d.ts&quot; &#x2F;&gt;
&#x2F;*jshint globalstrict:true*&#x2F;
&#x2F;*global angular:false*&#x2F;
&#x27;use strict&#x27;;
var isDefined = angular.isDefined, isUndefined = angular.isUndefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy;
function inherit(parent, extra) {
    return extend(new (extend(function () {
    }, {
        prototype: parent
    }))(), extra);
}
function toName(named) {
    return isString(named) ? named : named.fullname;
}
angular.module(&#x27;ui.routing&#x27;, []);

&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;..&#x2F;lib&#x2F;angular&#x2F;angular-1.0.d.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;common.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;interfaces.d.ts&quot; &#x2F;&gt;
&#x27;use strict&#x27;;
&#x2F;**
* @ngdoc object
* @name ui.routing.$routeProvider
* @function
*
* @description
*
* Used for configuring routes. See {@link ui.routing.$route $route} for an example.
*&#x2F;
function $RouteProvider() {
    var _this = this;
    var routes = {
    }, converters = {
    }, decorators = {
    }, caseSensitive = true;
    &#x2F;&#x2F;Public Methods
    &#x2F;**
    * @ngdoc method
    * @name ui.routing.$routeProvider#convert
    * @methodOf ui.routing.$routeProvider
    *
    * @param {string} name Cerverter name, used in the path when registering routes through the
    *   {@link ui.routing.routeProvider#when when} function.
    
    *
    * @returns {Object} self
    *
    *
    * @description
    * Adds a new converter or overwrites an existing one.
    *
    * By default the folowing converters are precent:
    *  - &#x60;&#x60; - default Converter, used on all parameters that doesn&#x27;t specify a converter.
    *    Matches any input.
    *
    *  - &#x60;num&#x60; - number converter, used to only mach numeric values.
    *
    *  - &#x60;regex&#x60; - regular expressions converter, used to match a parameter agains a regular
    *    expression.
    *&#x2F;
    this.convert = function (name, converter) {
        &#x2F;&#x2F;Note: We wan&#x27;t to allow overwrite
        converters[name] = converter;
        return _this;
    };
    &#x2F;**
    * @ngdoc method
    * @name ui.routing.$routeProvider#when
    * @methodOf ui.routing.$routeProvider
    *
    * @param {string} path Route path (matched against &#x60;$location.path&#x60;). If &#x60;$location.path&#x60;
    *    contains redundant trailing slash or is missing one, the route will still match.
    *
    *    &#x60;path&#x60; can contain named groups starting with a colon (&#x60;:name&#x60;) or curly brackets (&#x60;{name}&#x60;).
    *    All characters up to the next slash are matched and stored in &#x60;$routeParams&#x60; under the
    *    given &#x60;name&#x60; when the route matches.
    *
    *    Further, when using the curly bracket syntax, converters can be used to match only specific
    *    values, (&#x60;{num:name}&#x60;) will only match numerical values and (&#x60;{regex(\d{1,2}[a-z]+):name}&#x60;)
    *    would only match a parameter starting with one or two digits followed by a number of
    *    characters between &#x27;a&#x27; and &#x27;z&#x27;.
    *
    *    More converters can be registered using the {@link ui.routing.routeProvider#convert convert}
    *    function.
    *
    * @param {Object} route Mapping information to be assigned to &#x60;$route.current&#x60; on route
    *    match.
    *
    *    Object properties:
    *
    *    - &#x60;state&#x60; � &#x60;{string}&#x60; � a state that should be activated when the route is matched.
    *    - &#x60;action&#x60; � &#x60;{(string|function()=}&#x60; � an action that should be performed when the route is matched.
    *
    *    Legacy support for the following when using the {@link ui.routing.legacy ui.routing.legacy}
    *    module.
    *
    *    - &#x60;controller&#x60; � &#x60;{(string|function()=}&#x60; � Controller fn that should be associated with newly
    *      created scope or the name of a {@link angular.Module#controller registered controller}
    *      if passed as a string.
    *    - &#x60;template&#x60; � &#x60;{string=|function()=}&#x60; � html template as a string or function that returns
    *      an html template as a string which should be used by {@link ng.directive:ngView ngView} or
    *      {@link ng.directive:ngInclude ngInclude} directives.
    *      This property takes precedence over &#x60;templateUrl&#x60;.
    *
    *      If &#x60;template&#x60; is a function, it will be called with the following parameters:
    *
    *      - &#x60;{Array.&lt;Object&gt;}&#x60; - route parameters extracted from the current
    *        &#x60;$location.path()&#x60; by applying the current route
    *
    *    - &#x60;templateUrl&#x60; � &#x60;{string=|function()=}&#x60; � path or function that returns a path to an html
    *      template that should be used by {@link ng.directive:ngView ngView}.
    *
    *      If &#x60;templateUrl&#x60; is a function, it will be called with the following parameters:
    *
    *      - &#x60;{Array.&lt;Object&gt;}&#x60; - route parameters extracted from the current
    *        &#x60;$location.path()&#x60; by applying the current route
    *
    *    - &#x60;resolve&#x60; - &#x60;{Object.&lt;string, function&gt;=}&#x60; - An optional map of dependencies which should
    *      be injected into the controller. If any of these dependencies are promises, they will be
    *      resolved and converted to a value before the controller is instantiated and the
    *      &#x60;$routeChangeSuccess&#x60; event is fired. The map object is:
    *
    *      - &#x60;key&#x60; � &#x60;{string}&#x60;: a name of a dependency to be injected into the controller.
    *      - &#x60;factory&#x60; - &#x60;{string|function}&#x60;: If &#x60;string&#x60; then it is an alias for a service.
    *        Otherwise if function, then it is {@link api&#x2F;AUTO.$injector#invoke injected}
    *        and the return value is treated as the dependency. If the result is a promise, it is resolved
    *        before its value is injected into the controller.
    *
    *    - &#x60;redirectTo&#x60; � {(string|function())=} � value to update
    *      {@link ng.$location $location} path with and trigger route redirection.
    *
    *      If &#x60;redirectTo&#x60; is a function, it will be called with the following parameters:
    *
    *      - &#x60;{Object.&lt;string&gt;}&#x60; - route parameters extracted from the current
    *        &#x60;$location.path()&#x60; by applying the current route templateUrl.
    *      - &#x60;{string}&#x60; - current &#x60;$location.path()&#x60;
    *      - &#x60;{Object}&#x60; - current &#x60;$location.search()&#x60;
    *
    *      The custom &#x60;redirectTo&#x60; function is expected to return a string which will be used
    *      to update &#x60;$location.path()&#x60; and &#x60;$location.search()&#x60;.
    *
    *    - &#x60;[reloadOnSearch=true]&#x60; - {boolean=} - reload route when only $location.search()
    *    changes.
    *
    *      If the option is set to &#x60;false&#x60; and url in the browser changes, then
    *      &#x60;$routeUpdate&#x60; event is broadcasted on the root scope.
    *
    * @returns {Object} self
    *
    * @description
    * Adds a new route definition to the &#x60;$route&#x60; service.
    *&#x2F;
    this.when = function (path, route) {
        var normalized = normalizePath(path);
        routes[normalized.name] = {
            self: extend({
                reloadOnSearch: true
            }, route),
            redirect: createRedirector(route.redirectTo),
            match: createMatcher(path),
            path: path,
            params: normalized.params
        };
        return _this;
    };
    &#x2F;**
    * @ngdoc method
    * @name ng.$routeProvider#otherwise
    * @methodOf ng.$routeProvider
    *
    * @description
    * Sets route definition that will be used on route change when no other route definition
    * is matched.
    *
    * @param {Object} params Mapping information to be assigned to &#x60;$route.current&#x60;.
    * @returns {Object} self
    *&#x2F;
    this.otherwise = function (route) {
        _this.when(null, route);
        return _this;
    };
    this.decorate = function (name, decorator) {
        &#x2F;&#x2F;Note: We wan&#x27;t to allow overwrite
        decorators[name] = decorator;
        return _this;
    };
    this.ignoreCase = function () {
        caseSensitive = false;
        return _this;
    };
    this.matchCase = function () {
        caseSensitive = true;
        return _this;
    };
    &#x2F;&#x2F;Scoped Methods
    function interpolate(url, params) {
        &#x2F;&#x2F;TODO: We only support :params here, but that might be ok for now as we are constructing an url.
        var result = [];
        forEach((url || &#x27;&#x27;).split(&#x27;:&#x27;), function (segment, i) {
            if(i == 0) {
                result.push(segment);
            } else {
                var segmentMatch = segment.match(&#x2F;(\w+)(.*)&#x2F;);
                var key = segmentMatch[1];
                result.push(params[key]);
                result.push(segmentMatch[2] || &#x27;&#x27;);
                delete params[key];
            }
        });
        return result.join(&#x27;&#x27;);
    }
    function createRedirector(redirectTo) {
        var fn = null;
        return function ($location, next) {
            if(fn === null) {
                if(redirectTo) {
                    if(isString(redirectTo)) {
                        fn = function ($location, next) {
                            var interpolated = interpolate(redirectTo, next.params);
                            $location.path(interpolated).search(next.params).replace();
                        };
                    } else {
                        fn = function ($location, next) {
                            $location.url(redirectTo(next.pathParams, $location.path(), $location.search())).replace();
                        };
                    }
                } else {
                    fn = function () {
                    };
                }
            }
            return fn($location, next);
        };
    }
    function createSegment(match) {
        var cname = match[6] || &#x27;&#x27;, carg = match[8], trimmed;
        if(carg) {
            trimmed = carg.trim();
            if((trimmed[0] === &#x27;{&#x27; &amp;&amp; trimmed[trimmed.length - 1] === &#x27;}&#x27;) || (trimmed[0] === &#x27;[&#x27; &amp;&amp; trimmed[trimmed.length - 1] === &#x27;]&#x27;)) {
                try  {
                    carg = angular.fromJson(trimmed);
                } catch (e) {
                    &#x2F;&#x2F;Note: Errors are ok here, we let it remain as a string.
                                    }
            }
        }
        return {
            name: match[3] || match[9],
            converter: converters[cname](carg)
        };
    }
    var esc = &#x2F;[-\&#x2F;\\^$*+?.()|[\]{}]&#x2F;g;
    function escape(exp) {
        return exp.replace(esc, &quot;\\$&amp;&quot;);
    }
    &#x2F;&#x2F; NOTE: Hoisting brings the declaration (not assignment) of re to the top. I have left it here
    &#x2F;&#x2F;       so it is only used in parseExpression, but defining it inside would case a new re on each
    &#x2F;&#x2F;       call to parseExpression, and that is not needed.
    var re = new RegExp(&#x27;\x2F((:(\\w+))|(\\{((\\w+)(\\((.*?)\\))?:)?(\\w+)\\}))&#x27;, &#x27;g&#x27;);
    function parseExpression(path) {
        var regex = &quot;^&quot;, segments = [], index = 0, match, flags = &#x27;&#x27;;
        if(path === &#x27;&#x2F;&#x27;) {
            return {
                complete: &#x2F;&#x2F;partial: new RegExp(&#x27;^[\x2F].*$&#x27;, flags),
                new RegExp(&#x27;^[\x2F]$&#x27;, flags),
                segments: []
            };
        }
        while((match = re.exec(path)) !== null) {
            regex += escape(path.slice(index, match.index));
            regex += &#x27;&#x2F;([^\\&#x2F;]*)&#x27;;
            segments.push(createSegment(match));
            index = re.lastIndex;
        }
        regex += escape(path.substr(index));
        if(!caseSensitive) {
            flags += &#x27;i&#x27;;
        }
        if(regex[regex.length - 1] === &#x27;\x2F&#x27;) {
            regex = regex.substr(0, regex.length - 1);
        }
        return {
            complete: &#x2F;&#x2F;partial: new RegExp(regex + &quot;\x2F?.*$&quot;, flags),
            new RegExp(regex + &#x27;\x2F?$&#x27;, flags),
            segments: segments
        };
    }
    function normalizePath(path) {
        var name = &quot;&quot;, index = 0, match, counter = 0, params = {
        };
        if(path === null) {
            return {
                name: null,
                params: params
            };
        }
        while((match = re.exec(path)) !== null) {
            var converter = match[6] || &#x27;&#x27;, paramName = match[3] || match[9];
            params[paramName] = {
                id: counter,
                converter: converter
            };
            if(converter !== &#x27;&#x27;) {
                converter = &quot;:&quot; + converter;
            }
            name += path.slice(index, match.index) + &#x27;&#x2F;$&#x27; + (counter++) + converter;
            index = re.lastIndex;
        }
        name += path.substr(index);
        if(!caseSensitive) {
            name = name.toLowerCase();
        }
        return {
            name: name,
            params: params
        };
    }
    function createMatcher(path) {
        if(path == null) {
            return function (location) {
            };
        }
        var expFac = function () {
            var v = parseExpression(path);
            expFac = function () {
                return v;
            };
            return expFac();
        };
        return function (location) {
            var exp = expFac(), match = location.match(exp.complete), dst = {
            }, invalidParam;
            if(match) {
                &#x2F;&#x2F;if (location.match(exp.complete)) {
                invalidParam = false;
                forEach(exp.segments, function (segment, index) {
                    var param, value;
                    if(!invalidParam) {
                        param = match[index + 1];
                        value = segment.converter(param);
                        if(isDefined(value.accept)) {
                            if(!value.accept) {
                                invalidParam = true;
                            }
                            dst[segment.name] = value.value;
                        } else {
                            if(!value) {
                                invalidParam = true;
                            }
                            dst[segment.name] = param;
                        }
                    }
                });
                if(!invalidParam) {
                    return dst;
                }
                &#x2F;&#x2F;} else {
                &#x2F;&#x2F;TODO: Match nested routes
                &#x2F;&#x2F;}
                            }
        };
    }
    &#x2F;&#x2F;Registration of Default Converters
    this.convert(&#x27;num&#x27;, function () {
        return function (param) {
            var accepts = !isNaN(param);
            return {
                accept: accepts,
                value: accepts ? Number(param) : 0
            };
        };
    });
    this.convert(&#x27;regex&#x27;, function (arg) {
        var exp, flags = &#x27;&#x27;, regex;
        if(isObject(arg) &amp;&amp; isDefined(arg.exp)) {
            exp = arg.exp;
            if(isDefined(arg.flags)) {
                flags = arg.flags;
            }
        } else if(isString(arg) &amp;&amp; arg.length &gt; 0) {
            exp = arg;
        } else {
            throw new Error(&quot;The Regular-expression converter was not initialized with a valid object.&quot;);
        }
        regex = new RegExp(exp, flags);
        return function (param) {
            var accepts = regex.test(param);
            return {
                accept: accepts,
                value: accepts ? regex.exec(param) : null
            };
        };
    });
    this.convert(&#x27;&#x27;, function () {
        return function (param) {
            return true;
        };
    });
    &#x2F;&#x2F;Service Factory
    this.$get = [
        &#x27;$rootScope&#x27;, 
        &#x27;$location&#x27;, 
        &#x27;$q&#x27;, 
        &#x27;$injector&#x27;, 
        &#x27;$routeParams&#x27;, 
        function ($rootScope, $location, $q, $injector, $routeParams) {
            &#x2F;**
            * @ngdoc object
            * @name ng.$route
            * @requires $location
            * @requires $routeParams
            *
            * @property {Object} current Reference to the current route definition.
            * The route definition contains:
            *
            *   - &#x60;controller&#x60;: The controller constructor as define in route definition.
            *   - &#x60;locals&#x60;: A map of locals which is used by {@link ng.$controller $controller} service for
            *     controller instantiation. The &#x60;locals&#x60; contain
            *     the resolved values of the &#x60;resolve&#x60; map. Additionally the &#x60;locals&#x60; also contain:
            *
            *     - &#x60;$scope&#x60; - The current route scope.
            *     - &#x60;$template&#x60; - The current route template HTML.
            *
            * @property {Array.&lt;Object&gt;} routes Array of all configured routes.
            *
            * @description
            * Is used for deep-linking URLs to controllers and views (HTML partials).
            * It watches &#x60;$location.url()&#x60; and tries to map the path to an existing route definition.
            *
            * You can define routes through {@link ng.$routeProvider $routeProvider}&#x27;s API.
            *
            * The &#x60;$route&#x60; service is typically used in conjunction with {@link ng.directive:ngView ngView}
            * directive and the {@link ng.$routeParams $routeParams} service.
            *
            * @example
            This example shows how changing the URL hash causes the &#x60;$route&#x60; to match a route against the
            URL, and the &#x60;ngView&#x60; pulls in the partial.
            
            Note that this example is using {@link ng.directive:script inlined templates}
            to get it working on jsfiddle as well.
            
            &lt;example module=&quot;ngView&quot;&gt;
            &lt;file name=&quot;index.html&quot;&gt;
            &lt;div ng-controller=&quot;MainCntl&quot;&gt;
            Choose:
            &lt;a href=&quot;Book&#x2F;Moby&quot;&gt;Moby&lt;&#x2F;a&gt; |
            &lt;a href=&quot;Book&#x2F;Moby&#x2F;ch&#x2F;1&quot;&gt;Moby: Ch1&lt;&#x2F;a&gt; |
            &lt;a href=&quot;Book&#x2F;Gatsby&quot;&gt;Gatsby&lt;&#x2F;a&gt; |
            &lt;a href=&quot;Book&#x2F;Gatsby&#x2F;ch&#x2F;4?key=value&quot;&gt;Gatsby: Ch4&lt;&#x2F;a&gt; |
            &lt;a href=&quot;Book&#x2F;Scarlet&quot;&gt;Scarlet Letter&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;
            
            &lt;div ng-view&gt;&lt;&#x2F;div&gt;
            &lt;hr &#x2F;&gt;
            
            &lt;pre&gt;$location.path() = {{$location.path()}}&lt;&#x2F;pre&gt;
            &lt;pre&gt;$route.current.templateUrl = {{$route.current.templateUrl}}&lt;&#x2F;pre&gt;
            &lt;pre&gt;$route.current.params = {{$route.current.params}}&lt;&#x2F;pre&gt;
            &lt;pre&gt;$route.current.scope.name = {{$route.current.scope.name}}&lt;&#x2F;pre&gt;
            &lt;pre&gt;$routeParams = {{$routeParams}}&lt;&#x2F;pre&gt;
            &lt;&#x2F;div&gt;
            &lt;&#x2F;file&gt;
            
            &lt;file name=&quot;book.html&quot;&gt;
            controller: {{name}}&lt;br &#x2F;&gt;
            Book Id: {{params.bookId}}&lt;br &#x2F;&gt;
            &lt;&#x2F;file&gt;
            
            &lt;file name=&quot;chapter.html&quot;&gt;
            controller: {{name}}&lt;br &#x2F;&gt;
            Book Id: {{params.bookId}}&lt;br &#x2F;&gt;
            Chapter Id: {{params.chapterId}}
            &lt;&#x2F;file&gt;
            
            &lt;file name=&quot;script.js&quot;&gt;
            angular.module(&#x27;ngView&#x27;, [], function($routeProvider, $locationProvider) {
            $routeProvider.when(&#x27;&#x2F;Book&#x2F;:bookId&#x27;, {
            templateUrl: &#x27;book.html&#x27;,
            controller: BookCntl,
            resolve: {
            &#x2F;&#x2F; I will cause a 1 second delay
            delay: function($q, $timeout) {
            var delay = $q.defer();
            $timeout(delay.resolve, 1000);
            return delay.promise;
            }
            }
            });
            $routeProvider.when(&#x27;&#x2F;Book&#x2F;:bookId&#x2F;ch&#x2F;:chapterId&#x27;, {
            templateUrl: &#x27;chapter.html&#x27;,
            controller: ChapterCntl
            });
            
            &#x2F;&#x2F; configure html5 to get links working on jsfiddle
            $locationProvider.html5Mode(true);
            });
            
            function MainCntl($scope, $route, $routeParams, $location) {
            $scope.$route = $route;
            $scope.$location = $location;
            $scope.$routeParams = $routeParams;
            }
            
            function BookCntl($scope, $routeParams) {
            $scope.name = &quot;BookCntl&quot;;
            $scope.params = $routeParams;
            }
            
            function ChapterCntl($scope, $routeParams) {
            $scope.name = &quot;ChapterCntl&quot;;
            $scope.params = $routeParams;
            }
            &lt;&#x2F;file&gt;
            
            &lt;file name=&quot;scenario.js&quot;&gt;
            it(&#x27;should load and compile correct template&#x27;, function() {
            element(&#x27;a:contains(&quot;Moby: Ch1&quot;)&#x27;).click();
            var content = element(&#x27;.doc-example-live [ng-view]&#x27;).text();
            expect(content).toMatch(&#x2F;controller\: ChapterCntl&#x2F;);
            expect(content).toMatch(&#x2F;Book Id\: Moby&#x2F;);
            expect(content).toMatch(&#x2F;Chapter Id\: 1&#x2F;);
            
            element(&#x27;a:contains(&quot;Scarlet&quot;)&#x27;).click();
            sleep(2); &#x2F;&#x2F; promises are not part of scenario waiting
            content = element(&#x27;.doc-example-live [ng-view]&#x27;).text();
            expect(content).toMatch(&#x2F;controller\: BookCntl&#x2F;);
            expect(content).toMatch(&#x2F;Book Id\: Scarlet&#x2F;);
            });
            &lt;&#x2F;file&gt;
            &lt;&#x2F;example&gt;
            *&#x2F;
            &#x2F;**
            * @ngdoc event
            * @name ng.$route#$routeChangeStart
            * @eventOf ng.$route
            * @eventType broadcast on root scope
            * @description
            * Broadcasted before a route change. At this  point the route services starts
            * resolving all of the dependencies needed for the route change to occurs.
            * Typically this involves fetching the view template as well as any dependencies
            * defined in &#x60;resolve&#x60; route property. Once  all of the dependencies are resolved
            * &#x60;$routeChangeSuccess&#x60; is fired.
            *
            * @param {Route} next Future route information.
            * @param {Route} current Current route information.
            *&#x2F;
            &#x2F;**
            * @ngdoc event
            * @name ng.$route#$routeChangeSuccess
            * @eventOf ng.$route
            * @eventType broadcast on root scope
            * @description
            * Broadcasted after a route dependencies are resolved.
            * {@link ng.directive:ngView ngView} listens for the directive
            * to instantiate the controller and render the view.
            *
            * @param {Route} current Current route information.
            * @param {Route} previous Previous route information.
            *&#x2F;
            &#x2F;**
            * @ngdoc event
            * @name ng.$route#$routeChangeError
            * @eventOf ng.$route
            * @eventType broadcast on root scope
            * @description
            * Broadcasted if any of the resolve promises are rejected.
            *
            * @param {Route} current Current route information.
            * @param {Route} previous Previous route information.
            * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.
            *&#x2F;
            &#x2F;**
            * @ngdoc event
            * @name ng.$route#$routeUpdate
            * @eventOf ng.$route
            * @eventType broadcast on root scope
            * @description
            *
            * The &#x60;reloadOnSearch&#x60; property has been set to false, and we are reusing the same
            * instance of the Controller.
            *&#x2F;
                        var forceReload = false, $route = {
                routes: routes,
                reload: function () {
                    forceReload = true;
                    $rootScope.$evalAsync(update);
                }
            };
            $rootScope.$on(&#x27;$locationChangeSuccess&#x27;, update);
            return $route;
            function buildmatch(route, params, search) {
                var match = inherit(route, {
                    self: inherit(route.self, {
                        params: extend({
                        }, search, params),
                        searchParams: search,
                        pathParams: params
                    })
                });
                return match;
            }
            function findroute(currentPath) {
                var params, match;
                forEach(routes, function (route, path) {
                    if(!match &amp;&amp; (params = route.match(currentPath))) {
                        match = buildmatch(route, params, $location.search());
                    }
                });
                return match || routes[null] &amp;&amp; buildmatch(routes[null], {
                }, {
                });
            }
            function update() {
                var next = findroute($location.path()), lastRoute = $route.current, nextRoute = next ? next.self : undefined;
                if(!forceReload &amp;&amp; nextRoute &amp;&amp; lastRoute &amp;&amp; angular.equals(nextRoute.pathParams, lastRoute.pathParams) &amp;&amp; !nextRoute.reloadOnSearch) {
                    lastRoute.params = next.params;
                    copy(nextRoute.params, $routeParams);
                    $rootScope.$broadcast(&#x27;$routeUpdate&#x27;, lastRoute);
                } else if(next || lastRoute) {
                    &#x2F;&#x2F;TODO: We should always have a next to go to, it may be a null route though.
                    forceReload = false;
                    var event = $rootScope.$broadcast(&#x27;$routeChangeStart&#x27;, nextRoute, lastRoute);
                    if(!event.defaultPrevented) {
                        $route.current = nextRoute;
                        if(next) {
                            next.redirect($location, nextRoute);
                        }
                        var dp = $q.when(nextRoute);
                        if(nextRoute) {
                            forEach(decorators, function (decorator, name) {
                                dp = dp.then(function () {
                                    var decorated = $injector.invoke(decorator, nextRoute, {
                                        $next: nextRoute
                                    });
                                    return $q.when(decorated);
                                });
                            });
                        }
                        dp.then(function () {
                            if(nextRoute === $route.current) {
                                if(next) {
                                    angular.copy(nextRoute.params, $routeParams);
                                }
                                $rootScope.$broadcast(&#x27;$routeChangeSuccess&#x27;, nextRoute, lastRoute);
                            }
                        }, function (error) {
                            if(nextRoute === $route.current) {
                                $rootScope.$broadcast(&#x27;$routeChangeError&#x27;, nextRoute, lastRoute, error);
                            }
                        });
                    } else {
                        &#x2F;&#x2F;TODO: Do we need to do anything if the user cancels?
                        &#x2F;&#x2F;       - if the user wants to return to the old url, he should cancel on
                        &#x2F;&#x2F;         location change instead?
                                            }
                }
            }
        }    ];
}
angular.module(&#x27;ui.routing&#x27;).provider(&#x27;$route&#x27;, $RouteProvider).value(&#x27;$routeParams&#x27;, {
});

&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;..&#x2F;lib&#x2F;angular&#x2F;angular-1.0.d.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;common.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;interfaces.d.ts&quot; &#x2F;&gt;
&#x27;use strict&#x27;;
function $TransitionProvider() {
    var root = {
        children: {
        },
        targets: {
        }
    }, validation = &#x2F;^\w+(\.\w+)*(\.[*])?$&#x2F;;
    this.onEnter = function (state, onenter) {
        &#x2F;&#x2F;TODO: Validation
        if(isArray(onenter)) {
            forEach(onenter, function (single) {
                onenter(single, state);
            });
        } else if(isObject(onenter)) {
            this.transition(onenter.from || &#x27;*&#x27;, state, onenter.handler);
        } else if(isFunction(onenter)) {
            this.transition(&#x27;*&#x27;, state, onenter);
        }
    };
    this.onExit = function (state, onexit) {
        var _this = this;
        &#x2F;&#x2F;TODO: Validation
        if(isArray(onexit)) {
            forEach(onexit, function (single) {
                _this.onexit(single, state);
            });
        } else if(isObject(onexit)) {
            this.transition(state, onexit.to || &#x27;*&#x27;, onexit.handler);
        } else if(isFunction(onexit)) {
            this.transition(state, &#x27;*&#x27;, onexit);
        }
    };
    this.transition = function (from, to, handler) {
        var _this = this;
        var transition, regHandler;
        if(isArray(from)) {
            forEach(from, function (value) {
                _this.transition(value, to, handler);
            });
        } else if(isArray(to)) {
            forEach(to, function (value) {
                _this.transition(from, value, handler);
            });
        } else {
            from = toName(from);
            to = toName(to);
            &#x2F;&#x2F; We ignore the situation where to and from are the same explicit state.
            &#x2F;&#x2F; Reason to ignore is the array ways of registering transitions, it could easily happen that a fully named
            &#x2F;&#x2F; state was in both the target and source array, and it would be a hassle for the user if he had to avoid that.
            if(to === from &amp;&amp; to.indexOf(&#x27;*&#x27;) === -1) {
                return this;
            }
            validate(from, to);
            if(angular.isFunction(handler) || angular.isArray(handler)) {
                handler = {
                    between: handler
                };
            }
            transition = lookup(from);
            if(!(to in transition.targets)) {
                transition.targets[to] = [];
            }
            handler.name = from + &#x27; -&gt; &#x27; + to;
            transition.targets[to].push(handler);
        }
        return this;
    };
    function validate(from, to) {
        var fromValid = validateTarget(from), toValid = validateTarget(to);
        if(fromValid &amp;&amp; toValid) {
            &#x2F;&#x2F; &amp;&amp; from !== to
            return;
        }
        if(fromValid) {
            throw new Error(&quot;Invalid transition - to: &#x27;&quot; + to + &quot;&#x27;.&quot;);
        }
        if(toValid) {
            throw new Error(&quot;Invalid transition - from: &#x27;&quot; + from + &quot;&#x27;.&quot;);
        }
        &#x2F;&#x2F;if (from === to &amp;&amp; from.indexOf(&#x27;*&#x27;) === -1)
        &#x2F;&#x2F;    throw new Error(&quot;Invalid transition - from and to can&#x27;t be the same.&quot;);
        throw new Error(&quot;Invalid transition - from: &#x27;&quot; + from + &quot;&#x27;, to: &#x27;&quot; + to + &quot;&#x27;.&quot;);
    }
    function validateTarget(target) {
        if(target === &#x27;*&#x27; || validation.test(target)) {
            return true;
        }
        return false;
    }
    function lookup(name) {
        var current = root, names = name.split(&#x27;.&#x27;), i = &#x2F;&#x2F;If name contains root explicitly, skip that one
        names[0] === &#x27;root&#x27; ? 1 : 0;
        for(; i &lt; names.length; i++) {
            if(!(names[i] in current.children)) {
                current.children[names[i]] = {
                    children: {
                    },
                    targets: {
                    }
                };
            }
            current = current.children[names[i]];
        }
        return current;
    }
    this.$get = [
        &#x27;$q&#x27;, 
        &#x27;$injector&#x27;, 
        function ($q, $injector) {
            var $transition = {
                root: root,
                find: find
            };
            return $transition;
            function find(from, to) {
                var transitions = findTransitions(from.fullname), handlers = extractHandlers(transitions, to.fullname), emitters;
                function emit(select, tc) {
                    var _this = this;
                    var handler;
                    forEach(handlers, function (handlerObj) {
                        if(isDefined(handler = select(handlerObj))) {
                            $injector.invoke(handler, _this, {
                                $to: to,
                                $from: from,
                                $transition: tc
                            });
                        }
                    });
                }
                return {
                    before: function (tc) {
                        emit(function (h) {
                            return h.before;
                        }, tc);
                    },
                    between: function (tc) {
                        emit(function (h) {
                            return h.between;
                        }, tc);
                    },
                    after: function (tc) {
                        emit(function (h) {
                            return h.after;
                        }, tc);
                    }
                };
            }
            function trimRoot(path) {
                if(path[0] === &#x27;root&#x27;) {
                    path.splice(0, 1);
                }
                return path;
            }
            function compare(one, to) {
                var left = trimRoot(one.split(&#x27;.&#x27;)).reverse(), right = trimRoot(to.split(&#x27;.&#x27;)).reverse(), l, r, i = 0;
                while(true) {
                    l = left.pop();
                    r = right.pop();
                    if(r === &#x27;*&#x27; || l === &#x27;*&#x27;) {
                        return true;
                    }
                    if(l !== r) {
                        return false;
                    }
                    if(!isDefined(l) || !isDefined(r)) {
                        return true;
                    }
                }
                return true;
            }
            function extractHandlers(transitions, to) {
                var handlers = [];
                forEach(transitions, function (t) {
                    forEach(t.targets, function (target, targetName) {
                        if(compare(targetName, to)) {
                            forEach(target, function (value) {
                                handlers.push(value);
                            });
                        }
                    });
                });
                return handlers;
            }
            function findTransitions(from) {
                var current = root, names = from.split(&#x27;.&#x27;), transitions = [], index = names[0] === &#x27;root&#x27; ? 1 : 0;
                do {
                    if(&#x27;*&#x27; in current.children) {
                        transitions.push(current.children[&#x27;*&#x27;]);
                    }
                    if(names[index] in current.children) {
                        current = current.children[names[index]];
                        transitions.push(current);
                    } else {
                        break;
                    }
                }while(index++ &lt; names.length);
                return transitions;
            }
        }    ];
}
angular.module(&#x27;ui.routing&#x27;).provider(&#x27;$transition&#x27;, $TransitionProvider);

&#x27;use strict&#x27;;
var $StateProvider = [
    &#x27;$routeProvider&#x27;, 
    &#x27;$transitionProvider&#x27;, 
    function ($routeProvider, $transitionProvider) {
        var root = {
            fullname: &#x27;root&#x27;,
            children: {
            },
            self: {
                fullname: &#x27;root&#x27;
            }
        }, nameValidation = &#x2F;^\w+(\.\w+)*?$&#x2F;;
        function validateName(name) {
            if(nameValidation.test(name)) {
                return;
            }
            throw new Error(&quot;Invalid name: &#x27;&quot; + name + &quot;&#x27;.&quot;);
        }
        function createRoute(stateRoute, parrentRoute, stateName, reloadOnSearch) {
            var route;
            if(!isDefined(reloadOnSearch)) {
                reloadOnSearch = true;
            }
            route = (parrentRoute || &#x27;&#x27;);
            if(route !== &#x27;&#x27; &amp;&amp; route[route.length - 1] === &#x27;&#x2F;&#x27;) {
                route = route.substr(0, route.length - 1);
            }
            if(stateRoute[0] !== &#x27;&#x2F;&#x27;) {
                route += &#x27;&#x2F;&#x27;;
            }
            route += stateRoute;
            $routeProvider.when(route, {
                state: stateName,
                reloadOnSearch: reloadOnSearch
            });
            return route;
        }
        function lookupRoute(parent) {
            while(isDefined(parent) &amp;&amp; !isDefined(parent.route)) {
                parent = parent.parent;
            }
            return (parent &amp;&amp; parent.route) || &#x27;&#x27;;
        }
        var re = new RegExp(&#x27;\x2F((:(\\w+))|(\\{((\\w+)(\\((.*?)\\))?:)?(\\w+)\\}))&#x27;, &#x27;g&#x27;);
        function findParams(path) {
            var match, params = [];
            if(path === null) {
                return params;
            }
            while((match = re.exec(path)) !== null) {
                var paramName = match[3] || match[9];
                params.push(paramName);
            }
            return params;
        }
        function registerState(name, at, state) {
            var fullname = at.fullname + &#x27;.&#x27; + name, parent = at;
            if(!isDefined(at.children)) {
                at.children = {
                };
            }
            if(!(name in at.children)) {
                at.children[name] = {
                };
            }
            at = at.children[name];
            at.self = extend(state, {
                fullname: fullname
            });
            at.fullname = fullname;
            at.parent = parent;
            if(isDefined(state.route)) {
                at.route = createRoute(state.route, lookupRoute(parent), fullname, state.reloadOnSearch);
                at.params = findParams(state.route);
            }
            if(isDefined(state.onEnter)) {
                $transitionProvider.onEnter(fullname, state.onEnter);
            }
            if(isDefined(state.onExit)) {
                $transitionProvider.onExit(fullname, state.onExit);
            }
            if(state.children === null) {
                at.children = {
                };
            } else {
                forEach(state.children, function (childState, childName) {
                    registerState(childName, at, childState);
                });
            }
        }
        function lookup(names) {
            var current = root, i = &#x2F;&#x2F;If name contains root explicitly, skip that one
            names[0] === &#x27;root&#x27; ? 1 : 0;
            for(; i &lt; names.length; i++) {
                if(!(names[i] in current.children)) {
                    throw new Error(&quot;Could not locate &#x27;&quot; + names[i] + &quot;&#x27; under &#x27;&quot; + current.fullname + &quot;&#x27;.&quot;);
                }
                current = current.children[names[i]];
            }
            return current;
        }
        function lookupState(name) {
            return lookup(name.split(&#x27;.&#x27;));
            ;
        }
        function lookupParent(name) {
            var names = name.split(&#x27;.&#x27;), name = names.pop();
            return {
                at: lookup(names),
                name: name
            };
        }
        this.state = function (name, state) {
            var pair;
            validateName(name);
            pair = lookupParent(name);
            registerState(pair.name, pair.at, state);
            return this;
        };
        this.transition = function (from, to, handler) {
            $transitionProvider.transition(from, to, handler);
            return this;
        };
        this.$get = [
            &#x27;$rootScope&#x27;, 
            &#x27;$q&#x27;, 
            &#x27;$injector&#x27;, 
            &#x27;$route&#x27;, 
            &#x27;$view&#x27;, 
            &#x27;$transition&#x27;, 
            &#x27;$location&#x27;, 
            function ($rootScope, $q, $injector, $route, $view, $transition, $location) {
                var forceReload = false, $state = {
                    root: root,
                    current: inherit({
                    }, root),
                    goto: goto,
                    lookup: function (path) {
                        &#x2F;&#x2F; XPath Inspired lookups
                        &#x2F;&#x2F;
                        &#x2F;&#x2F; &#x2F;myState -&gt; Selects myState from the root node.
                        &#x2F;&#x2F; .&#x2F;myState -&gt; Selects myState as a child of the current node.
                        &#x2F;&#x2F; ..&#x2F;myStaate -&gt; Selects myState as a child of the parent node to this.
                        &#x2F;&#x2F; &#x2F;myState.$1 -&gt; Selects the first child of myState
                        &#x2F;&#x2F; &#x2F;myState.$last -&gt; Selects the last child of myState
                        &#x2F;&#x2F; .$next -&gt; Selects the next sibling of current element
                                            },
                    nextSibling: &#x2F;&#x2F;TODO: Implement functions that return siblings etc.
                    &#x27;&#x27;,
                    prevSibling: &#x27;&#x27;,
                    parrent: &#x27;&#x27;,
                    children: &#x27;&#x27;,
                    reload: function () {
                        forceReload = true;
                        $rootScope.$evalAsync(update);
                    }
                };
                $rootScope.$on(&#x27;$routeChangeSuccess&#x27;, update);
                $rootScope.$on(&#x27;$routeUpdate&#x27;, function () {
                    &#x2F;&#x2F;TODO: Broadcast StateUpdate?
                                    });
                return $state;
                function update() {
                    var route = $route.current, params;
                    if(route) {
                        params = {
                            all: route.params,
                            path: route.pathParams,
                            search: route.searchParams
                        };
                        if(route.state) {
                            goto(route.state, params);
                        }
                        &#x2F;&#x2F;TODO: Move Action to state instead?.
                        &#x2F;&#x2F;if (route.action) {
                        &#x2F;&#x2F;    $injector.invoke(route.action, { $params: params });
                        &#x2F;&#x2F;}
                                            } else {
                        goto(root);
                    }
                }
                function isChanged(state, params) {
                    var old = $state.current.params, oldPar = old &amp;&amp; old.all || {
                    }, newPar = params.all, result = false;
                    forEach(state.params, function (name) {
                        &#x2F;&#x2F;TODO: Implement an equals function that converts towards strings as this could very well
                        &#x2F;&#x2F;      ignore an change on certain situations.
                        &#x2F;&#x2F;
                        &#x2F;&#x2F;      also change to a damn &quot;forEach&quot; where we can break out mid way...
                        result = oldPar[name] != newPar[name];
                    });
                    return result;
                }
                function changeChain(to, params) {
                    var states = [], lastChanged = 1, current = to;
                    while(current !== root) {
                        states.push(current);
                        if(isChanged(current, params)) {
                            lastChanged = states.length;
                        }
                        current = current.parent;
                    }
                    return {
                        states: states.reverse(),
                        first: states.length - lastChanged
                    };
                }
                function goto(to, params) {
                    &#x2F;&#x2F;TODO: This list of declarations seems to indicate that we are doing more that we should in a single function.
                    &#x2F;&#x2F;      should try to refactor it if possible.
                                        var to = lookupState(toName(to)), toState = inherit({
                        params: params
                    }, to.self), fromState = $state.current, emit = $transition.find($state.current, toState), cancel = false, event, transition, transaction, changed = changeChain(to, params);
                    event = $rootScope.$broadcast(&#x27;$stateChangeStart&#x27;, toState, fromState);
                    if(!event.defaultPrevented) {
                        transition = {
                            cancel: function () {
                                cancel = true;
                            },
                            goto: function (state, params) {
                                cancel = true;
                                goto(state, params);
                            }
                        };
                        emit.before(transition);
                        if(cancel) {
                            &#x2F;&#x2F;TODO: Should we do more here?... What about the URL?... Should we reset that to the privous URL?...
                            &#x2F;&#x2F;      That is if this was even triggered by an URL change in teh first place.
                            return;
                        }
                        $q.when(toState).then(function () {
                            transaction = $view.beginUpdate();
                            $view.clear();
                            forEach(changed.states, function (state, index) {
                                forEach(state.self.views, function (view, name) {
                                    if(index &lt; changed.first) {
                                        $view.setIfAbsent(name, view.template, view.controller);
                                    } else {
                                        $view.setOrUpdate(name, view.template, view.controller);
                                    }
                                });
                            });
                            emit.between(transition);
                            if(cancel) {
                                transaction.cancel();
                                &#x2F;&#x2F;TODO: Should we do more here?... What about the URL?... Should we reset that to the privous URL?...
                                &#x2F;&#x2F;      That is if this was even triggered by an URL change in teh first place.
                                return;
                            }
                            $state.current = toState;
                            transaction.commit();
                            $rootScope.$broadcast(&#x27;$stateChangeSuccess&#x27;, toState, fromState);
                        }, function (error) {
                            transaction.cancel();
                            $rootScope.$broadcast(&#x27;$stateChangeError&#x27;, toState, fromState, error);
                        }).then(function () {
                            if(!cancel) {
                                transition.cancel = function () {
                                    throw Error(&quot;Can&#x27;t cancel transition in after handler&quot;);
                                };
                                emit.after(transition);
                            }
                            &#x2F;&#x2F;Note: nothing to do here.
                                                    });
                    }
                }
            }        ];
    }];
angular.module(&#x27;ui.routing&#x27;).provider(&#x27;$state&#x27;, $StateProvider);

&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;..&#x2F;lib&#x2F;angular&#x2F;angular-1.0.d.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;common.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;interfaces.d.ts&quot; &#x2F;&gt;
&#x27;use strict&#x27;;
function $TemplateProvider() {
    this.$get = [
        &#x27;$http&#x27;, 
        &#x27;$q&#x27;, 
        &#x27;$injector&#x27;, 
        &#x27;$templateCache&#x27;, 
        function ($http, $q, $injector, $templateCache) {
            function getFromUrl(url) {
                return $http.get(url, {
                    cache: $templateCache
                }).then(function (response) {
                    return response.data;
                });
            }
            function getFromFunction(fn) {
                return $q.when($injector.invoke(fn));
            }
            function getFromObject(obj) {
                if(isDefined(obj.url)) {
                    return getFromUrl(obj.url);
                }
                if(isDefined(obj.fn)) {
                    return getFromFunction(obj.fn);
                }
                if(isDefined(obj.html)) {
                    return $q.when(obj.html);
                }
                throw new Error(&quot;Object must define url, fn or html.&quot;);
            }
            this.get = function (template) {
                &#x2F;&#x2F;TODO: Make a regular expression check?
                if(isString(template)) {
                    return getFromUrl(template);
                }
                if(isFunction(template) || isArray(template)) {
                    return getFromFunction(template);
                }
                if(isObject(template)) {
                    return getFromObject(template);
                }
                throw new Error(&quot;Template must be either an url as string, function or a object defining either url, fn or html.&quot;);
            };
            return this;
        }    ];
}
angular.module(&#x27;ui.routing&#x27;).provider(&#x27;$template&#x27;, $TemplateProvider);

&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;..&#x2F;lib&#x2F;angular&#x2F;angular-1.0.d.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;common.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;interfaces.d.ts&quot; &#x2F;&gt;
&#x27;use strict&#x27;;
function $ViewProvider() {
    this.$get = [
        &#x27;$rootScope&#x27;, 
        &#x27;$q&#x27;, 
        &#x27;$template&#x27;, 
        function ($rootScope, $q, $template) {
            var views = {
            }, transaction = null;
            function ensureName(name) {
                if(name === &#x27;undefined&#x27;) {
                    throw new Error(&#x27;Must define a view name.&#x27;);
                }
            }
            ;
            function ensureExists(name) {
                if(!(name in views)) {
                    throw new Error(&#x27;View with name &quot;&#x27; + name + &#x27;&quot; was not present.&#x27;);
                }
            }
            ;
            function raiseUpdated(name) {
                $rootScope.$broadcast(&#x27;$viewUpdate&#x27;, name);
            }
            function containsView(map, name) {
                return (name in map) &amp;&amp; map[name] !== null;
            }
            this.clear = function (name) {
                var _this = this;
                if(isUndefined(name)) {
                    forEach(views, function (val, key) {
                        _this.clear(key);
                    });
                } else {
                    if(transaction) {
                        transaction.records[name] = {
                            act: &#x27;clear&#x27;,
                            fn: function () {
                                _this.clear(name);
                            }
                        };
                        return;
                    }
                    delete views[name];
                    raiseUpdated(name);
                }
            };
            this.setOrUpdate = function (name, template, controller) {
                var _this = this;
                ensureName(name);
                if(transaction) {
                    transaction.records[name] = {
                        act: &#x27;setOrUpdate&#x27;,
                        fn: function () {
                            _this.setOrUpdate(name, template, controller);
                        }
                    };
                    return;
                }
                if(containsView(views, name)) {
                    &#x2F;&#x2F;TODO: Should we make this latebound so only views actually used gets loaded and rendered?
                    views[name].template = $template.get(template);
                    views[name].controller = controller;
                    views[name].version++;
                } else {
                    views[name] = {
                        template: &#x2F;&#x2F;TODO: Should we make this latebound so only views actually used gets loaded and rendered?
                        $template.get(template),
                        controller: controller,
                        version: 0
                    };
                }
                raiseUpdated(name);
            };
            this.setIfAbsent = function (name, template, controller) {
                var _this = this;
                ensureName(name);
                if(transaction) {
                    if(!containsView(transaction.records, name) || transaction.records[name].act === &#x27;clear&#x27;) {
                        transaction.records[name] = {
                            act: &#x27;setIfAbsent&#x27;,
                            fn: function () {
                                _this.setIfAbsent(name, template, controller);
                            }
                        };
                    }
                    return;
                }
                if(!containsView(views, name)) {
                    views[name] = {
                        template: &#x2F;&#x2F;TODO: Should we make this latebound so only views actually used gets loaded and rendered?
                        $template.get(template),
                        controller: controller,
                        version: 0
                    };
                    raiseUpdated(name);
                }
            };
            this.get = function (name) {
                &#x2F;&#x2F;TODO: return copies instead of actuals...
                if(isUndefined(name)) {
                    return views;
                }
                &#x2F;&#x2F; Ensure checks if the view was defined at any point, not if it is still defined.
                &#x2F;&#x2F; if it was defined but cleared, then null is returned which can be used to clear the view if desired.
                return views[name];
            };
            this.beginUpdate = function () {
                if(transaction) {
                    throw new Error(&quot;Can&#x27;t start multiple transactions&quot;);
                }
                var trx = transaction = {
                    records: {
                    }
                };
                return {
                    commit: function () {
                        transaction = null;
                        forEach(trx.records, function (rec) {
                            rec.fn();
                        });
                    },
                    cancel: function () {
                        transaction = null;
                    }
                };
            };
            return this;
        }    ];
}
angular.module(&#x27;ui.routing&#x27;).provider(&#x27;$view&#x27;, $ViewProvider);

&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;..&#x2F;..&#x2F;lib&#x2F;angular&#x2F;angular-1.0.d.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;..&#x2F;interfaces.d.ts&quot; &#x2F;&gt;
&#x2F;&#x2F;&#x2F; &lt;reference path=&quot;..&#x2F;common.ts&quot; &#x2F;&gt;
&#x27;use strict&#x27;;
var uiViewDirective = [
    &#x27;$state&#x27;, 
    &#x27;$anchorScroll&#x27;, 
    &#x27;$compile&#x27;, 
    &#x27;$controller&#x27;, 
    &#x27;$view&#x27;, 
    function ($state, $anchorScroll, $compile, $controller, $view) {
        return {
            restrict: &#x27;ECA&#x27;,
            terminal: true,
            link: function (scope, element, attr) {
                var viewScope, name = attr[&#x27;uiView&#x27;] || attr.name, onloadExp = attr.onload || &#x27;&#x27;, version = -1;
                &#x2F;&#x2F; Find the details of the parent view directive (if any) and use it
                &#x2F;&#x2F; to derive our own qualified view name, then hang our own details
                &#x2F;&#x2F; off the DOM so child directives can find it.
                &#x2F;&#x2F;   var parent = element.parent().inheritedData(&#x27;$uiView&#x27;);
                &#x2F;&#x2F;   name = name + &#x27;@&#x27; + (parent ? parent.state.name : &#x27;&#x27;);
                &#x2F;&#x2F;   var view = { name: name, state: null };
                &#x2F;&#x2F;   element.data(&#x27;$uiView&#x27;, view);
                scope.$on(&#x27;$stateChangeBegin&#x27;, function () {
                });
                scope.$on(&#x27;$viewChanged&#x27;, function (event, updatedName) {
                    if(updatedName === name) {
                        update();
                    }
                });
                scope.$on(&#x27;$stateChangeSuccess&#x27;, update);
                update();
                function resetScope(newScope) {
                    if(viewScope) {
                        viewScope.$destroy();
                    }
                    viewScope = newScope === &#x27;undefined&#x27; ? null : newScope;
                }
                function clearContent() {
                    element.html(&#x27;&#x27;);
                    resetScope();
                }
                function update() {
                    var view = $view.get(name), controller;
                    if(view &amp;&amp; view.template) {
                        if(view.version === version) {
                            return;
                        }
                        version = view.version;
                        controller = view.controller;
                        view.template.then(function (html) {
                            element.html(html);
                            resetScope(scope.$new());
                            var link = $compile(element.contents());
                            if(controller) {
                                controller = $controller(controller, {
                                    $scope: viewScope
                                });
                                element.contents().data(&#x27;$ngControllerController&#x27;, controller);
                            }
                            link(viewScope);
                            viewScope.$emit(&#x27;$viewContentLoaded&#x27;);
                            viewScope.$eval(onloadExp);
                            $anchorScroll();
                        });
                    } else {
                        clearContent();
                    }
                }
            }
        };
    }];
angular.module(&#x27;ui.routing&#x27;).directive(&#x27;uiView&#x27;, uiViewDirective);

})(window, document);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
