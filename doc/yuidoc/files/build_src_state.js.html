<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>build\src\state.js - angular-routing</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="angular-routing"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: build\src\state.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/// &lt;reference path=&quot;../lib/angular/angular-1.0.d.ts&quot; /&gt;
/// &lt;reference path=&quot;common.ts&quot; /&gt;
/// &lt;reference path=&quot;interfaces.d.ts&quot; /&gt;
/// &lt;reference path=&quot;state/state.ts&quot; /&gt;
/// &lt;reference path=&quot;state/stateFactory.ts&quot; /&gt;
/// &lt;reference path=&quot;state/stateRules.ts&quot; /&gt;
/// &lt;reference path=&quot;state/stateComparer.ts&quot; /&gt;
/// &lt;reference path=&quot;state/stateBrowser.ts&quot; /&gt;
/// &lt;reference path=&quot;state/stateUrlBuilder.ts&quot; /&gt;
/**
* @ngdoc object
* @name dotjem.routing.$stateProvider
*
* @description
* Used for configuring states. See {@link dotjem.routing.$state $state} for an example.
*/
var $StateProvider = [
    &#x27;$routeProvider&#x27;, 
    &#x27;$stateTransitionProvider&#x27;, 
    function ($routeProvider, $transitionProvider) {
        &#x27;use strict&#x27;;
        //TODO: maybe create a stateUtilityProvider that can serve as a factory for all these helpers.
        //      it would make testing of them individually easier, although it would make them more public than
        //      they are right now.
                var factory = new StateFactory($routeProvider, $transitionProvider), root = factory.createState(&#x27;root&#x27;, {
        }), browser = new StateBrowser(root), comparer = new StateComparer();
        /**
        * @ngdoc method
        * @name dotjem.$stateProvider#state
        * @methodOf dotjem.routing.$stateProvider
        *
        * @param {string} fullname Full name of the state, use &#x27;.&#x27; to seperate parent and child states.
        *
        * E.g. if the full name &quot;home&quot; is given, the state is directly located under the root.
        * It then becomes possible to register &quot;home.recents&quot; as a child named &quot;recents&quot; under the state &quot;home&quot;.
        *
        * The following registrations would result in the ilustated hierachy.
        *
        * &#x60;.state(&#x27;home&#x27;, {})&#x60;
        * &#x60;.state(&#x27;home.recents&#x27;, {})&#x60;
        * &#x60;.state(&#x27;home.all&#x27;, {})&#x60;
        * &#x60;.state(&#x27;staff&#x27;, {})&#x60;
        * &#x60;.state(&#x27;staff.all&#x27;, {})&#x60;
        * &#x60;.state(&#x27;staff.single&#x27;, {})&#x60;
        *
        *   - home
        *     - recents
        *     - all
        *   - staff
        *     - all
        *     - single
        *
        * @param {Object} state All information about the state.
        *
        *    Object properties:
        *
        * - &#x60;views&#x60;: &#x60;{Object}&#x60; A list og views to be updated when the state is activated.
        * - &#x60;route&#x60;: &#x60;{string}&#x60; A route to associate the state with,
        *   this will be registered with the {@link dotjem.routing.$routeProvider $routeProvider}
        * - &#x60;onEnter&#x60;: &#x60;{string|function|Object}&#x60; value
        * - &#x60;onExit&#x60;: &#x60;{string|function|Object}&#x60; value
        * - &#x60;reloadOnSearch&#x60;: &#x60;{bool}&#x60; If associated with a route, should that route reload on search.
        * - &#x60;scrollTo&#x60;: {string=} ï¿½ A element to scroll to when the state has been loaded.
        *
        * @returns {Object} self
        *
        * @description
        * Adds a new route definition to the &#x60;$route&#x60; service.
        */
        this.state = function (fullname, state) {
            StateRules.validateName(fullname);
            var parent = browser.lookup(fullname, 1);
            parent.add(factory.createState(fullname, state, parent));
            return this;
        };
        this.$get = [
            &#x27;$rootScope&#x27;, 
            &#x27;$q&#x27;, 
            &#x27;$injector&#x27;, 
            &#x27;$route&#x27;, 
            &#x27;$view&#x27;, 
            &#x27;$stateTransition&#x27;, 
            &#x27;$location&#x27;, 
            &#x27;$scroll&#x27;, 
            function ($rootScope, $q, $injector, $route, $view, $transition, $location, $scroll) {
                /**
                * @ngdoc object
                * @name dotjem.routing.$state
                *
                * @requires $rootScope
                * @requires $q
                * @requires $injector
                * @requires $route
                * @requires $view
                * @requires $stateTransition
                * @requires $location
                * @requires $scroll
                *
                * @property {Object} current Reference to the current state loaded.
                *
                * @description
                *
                * You can define states through {@link dotjem.routing.$stateProvider $stateProvider}&#x27;s API.
                */
                /**
                * @ngdoc event
                * @name dotjem.routing.$state#$stateChangeStart
                * @eventOf dotjem.routing.$state
                *
                * @eventType broadcast on root scope
                *
                * @description
                * Broadcasted before a route change. At this  point the route services starts
                * resolving all of the dependencies needed for the route change to occurs.
                *
                * @param {Object} angularEvent Synthetic event object.
                * @param {State} next Future state.
                * @param {State} current Current state.
                */
                /**
                * @ngdoc event
                * @name dotjem.routing.$state#$stateChangeSuccess
                * @eventOf dotjem.routing.$state
                *
                * @eventType broadcast on root scope
                *
                * @description
                * Broadcasted after a route dependencies are resolved.
                *
                * @param {Object} angularEvent Synthetic event object.
                * @param {State} next Future state.
                * @param {State} current Current state.
                */
                /**
                * @ngdoc event
                * @name dotjem.routing.$state#$stateChangeError
                * @eventOf dotjem.routing.$state
                *
                * @eventType broadcast on root scope
                *
                * @description
                * Broadcasted if any of the resolve promises are rejected.
                *
                * @param {Object} angularEvent Synthetic event object.
                * @param {State} next Future state.
                * @param {State} current Current state.
                * @param {Object} rejection Rejection of the promise. Usually the error of the failed promise.
                */
                /**
                * @ngdoc event
                * @name dotjem.routing.$state#$stateUpdate
                * @eventOf dotjem.routing.$state
                *
                * @eventType broadcast on root scope
                *
                * @description
                */
                /**
                * @ngdoc method
                * @name dotjem.routing.$state#goto
                * @methodOf dotjem.routing.$state
                *
                * @param {State|string} state Current state.
                * @param {Object} params Current state.
                *
                * @description
                * Goes to the specified state,
                */
                /**
                * @ngdoc method
                * @name dotjem.routing.$state#lookup
                * @methodOf dotjem.routing.$state
                *
                * @param {string} path Expression to resolve or the full name of a state.
                *
                * @description
                * Finds a state based on the provided expression or name.
                */
                /**
                * @ngdoc method
                * @name dotjem.routing.$state#reload
                * @methodOf dotjem.routing.$state
                *
                * @param {State|string|boolean=} state Name or State in the current hierachy or true/false
                *
                * @description
                * Reloads the state and associated views.
                */
                /**
                * @ngdoc method
                * @name dotjem.routing.$state#url
                * @methodOf dotjem.routing.$state
                *
                * @param {State|string=} state A state to generate an URL for
                * @param {Object=} params A set of parameters to use when generating the url
                *
                * @description
                * An url generated from the provided parameters.
                */
                var urlbuilder = new StateUrlBuilder($route);
                var forceReload = null, current = root, currentParams = {
                }, $state = {
                    root: // NOTE: root should not be used in general, it is exposed for testing purposes.
                    root,
                    current: extend({
                    }, root.self),
                    goto: function (state, params) {
                        goto({
                            state: state,
                            params: {
                                all: params
                            },
                            updateroute: true
                        });
                    },
                    lookup: function (path) {
                        return browser.resolve(current, path);
                    },
                    reload: reload,
                    url: function (state, params) {
                        state = isDefined(state) ? browser.lookup(toName(state)) : current;
                        return urlbuilder.buildUrl($state.current, state, params);
                    }
                };
                $rootScope.$on(&#x27;$routeChangeSuccess&#x27;, function () {
                    var route = $route.current, params;
                    if(route) {
                        params = {
                            all: route.params,
                            path: route.pathParams,
                            search: route.searchParams
                        };
                        if(route.state) {
                            goto({
                                state: route.state,
                                params: params,
                                route: route
                            });
                        }
                    } else {
                        goto({
                            state: root
                        });
                    }
                });
                $rootScope.$on(&#x27;$routeUpdate&#x27;, function () {
                    var route = $route.current;
                    raiseUpdate(route.params, route.pathParams, route.searchParams);
                });
                return $state;
                function reload(state) {
                    if(isDefined(state)) {
                        if(isString(state) || isObject(state)) {
                            forceReload = toName(state);
                            //TODO: We need some name normalization OR a set of &quot;compare&quot; etc methods that can ignore root.
                            if(forceReload.indexOf(&#x27;root&#x27;) !== 0) {
                                forceReload = &#x27;root.&#x27; + forceReload;
                            }
                        } else if(state) {
                            forceReload = root.fullname;
                        }
                    } else {
                        forceReload = current.fullname;
                    }
                    $rootScope.$evalAsync(function () {
                        goto({
                            state: current,
                            params: currentParams,
                            route: $route.current
                        });
                    });
                }
                function raiseUpdate(all, path, search) {
                    var dst = $state.current.$params;
                    dst.all = all;
                    dst.path = path;
                    dst.search = search;
                    $rootScope.$broadcast(&#x27;$stateUpdate&#x27;, $state.current);
                }
                function goto(args) {
                    //TODO: This list of declarations seems to indicate that we are doing more that we should in a single function.
                    //      should try to refactor it if possible.
                                        var params = args.params, route = args.route, to = browser.lookup(toName(args.state)), toState = // lookupState(toName(args.state)),
                    extend({
                    }, to.self, {
                        $params: params,
                        $route: route
                    }), fromState = $state.current, emit = $transition.find($state.current, toState), cancel = false, transaction, scrollTo, changed = comparer.compare(browser.lookup(toName($state.current)), to, fromState.$params &amp;&amp; fromState.$params.all, params &amp;&amp; params.all || {
                    }, forceReload), transition = {
                        cancel: function () {
                            cancel = true;
                        },
                        goto: function (state, params) {
                            cancel = true;
                            goto({
                                state: state,
                                params: {
                                    all: params
                                },
                                updateroute: true
                            });
                        }
                    };
                    if(!forceReload &amp;&amp; !changed.stateChanges) {
                        if(changed.paramChanges) {
                            raiseUpdate(params.all || {
                            }, params.path || {
                            }, params.search || {
                            });
                        }
                        return;
                    }
                    forceReload = null;
                    if(args.updateroute &amp;&amp; to.route) {
                        //TODO: This is very similar to what we do in buildStateArray -&gt; extractParams,
                        //      maybe we can refactor those together
                                                var paramsObj = {
                        }, allFrom = (fromState.$params &amp;&amp; fromState.$params.all) || {
                        };
                        forEach(to.route.params, function (param, name) {
                            if(name in allFrom) {
                                paramsObj[name] = allFrom[name];
                            }
                        });
                        var mergedParams = extend(paramsObj, (params &amp;&amp; params.all));
                        $route.change(extend({
                        }, to.route, {
                            params: mergedParams
                        }));
                        return;
                    }
                    emit.before(transition);
                    if(cancel) {
                        //TODO: Should we do more here?... What about the URL?... Should we reset that to the privous URL?...
                        //      That is if this was even triggered by an URL change in the first place.
                        return;
                    }
                    var event = $rootScope.$broadcast(&#x27;$stateChangeStart&#x27;, toState, fromState);
                    if(!event.defaultPrevented) {
                        $q.when(toState).then(function () {
                            var useUpdate = false, locals = {
                            }, promises = [];
                            transaction = $view.beginUpdate();
                            $view.clear();
                            function resolve(args) {
                                var values = [], keys = [];
                                angular.forEach(args || {
                                }, function (value, key) {
                                    keys.push(key);
                                    values.push(angular.isString(value) ? $injector.get(value) : $injector.invoke(value));
                                });
                                var def = $q.defer();
                                $q.all(values).then(function (values) {
                                    angular.forEach(values, function (value, index) {
                                        locals[keys[index]] = value;
                                    });
                                    def.resolve(locals);
                                });
                                return def.promise;
                            }
                            var promise = $q.when(0);
                            forEach(changed.array, function (change, index) {
                                promise = promise.then(function () {
                                    return resolve(change.state.resolve);
                                }).then(function (locals) {
                                    if(change.isChanged) {
                                        useUpdate = true;
                                    }
                                    scrollTo = change.state.scrollTo;
                                    forEach(change.state.views, function (view, name) {
                                        var sticky, fn;
                                        if(view.sticky) {
                                            sticky = view.sticky;
                                            if((fn = injectFn(sticky)) != null) {
                                                sticky = fn($injector, {
                                                    $to: toState,
                                                    $from: fromState
                                                });
                                            } else if(!isString(sticky)) {
                                                sticky = change.state.fullname;
                                            }
                                        }
                                        if(useUpdate || isDefined(sticky)) {
                                            $view.setOrUpdate(name, view.template, view.controller, copy(locals), sticky);
                                        } else {
                                            $view.setIfAbsent(name, view.template, view.controller, copy(locals));
                                        }
                                    });
                                });
                            });
                            return promise.then(function () {
                                emit.between(transition);
                                if(cancel) {
                                    transaction.cancel();
                                    //TODO: Should we do more here?... What about the URL?... Should we reset that to the privous URL?...
                                    //      That is if this was even triggered by an URL change in teh first place.
                                    return;
                                }
                                current = to;
                                currentParams = params;
                                $state.current = toState;
                                transaction.commit();
                                $rootScope.$broadcast(&#x27;$stateChangeSuccess&#x27;, toState, fromState);
                            });
                        }, function (error) {
                            transaction.cancel();
                            $rootScope.$broadcast(&#x27;$stateChangeError&#x27;, toState, fromState, error);
                        }).then(function () {
                            if(!cancel) {
                                transition.cancel = function () {
                                    throw Error(&quot;Can&#x27;t cancel transition in after handler&quot;);
                                };
                                emit.after(transition);
                                $scroll(scrollTo);
                            }
                            //Note: nothing to do here.
                                                    });
                    }
                }
            }        ];
    }];
angular.module(&#x27;dotjem.routing&#x27;).provider(&#x27;$state&#x27;, $StateProvider);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
