<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>build\src\route.js - angular-routing</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="angular-routing"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/$RouteProvider.html">$RouteProvider</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: build\src\route.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/// &lt;reference path=&quot;../lib/angular/angular-1.0.d.ts&quot; /&gt;
/// &lt;reference path=&quot;common.ts&quot; /&gt;
/// &lt;reference path=&quot;interfaces.d.ts&quot; /&gt;
&#x27;use strict&#x27;;
/**
* Used for configuring routes. See {@link dotjem.routing.$route $route} for an example.
*
* @class $RouteProvider
* @constructor
*/
function $RouteProvider() {
    var _this = this;
    var routes = {
    }, converters = {
    }, decorators = {
    }, caseSensitive = true;
    //Public Methods
    /**
    * Adds a new converter or overwrites an existing one.
    *
    * By default the folowing converters are precent:
    *  - &#x60;&#x60; - default Converter, used on all parameters that doesn&#x27;t specify a converter.
    *    Matches any input.
    *
    *  - &#x60;num&#x60; - number converter, used to only mach numeric values.
    *
    *  - &#x60;regex&#x60; - regular expressions converter, used to match a parameter agains a regular
    *    expression.
    *
    * @method convert
    * @return {Object} self
    *
    * @param {string} name Cerverter name, used in the path when registering routes through the
    *   {@link dotjem.routing.routeProvider#when when} function.
    */
    this.convert = function (name, converter) {
        //Note: We wan&#x27;t to allow overwrite
        converters[name] = converter;
        return _this;
    };
    /**
    * Adds a new route definition to the &#x60;$route&#x60; service.
    *
    * @method when
    * @returns {Object} self
    *
    * @param {string} path Route path (matched against &#x60;$location.path&#x60;). If &#x60;$location.path&#x60;
    *    contains redundant trailing slash or is missing one, the route will still match.
    *
    *    &#x60;path&#x60; can contain named groups starting with a colon (&#x60;:name&#x60;) or curly brackets (&#x60;{name}&#x60;).
    *    All characters up to the next slash are matched and stored in &#x60;$routeParams&#x60; under the
    *    given &#x60;name&#x60; when the route matches.
    *
    *    Further, when using the curly bracket syntax, converters can be used to match only specific
    *    values, (&#x60;{num:name}&#x60;) will only match numerical values and (&#x60;{regex(\d{1,2}[a-z]+):name}&#x60;)
    *    would only match a parameter starting with one or two digits followed by a number of
    *    characters between &#x27;a&#x27; and &#x27;z&#x27;.
    *
    *    More converters can be registered using the {@link dotjem.routing.routeProvider#convert convert}
    *    function.
    *
    * @param {Object} route Mapping information to be assigned to &#x60;$route.current&#x60; on route
    *    match.
    *
    *    Object properties:
    *
    *    - &#x60;state&#x60; � &#x60;{string}&#x60; � a state that should be activated when the route is matched.
    *    - &#x60;action&#x60; � &#x60;{(string|function()=}&#x60; � an action that should be performed when the route is matched.
    *
    *    Legacy support for the following when using the {@link dotjem.routing.legacy dotjem.routing.legacy}
    *    module.
    *
    *    - &#x60;controller&#x60; � &#x60;{(string|function()=}&#x60; � Controller fn that should be associated with newly
    *      created scope or the name of a {@link angular.Module#controller registered controller}
    *      if passed as a string.
    *    - &#x60;template&#x60; � &#x60;{string=|function()=}&#x60; � html template as a string or function that returns
    *      an html template as a string which should be used by {@link ng.directive:ngView ngView} or
    *      {@link ng.directive:ngInclude ngInclude} directives.
    *      This property takes precedence over &#x60;templateUrl&#x60;.
    *
    *      If &#x60;template&#x60; is a function, it will be called with the following parameters:
    *
    *      - &#x60;{Array.&lt;Object&gt;}&#x60; - route parameters extracted from the current
    *        &#x60;$location.path()&#x60; by applying the current route
    *
    *    - &#x60;templateUrl&#x60; � &#x60;{string=|function()=}&#x60; � path or function that returns a path to an html
    *      template that should be used by {@link ng.directive:ngView ngView}.
    *
    *      If &#x60;templateUrl&#x60; is a function, it will be called with the following parameters:
    *
    *      - &#x60;{Array.&lt;Object&gt;}&#x60; - route parameters extracted from the current
    *        &#x60;$location.path()&#x60; by applying the current route
    *
    *    - &#x60;resolve&#x60; - &#x60;{Object.&lt;string, function&gt;=}&#x60; - An optional map of dependencies which should
    *      be injected into the controller. If any of these dependencies are promises, they will be
    *      resolved and converted to a value before the controller is instantiated and the
    *      &#x60;$routeChangeSuccess&#x60; event is fired. The map object is:
    *
    *      - &#x60;key&#x60; � &#x60;{string}&#x60;: a name of a dependency to be injected into the controller.
    *      - &#x60;factory&#x60; - &#x60;{string|function}&#x60;: If &#x60;string&#x60; then it is an alias for a service.
    *        Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}
    *        and the return value is treated as the dependency. If the result is a promise, it is resolved
    *        before its value is injected into the controller.
    *
    *    - &#x60;redirectTo&#x60; � {(string|function())=} � value to update
    *      {@link ng.$location $location} path with and trigger route redirection.
    *
    *      If &#x60;redirectTo&#x60; is a function, it will be called with the following parameters:
    *
    *      - &#x60;{Object.&lt;string&gt;}&#x60; - route parameters extracted from the current
    *        &#x60;$location.path()&#x60; by applying the current route templateUrl.
    *      - &#x60;{string}&#x60; - current &#x60;$location.path()&#x60;
    *      - &#x60;{Object}&#x60; - current &#x60;$location.search()&#x60;
    *
    *      The custom &#x60;redirectTo&#x60; function is expected to return a string which will be used
    *      to update &#x60;$location.path()&#x60; and &#x60;$location.search()&#x60;.
    *
    *    - &#x60;[reloadOnSearch=true]&#x60; - {boolean=} - reload route when only $location.search()
    *    changes.
    *
    *      If the option is set to &#x60;false&#x60; and url in the browser changes, then
    *      &#x60;$routeUpdate&#x60; event is broadcasted on the root scope.
    */
    this.when = function (path, route) {
        var expression = parseExpression(path);
        routes[expression.name] = {
            self: extend({
                reloadOnSearch: true
            }, route),
            redirect: createRedirector(route.redirectTo),
            match: createMatcher(path, expression),
            params: expression.params,
            path: path
        };
        return {
            convert: _this.convert,
            when: _this.when,
            otherwise: _this.otherwise,
            decorate: _this.decorate,
            ignoreCase: _this.ignoreCase,
            matchCase: _this.matchCase,
            $route: {
                name: expression.name,
                params: copy(expression.params),
                route: path
            }
        };
    };
    /**
    * Sets route definition that will be used on route change when no other route definition
    * is matched.
    *
    * @method otherwise
    * @return {Object} self
    *
    * @param {Object} params Mapping information to be assigned to &#x60;$route.current&#x60;.
    */
    this.otherwise = function (route) {
        _this.when(null, route);
        return _this;
    };
    this.decorate = function (name, decorator) {
        //Note: We wan&#x27;t to allow overwrite
        decorators[name] = decorator;
        return _this;
    };
    this.ignoreCase = function () {
        caseSensitive = false;
        return _this;
    };
    this.matchCase = function () {
        caseSensitive = true;
        return _this;
    };
    //Scoped Methods
    function createRedirector(redirectTo) {
        var fn = null;
        return function ($location, next) {
            if(fn === null) {
                if(redirectTo) {
                    if(isString(redirectTo)) {
                        fn = function ($location, next) {
                            var interpolated = interpolate(redirectTo, next.params);
                            $location.path(interpolated).search(next.params).replace();
                        };
                    } else {
                        fn = function ($location, next) {
                            $location.url(redirectTo(next.pathParams, $location.path(), $location.search())).replace();
                        };
                    }
                } else {
                    fn = function () {
                    };
                }
            }
            return fn($location, next);
        };
    }
    function createParameter(name, converter, cargs) {
        var trimmed;
        if(cargs) {
            trimmed = cargs.trim();
            if((trimmed[0] === &#x27;{&#x27; &amp;&amp; trimmed[trimmed.length - 1] === &#x27;}&#x27;) || (trimmed[0] === &#x27;[&#x27; &amp;&amp; trimmed[trimmed.length - 1] === &#x27;]&#x27;)) {
                try  {
                    cargs = angular.fromJson(trimmed);
                } catch (e) {
                    //Note: Errors are ok here, we let it remain as a string.
                                    }
            }
        }
        return {
            name: name,
            converter: function () {
                return converters[converter](cargs);
            }
        };
    }
    function interpolate(url, params) {
        //TODO: Are we missing calls to some &quot;Encode URI component&quot;?
                var result = [], name = &quot;&quot;, index = 0;
        forEach(parseParams(url), function (param, idx) {
            var formatter = function (val) {
                return val.toString();
            }, converter = createParameter(param.name, param.converter, param.args).converter();
            if(!isFunction(converter) &amp;&amp; isDefined(converter.format)) {
                formatter = converter.format;
            }
            name += url.slice(index, param.index) + &#x27;/&#x27; + formatter(params[param.name]);
            index = param.lastIndex;
            delete params[param.name];
        });
        name += url.substr(index);
        return name;
    }
    var esc = /[-\/\\^$*+?.()|[\]{}]/g;
    function escape(exp) {
        return exp.replace(esc, &quot;\\$&amp;&quot;);
    }
    var paramsRegex = new RegExp(&#x27;\x2F((:(\\w+))|(\\{((\\w+)(\\((.*?)\\))?:)?(\\w+)\\}))&#x27;, &#x27;g&#x27;);
    function parseParams(path) {
        var match, params = [];
        if(path === null) {
            return params;
        }
        while((match = paramsRegex.exec(path)) !== null) {
            params.push({
                name: match[3] || match[9],
                converter: match[6] || &#x27;&#x27;,
                args: match[8],
                index: match.index,
                lastIndex: paramsRegex.lastIndex
            });
        }
        return params;
    }
    function parseExpression(path) {
        var regex = &quot;^&quot;, name = &quot;&quot;, segments = [], index = 0, flags = &#x27;&#x27;, params = {
        };
        if(path === null) {
            return {
                name: null,
                params: params
            };
        }
        if(path === &#x27;/&#x27;) {
            return {
                exp: new RegExp(&#x27;^[\x2F]?$&#x27;, flags),
                segments: [],
                name: name,
                params: params
            };
        }
        forEach(parseParams(path), function (param, idx) {
            var cname = &#x27;&#x27;;
            regex += escape(path.slice(index, param.index));
            regex += &#x27;/([^\\/]*)&#x27;;
            if(param.converter !== &#x27;&#x27;) {
                cname = &quot;:&quot; + param.converter;
            }
            name += path.slice(index, param.index) + &#x27;/$&#x27; + idx + cname;
            params[param.name] = {
                id: idx,
                converter: param.converter
            };
            segments.push(createParameter(param.name, param.converter, param.args));
            index = param.lastIndex;
        });
        regex += escape(path.substr(index));
        name += path.substr(index);
        if(!caseSensitive) {
            name = name.toLowerCase();
            flags += &#x27;i&#x27;;
        }
        if(regex[regex.length - 1] === &#x27;\x2F&#x27;) {
            regex = regex.substr(0, regex.length - 1);
        }
        return {
            exp: new RegExp(regex + &#x27;\x2F?$&#x27;, flags),
            segments: segments,
            name: name,
            params: params
        };
    }
    function createMatcher(path, expression) {
        if(path == null) {
            return function (location) {
            };
        }
        return function (location) {
            var match = location.match(expression.exp), dst = {
            }, invalidParam;
            if(match) {
                invalidParam = false;
                forEach(expression.segments, function (segment, index) {
                    var param, value, converter;
                    if(!invalidParam) {
                        param = match[index + 1];
                        converter = segment.converter();
                        if(!isFunction(converter) &amp;&amp; isDefined(converter.parse)) {
                            converter = converter.parse;
                        }
                        value = converter(param);
                        if(isDefined(value.accept)) {
                            if(!value.accept) {
                                invalidParam = true;
                            }
                            dst[segment.name] = value.value;
                        } else {
                            if(!value) {
                                invalidParam = true;
                            }
                            dst[segment.name] = param;
                        }
                    }
                });
                if(!invalidParam) {
                    return dst;
                }
            }
        };
    }
    //Registration of Default Converters
    this.convert(&#x27;num&#x27;, function () {
        return {
            parse: function (param) {
                var accepts = !isNaN(param);
                return {
                    accept: accepts,
                    value: accepts ? Number(param) : 0
                };
            },
            format: function (value) {
                if(isNaN(value)) {
                    throw new Error(errors.invalidNumericValue);
                }
                return value.toString();
            }
        };
    });
    this.convert(&#x27;regex&#x27;, function (arg) {
        var exp, flags = &#x27;&#x27;, regex;
        if(isObject(arg) &amp;&amp; isDefined(arg.exp)) {
            exp = arg.exp;
            if(isDefined(arg.flags)) {
                flags = arg.flags;
            }
        } else if(isString(arg) &amp;&amp; arg.length &gt; 0) {
            exp = arg;
        } else {
            throw Error(errors.regexConverterNotValid);
        }
        regex = new RegExp(exp, flags);
        return {
            parse: function (param) {
                var accepts = regex.test(param);
                return {
                    accept: accepts,
                    value: accepts ? regex.exec(param) : null
                };
            },
            format: function (value) {
                var str = value.toString();
                var test = regex.test(str);
                if(!test) {
                    throw Error(errors.valueCouldNotBeMatchedByRegex);
                }
                return str;
            }
        };
    });
    this.convert(&#x27;&#x27;, function () {
        return function (param) {
            return true;
        };
    });
    //Service Factory
    this.$get = [
        &#x27;$rootScope&#x27;, 
        &#x27;$location&#x27;, 
        &#x27;$q&#x27;, 
        &#x27;$injector&#x27;, 
        &#x27;$routeParams&#x27;, 
        function ($rootScope, $location, $q, $injector, $routeParams) {
            var forceReload = false, $route = {
                routes: routes,
                reload: function () {
                    forceReload = true;
                    $rootScope.$evalAsync(update);
                },
                change: function (args) {
                    var params = args.params || {
                    }, route = interpolate(args.route, params), loc = $location.path(route).search(params || {
                    });
                    if(args.replace) {
                        loc.replace();
                    }
                },
                format: function (route, params) {
                    var params = params || {
                    };
                    return interpolate(route, params) + toKeyValue(params);
                }
            };
            $rootScope.$on(&#x27;$locationChangeSuccess&#x27;, update);
            return $route;
            function buildmatch(route, params, search) {
                var match = inherit(route, {
                    self: inherit(route.self, {
                        params: extend({
                        }, search, params),
                        searchParams: search,
                        pathParams: params
                    })
                });
                return match;
            }
            function findroute(currentPath) {
                var params, match;
                forEach(routes, function (route, path) {
                    if(!match &amp;&amp; (params = route.match(currentPath))) {
                        match = buildmatch(route, params, $location.search());
                    }
                });
                return match || routes[null] &amp;&amp; buildmatch(routes[null], {
                }, {
                });
            }
            function update() {
                var next = findroute($location.path()), lastRoute = $route.current, nextRoute = next ? next.self : undefined;
                if(!forceReload &amp;&amp; nextRoute &amp;&amp; lastRoute &amp;&amp; angular.equals(nextRoute.pathParams, lastRoute.pathParams) &amp;&amp; !nextRoute.reloadOnSearch) {
                    lastRoute.params = next.params;
                    lastRoute.searchParams = next.searchParams;
                    lastRoute.pathParams = next.pathParams;
                    copy(nextRoute.params, $routeParams);
                    $rootScope.$broadcast(&#x27;$routeUpdate&#x27;, lastRoute);
                } else if(next || lastRoute) {
                    //TODO: We should always have a next to go to, it may be a null route though.
                    forceReload = false;
                    var event = $rootScope.$broadcast(&#x27;$routeChangeStart&#x27;, nextRoute, lastRoute);
                    if(!event.defaultPrevented) {
                        $route.current = nextRoute;
                        if(next) {
                            next.redirect($location, nextRoute);
                        }
                        var dp = $q.when(nextRoute);
                        if(nextRoute) {
                            forEach(decorators, function (decorator, name) {
                                dp = dp.then(function () {
                                    //Note: must keep nextRoute as &quot;this&quot; context here.
                                    var decorated = $injector.invoke(decorator, nextRoute, {
                                        $next: nextRoute
                                    });
                                    return $q.when(decorated);
                                });
                            });
                        }
                        dp.then(function () {
                            if(nextRoute === $route.current) {
                                if(next) {
                                    angular.copy(nextRoute.params, $routeParams);
                                }
                                $rootScope.$broadcast(&#x27;$routeChangeSuccess&#x27;, nextRoute, lastRoute);
                            }
                        }, function (error) {
                            if(nextRoute === $route.current) {
                                $rootScope.$broadcast(&#x27;$routeChangeError&#x27;, nextRoute, lastRoute, error);
                            }
                        });
                    } else {
                        //TODO: Do we need to do anything if the user cancels?
                        //       - if the user wants to return to the old url, he should cancel on
                        //         location change instead?
                                            }
                }
            }
        }    ];
}
angular.module(&#x27;dotjem.routing&#x27;).provider(&#x27;$route&#x27;, $RouteProvider).value(&#x27;$routeParams&#x27;, {
});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
