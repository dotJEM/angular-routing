<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>build\src\stateTransition.js - angular-routing</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="angular-routing"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: build\src\stateTransition.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/// &lt;reference path=&quot;../lib/angular/angular-1.0.d.ts&quot; /&gt;
/// &lt;reference path=&quot;common.ts&quot; /&gt;
/// &lt;reference path=&quot;interfaces.d.ts&quot; /&gt;
/**
* @ngdoc object
* @name dotjem.routing.$stateTransitionProvider
*
* @description
* Used for configuring states. See {@link dotjem.routing.$state $state} for an example.
*/
function $StateTransitionProvider() {
    &#x27;use strict&#x27;;
    var root = {
        children: {
        },
        targets: {
        }
    }, validation = /^\w+(\.\w+)*(\.[*])?$/, _this = this;
    function alignHandler(obj) {
        var result = {
            handler: {
            }
        };
        if(isDefined(obj.to)) {
            result.to = obj.to;
        }
        if(isDefined(obj.from)) {
            result.from = obj.from;
        }
        if(isDefined(obj.handler)) {
            result.handler = obj.handler;
        }
        if(isDefined(obj.before) &amp;&amp; isUndefined(result.handler.before)) {
            result.handler.before = obj.before;
        }
        if(isDefined(obj.between) &amp;&amp; isUndefined(result.handler.between)) {
            result.handler.between = obj.between;
        }
        if(isDefined(obj.after) &amp;&amp; isUndefined(result.handler.after)) {
            result.handler.after = obj.after;
        }
        return result;
    }
    /**
    * @ngdoc method
    * @name dotjem.routing.$stateTransitionProvider#onEnter
    * @methodOf dotjem.routing.$stateTransitionProvider
    *
    * @param {string|State|Array} state The state we are transitioning to.
    * @param {funtion|Object} onenter The handler to invoke when entering the state.
    *
    * @description
    */
    this.onEnter = function (state, onenter) {
        //TODO: Validation
        if(isObject(onenter)) {
            var aligned = alignHandler(onenter);
            this.transition(aligned.from || &#x27;*&#x27;, state, aligned.handler);
        } else if(isFunction(onenter) || isArray(onenter)) {
            this.transition(&#x27;*&#x27;, state, onenter);
        }
    };
    /**
    * @ngdoc method
    * @name dotjem.routing.$stateTransitionProvider#onExit
    * @methodOf dotjem.routing.$stateTransitionProvider
    *
    * @param {string|State|Array} state The state we are transitioning from.
    * @param {funtion|Object} onexit The handler to invoke when entering the state.
    *
    * @description
    */
    this.onExit = function (state, onexit) {
        if(isObject(onexit)) {
            var aligned = alignHandler(onexit);
            this.transition(state, aligned.to || &#x27;*&#x27;, aligned.handler);
        } else if(isFunction(onexit) || isArray(onexit)) {
            this.transition(state, &#x27;*&#x27;, onexit);
        }
    };
    /**
    * @ngdoc method
    * @name dotjem.routing.$stateTransitionProvider#transition
    * @methodOf dotjem.routing.$stateTransitionProvider
    *
    * @param {string|State|Array} from The state we are transitioning from.
    * @param {string|State|Array} to The state we are transitioning to.
    * @param {funtion|Object} handler The handler to invoke when the transitioning occurs.
    *
    * @description
    */
    this.transition = function (from, to, handler) {
        var _this = this;
        var transition, regHandler;
        if(isArray(from)) {
            forEach(from, function (value) {
                _this.transition(value, to, handler);
            });
        } else if(isArray(to)) {
            forEach(to, function (value) {
                _this.transition(from, value, handler);
            });
        } else {
            from = toName(from);
            to = toName(to);
            // We ignore the situation where to and from are the same explicit state.
            // Reason to ignore is the array ways of registering transitions, it could easily happen that a fully named
            // state was in both the target and source array, and it would be a hassle for the user if he had to avoid that.
            if(to === from &amp;&amp; to.indexOf(&#x27;*&#x27;) === -1) {
                return this;
            }
            validate(from, to);
            if(angular.isFunction(handler) || angular.isArray(handler)) {
                handler = {
                    between: handler
                };
            }
            transition = lookup(from);
            if(!(to in transition.targets)) {
                transition.targets[to] = [];
            }
            handler.name = from + &#x27; -&gt; &#x27; + to;
            transition.targets[to].push(handler);
        }
        return this;
    };
    function validate(from, to) {
        var fromValid = validateTarget(from), toValid = validateTarget(to);
        if(fromValid &amp;&amp; toValid) {
            // &amp;&amp; from !== to
            return;
        }
        if(fromValid) {
            throw new Error(&quot;Invalid transition - to: &#x27;&quot; + to + &quot;&#x27;.&quot;);
        }
        if(toValid) {
            throw new Error(&quot;Invalid transition - from: &#x27;&quot; + from + &quot;&#x27;.&quot;);
        }
        //if (from === to &amp;&amp; from.indexOf(&#x27;*&#x27;) === -1)
        //    throw new Error(&quot;Invalid transition - from and to can&#x27;t be the same.&quot;);
        throw new Error(&quot;Invalid transition - from: &#x27;&quot; + from + &quot;&#x27;, to: &#x27;&quot; + to + &quot;&#x27;.&quot;);
    }
    function validateTarget(target) {
        if(target === &#x27;*&#x27; || validation.test(target)) {
            return true;
        }
        return false;
    }
    function lookup(name) {
        var current = root, names = name.split(&#x27;.&#x27;), i = //If name contains root explicitly, skip that one
        names[0] === &#x27;root&#x27; ? 1 : 0;
        for(; i &lt; names.length; i++) {
            if(!(names[i] in current.children)) {
                current.children[names[i]] = {
                    children: {
                    },
                    targets: {
                    }
                };
            }
            current = current.children[names[i]];
        }
        return current;
    }
    /**
    * @ngdoc object
    * @name dotjem.routing.$stateTransition
    *
    * @requires $q
    * @requires $injector
    *
    * @description
    *
    */
    this.$get = [
        &#x27;$q&#x27;, 
        &#x27;$injector&#x27;, 
        function ($q, $injector) {
            /**
            * @ngdoc method
            * @name dotjem.routing.$stateTransition#find
            * @methodOf dotjem.routing.$stateTransition
            *
            * @param {string|State|Array} from The state we are transitioning from.
            * @param {string|State|Array} to The state we are transitioning to.
            *
            * @description
            */
            var $transition = {
                root: root,
                find: find
            };
            return $transition;
            function find(from, to) {
                var transitions = findTransitions(toName(from)), handlers = extractHandlers(transitions, toName(to)), emitters;
                function emit(select, tc) {
                    var handler;
                    forEach(handlers, function (handlerObj) {
                        if(isDefined(handler = select(handlerObj))) {
                            injectFn(handler)($injector, {
                                $to: to,
                                $from: from,
                                $transition: tc
                            });
                        }
                    });
                }
                return {
                    before: function (tc) {
                        emit(function (h) {
                            return h.before;
                        }, tc);
                    },
                    between: function (tc) {
                        emit(function (h) {
                            return h.between;
                        }, tc);
                    },
                    after: function (tc) {
                        emit(function (h) {
                            return h.after;
                        }, tc);
                    }
                };
            }
            function trimRoot(path) {
                if(path[0] === &#x27;root&#x27;) {
                    path.splice(0, 1);
                }
                return path;
            }
            function compare(one, to) {
                var left = trimRoot(one.split(&#x27;.&#x27;)).reverse(), right = trimRoot(to.split(&#x27;.&#x27;)).reverse(), l, r, i = 0;
                while(true) {
                    l = left.pop();
                    r = right.pop();
                    if(r === &#x27;*&#x27; || l === &#x27;*&#x27;) {
                        return true;
                    }
                    if(l !== r) {
                        return false;
                    }
                    if(!isDefined(l) || !isDefined(r)) {
                        return true;
                    }
                }
                return true;
            }
            function extractHandlers(transitions, to) {
                var handlers = [];
                forEach(transitions, function (t) {
                    forEach(t.targets, function (target, targetName) {
                        if(compare(targetName, to)) {
                            forEach(target, function (value) {
                                handlers.push(value);
                            });
                        }
                    });
                });
                return handlers;
            }
            function findTransitions(from) {
                var current = root, names = from.split(&#x27;.&#x27;), transitions = [], index = names[0] === &#x27;root&#x27; ? 1 : 0;
                do {
                    if(&#x27;*&#x27; in current.children) {
                        transitions.push(current.children[&#x27;*&#x27;]);
                    }
                    if(names[index] in current.children) {
                        current = current.children[names[index]];
                        transitions.push(current);
                    } else {
                        break;
                    }
                }while(index++ &lt; names.length);
                return transitions;
            }
        }    ];
}
angular.module(&#x27;dotjem.routing&#x27;).provider(&#x27;$stateTransition&#x27;, $StateTransitionProvider);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
