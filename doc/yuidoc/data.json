{
    "project": {
        "name": "angular-routing",
        "description": "State-based routing and view management for AngularJS",
        "version": "0.1",
        "url": ""
    },
    "files": {
        "build\\src\\route.js": {
            "name": "build\\src\\route.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "build\\angular-routing.js": {
            "name": "build\\angular-routing.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib\\angular\\impl\\angular-bootstrap-prettify.js": {
            "name": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib\\angular\\impl\\angular-bootstrap.js": {
            "name": "lib\\angular\\impl\\angular-bootstrap.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib\\angular\\impl\\angular-mocks.js": {
            "name": "lib\\angular\\impl\\angular-mocks.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib\\angular\\impl\\angular-resource.js": {
            "name": "lib\\angular\\impl\\angular-resource.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib\\angular\\impl\\angular.js": {
            "name": "lib\\angular\\impl\\angular.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        },
        "lib\\jquery\\impl\\jquery-1.9.1.js": {
            "name": "lib\\jquery\\impl\\jquery-1.9.1.js",
            "modules": {},
            "classes": {},
            "fors": {},
            "namespaces": {}
        }
    },
    "modules": {},
    "classes": {},
    "classitems": [
        {
            "file": "build\\src\\route.js",
            "line": 5,
            "ngdoc": "object",
            "name": "",
            "itemtype": "method",
            "description": "Used for configuring routes. See {@link ui.routing.$route $route} for an example.",
            "class": ""
        },
        {
            "file": "build\\src\\route.js",
            "line": 21,
            "ngdoc": "method",
            "name": "ui.routing.$routeProvider#convert",
            "methodof": "ui.routing.$routeProvider",
            "params": [
                {
                    "name": "name",
                    "description": "Cerverter name, used in the path when registering routes through the\n  {@link ui.routing.routeProvider#when when} function.",
                    "type": "String"
                }
            ],
            "return": {
                "description": "self",
                "type": "Object"
            },
            "description": "Adds a new converter or overwrites an existing one.\n\nBy default the folowing converters are precent:\n - `` - default Converter, used on all parameters that doesn't specify a converter.\n   Matches any input.\n\n - `num` - number converter, used to only mach numeric values.\n\n - `regex` - regular expressions converter, used to match a parameter agains a regular\n   expression.",
            "class": ""
        },
        {
            "file": "build\\src\\route.js",
            "line": 50,
            "ngdoc": "method",
            "name": "ui.routing.$routeProvider#when",
            "methodof": "ui.routing.$routeProvider",
            "params": [
                {
                    "name": "path",
                    "description": "Route path (matched against `$location.path`). If `$location.path`\n   contains redundant trailing slash or is missing one, the route will still match.\n\n   `path` can contain named groups starting with a colon (`:name`) or curly brackets (`{name}`).\n   All characters up to the next slash are matched and stored in `$routeParams` under the\n   given `name` when the route matches.\n\n   Further, when using the curly bracket syntax, converters can be used to match only specific\n   values, (`{num:name}`) will only match numerical values and (`{regex(\\d{1,2}[a-z]+):name}`)\n   would only match a parameter starting with one or two digits followed by a number of\n   characters between 'a' and 'z'.\n\n   More converters can be registered using the {@link ui.routing.routeProvider#convert convert}\n   function.",
                    "type": "String"
                },
                {
                    "name": "route",
                    "description": "Mapping information to be assigned to `$route.current` on route\n   match.\n\n   Object properties:\n\n   - `state` � `{string}` � a state that should be activated when the route is matched.\n   - `action` � `{(string|function()=}` � an action that should be performed when the route is matched.\n\n   Legacy support for the following when using the {@link ui.routing.legacy ui.routing.legacy}\n   module.\n\n   - `controller` � `{(string|function()=}` � Controller fn that should be associated with newly\n     created scope or the name of a {@link angular.Module#controller registered controller}\n     if passed as a string.\n   - `template` � `{string=|function()=}` � html template as a string or function that returns\n     an html template as a string which should be used by {@link ng.directive:ngView ngView} or\n     {@link ng.directive:ngInclude ngInclude} directives.\n     This property takes precedence over `templateUrl`.\n\n     If `template` is a function, it will be called with the following parameters:\n\n     - `{Array.<Object>}` - route parameters extracted from the current\n       `$location.path()` by applying the current route\n\n   - `templateUrl` � `{string=|function()=}` � path or function that returns a path to an html\n     template that should be used by {@link ng.directive:ngView ngView}.\n\n     If `templateUrl` is a function, it will be called with the following parameters:\n\n     - `{Array.<Object>}` - route parameters extracted from the current\n       `$location.path()` by applying the current route\n\n   - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n     be injected into the controller. If any of these dependencies are promises, they will be\n     resolved and converted to a value before the controller is instantiated and the\n     `$routeChangeSuccess` event is fired. The map object is:\n\n     - `key` � `{string}`: a name of a dependency to be injected into the controller.\n     - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n       Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}\n       and the return value is treated as the dependency. If the result is a promise, it is resolved\n       before its value is injected into the controller.\n\n   - `redirectTo` � {(string|function())=} � value to update\n     {@link ng.$location $location} path with and trigger route redirection.\n\n     If `redirectTo` is a function, it will be called with the following parameters:\n\n     - `{Object.<string>}` - route parameters extracted from the current\n       `$location.path()` by applying the current route templateUrl.\n     - `{string}` - current `$location.path()`\n     - `{Object}` - current `$location.search()`\n\n     The custom `redirectTo` function is expected to return a string which will be used\n     to update `$location.path()` and `$location.search()`.\n\n   - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()\n   changes.\n\n     If the option is set to `false` and url in the browser changes, then\n     `$routeUpdate` event is broadcasted on the root scope.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "self",
                "type": "Object"
            },
            "description": "Adds a new route definition to the `$route` service.",
            "class": ""
        },
        {
            "file": "build\\src\\route.js",
            "line": 150,
            "ngdoc": "method",
            "name": "ng.$routeProvider#otherwise",
            "methodof": "ng.$routeProvider",
            "description": "Sets route definition that will be used on route change when no other route definition\nis matched.",
            "params": [
                {
                    "name": "params",
                    "description": "Mapping information to be assigned to `$route.current`.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "self",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "build\\src\\route.js",
            "line": 391,
            "ngdoc": "object",
            "name": "current Reference to the current route definition.!~YUIDOC_LINE~!The route definition contains:!~YUIDOC_LINE~!!~YUIDOC_LINE~!  - `controller`: The controller constructor as define in route definition.!~YUIDOC_LINE~!  - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for!~YUIDOC_LINE~!    controller instantiation. The `locals` contain!~YUIDOC_LINE~!    the resolved values of the `resolve` map. Additionally the `locals` also contain:!~YUIDOC_LINE~!!~YUIDOC_LINE~!    - `$scope` - The current route scope.!~YUIDOC_LINE~!    - `$template` - The current route template HTML.",
            "requires": [
                "$location",
                "$routeParams"
            ],
            "itemtype": "property",
            "type": "Object",
            "description": "Is used for deep-linking URLs to controllers and views (HTML partials).\nIt watches `$location.url()` and tries to map the path to an existing route definition.\n\nYou can define routes through {@link ng.$routeProvider $routeProvider}'s API.\n\nThe `$route` service is typically used in conjunction with {@link ng.directive:ngView ngView}\ndirective and the {@link ng.$routeParams $routeParams} service.",
            "example": [
                "\n           This example shows how changing the URL hash causes the `$route` to match a route against the\n           URL, and the `ngView` pulls in the partial.\n           \n           Note that this example is using {@link ng.directive:script inlined templates}\n           to get it working on jsfiddle as well.\n           \n           <example module=\"ngView\">\n           <file name=\"index.html\">\n           <div ng-controller=\"MainCntl\">\n           Choose:\n           <a href=\"Book/Moby\">Moby</a> |\n           <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n           <a href=\"Book/Gatsby\">Gatsby</a> |\n           <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n           <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n           \n           <div ng-view></div>\n           <hr />\n           \n           <pre>$location.path() = {{$location.path()}}</pre>\n           <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n           <pre>$route.current.params = {{$route.current.params}}</pre>\n           <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n           <pre>$routeParams = {{$routeParams}}</pre>\n           </div>\n           </file>\n           \n           <file name=\"book.html\">\n           controller: {{name}}<br />\n           Book Id: {{params.bookId}}<br />\n           </file>\n           \n           <file name=\"chapter.html\">\n           controller: {{name}}<br />\n           Book Id: {{params.bookId}}<br />\n           Chapter Id: {{params.chapterId}}\n           </file>\n           \n           <file name=\"script.js\">\n           angular.module('ngView', [], function($routeProvider, $locationProvider) {\n           $routeProvider.when('/Book/:bookId', {\n           templateUrl: 'book.html',\n           controller: BookCntl,\n           resolve: {\n           // I will cause a 1 second delay\n           delay: function($q, $timeout) {\n           var delay = $q.defer();\n           $timeout(delay.resolve, 1000);\n           return delay.promise;\n           }\n           }\n           });\n           $routeProvider.when('/Book/:bookId/ch/:chapterId', {\n           templateUrl: 'chapter.html',\n           controller: ChapterCntl\n           });\n           \n           // configure html5 to get links working on jsfiddle\n           $locationProvider.html5Mode(true);\n           });\n           \n           function MainCntl($scope, $route, $routeParams, $location) {\n           $scope.$route = $route;\n           $scope.$location = $location;\n           $scope.$routeParams = $routeParams;\n           }\n           \n           function BookCntl($scope, $routeParams) {\n           $scope.name = \"BookCntl\";\n           $scope.params = $routeParams;\n           }\n           \n           function ChapterCntl($scope, $routeParams) {\n           $scope.name = \"ChapterCntl\";\n           $scope.params = $routeParams;\n           }\n           </file>\n           \n           <file name=\"scenario.js\">\n           it('should load and compile correct template', function() {\n           element('a:contains(\"Moby: Ch1\")').click();\n           var content = element('.doc-example-live [ng-view]').text();\n           expect(content).toMatch(/controller\\: ChapterCntl/);\n           expect(content).toMatch(/Book Id\\: Moby/);\n           expect(content).toMatch(/Chapter Id\\: 1/);\n           \n           element('a:contains(\"Scarlet\")').click();\n           sleep(2); // promises are not part of scenario waiting\n           content = element('.doc-example-live [ng-view]').text();\n           expect(content).toMatch(/controller\\: BookCntl/);\n           expect(content).toMatch(/Book Id\\: Scarlet/);\n           });\n           </file>\n           </example>"
            ],
            "class": "",
            "subprops": [
                {
                    "name": "routes",
                    "description": "Array of all configured routes.",
                    "type": "Array.<Object>"
                }
            ]
        },
        {
            "file": "build\\src\\route.js",
            "line": 515,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeStart",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted before a route change. At this  point the route services starts\nresolving all of the dependencies needed for the route change to occurs.\nTypically this involves fetching the view template as well as any dependencies\ndefined in `resolve` route property. Once  all of the dependencies are resolved\n`$routeChangeSuccess` is fired.",
            "params": [
                {
                    "name": "next",
                    "description": "Future route information.",
                    "type": "Route"
                },
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "build\\src\\route.js",
            "line": 530,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeSuccess",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted after a route dependencies are resolved.\n{@link ng.directive:ngView ngView} listens for the directive\nto instantiate the controller and render the view.",
            "params": [
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                },
                {
                    "name": "previous",
                    "description": "Previous route information.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "build\\src\\route.js",
            "line": 543,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeError",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted if any of the resolve promises are rejected.",
            "params": [
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                },
                {
                    "name": "previous",
                    "description": "Previous route information.",
                    "type": "Route"
                },
                {
                    "name": "rejection",
                    "description": "Rejection of the promise. Usually the error of the failed promise.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "build\\src\\route.js",
            "line": 555,
            "ngdoc": "event",
            "name": "ng.$route#$routeUpdate",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "The `reloadOnSearch` property has been set to false, and we are reusing the same\ninstance of the Controller.",
            "class": ""
        },
        {
            "file": "build\\angular-routing.js",
            "line": 23,
            "ngdoc": "object",
            "name": "",
            "itemtype": "method",
            "description": "Used for configuring routes. See {@link ui.routing.$route $route} for an example.",
            "class": ""
        },
        {
            "file": "build\\angular-routing.js",
            "line": 39,
            "ngdoc": "method",
            "name": "ui.routing.$routeProvider#convert",
            "methodof": "ui.routing.$routeProvider",
            "params": [
                {
                    "name": "name",
                    "description": "Cerverter name, used in the path when registering routes through the\n  {@link ui.routing.routeProvider#when when} function.",
                    "type": "String"
                }
            ],
            "return": {
                "description": "self",
                "type": "Object"
            },
            "description": "Adds a new converter or overwrites an existing one.\n\nBy default the folowing converters are precent:\n - `` - default Converter, used on all parameters that doesn't specify a converter.\n   Matches any input.\n\n - `num` - number converter, used to only mach numeric values.\n\n - `regex` - regular expressions converter, used to match a parameter agains a regular\n   expression.",
            "class": ""
        },
        {
            "file": "build\\angular-routing.js",
            "line": 68,
            "ngdoc": "method",
            "name": "ui.routing.$routeProvider#when",
            "methodof": "ui.routing.$routeProvider",
            "params": [
                {
                    "name": "path",
                    "description": "Route path (matched against `$location.path`). If `$location.path`\n   contains redundant trailing slash or is missing one, the route will still match.\n\n   `path` can contain named groups starting with a colon (`:name`) or curly brackets (`{name}`).\n   All characters up to the next slash are matched and stored in `$routeParams` under the\n   given `name` when the route matches.\n\n   Further, when using the curly bracket syntax, converters can be used to match only specific\n   values, (`{num:name}`) will only match numerical values and (`{regex(\\d{1,2}[a-z]+):name}`)\n   would only match a parameter starting with one or two digits followed by a number of\n   characters between 'a' and 'z'.\n\n   More converters can be registered using the {@link ui.routing.routeProvider#convert convert}\n   function.",
                    "type": "String"
                },
                {
                    "name": "route",
                    "description": "Mapping information to be assigned to `$route.current` on route\n   match.\n\n   Object properties:\n\n   - `state` � `{string}` � a state that should be activated when the route is matched.\n   - `action` � `{(string|function()=}` � an action that should be performed when the route is matched.\n\n   Legacy support for the following when using the {@link ui.routing.legacy ui.routing.legacy}\n   module.\n\n   - `controller` � `{(string|function()=}` � Controller fn that should be associated with newly\n     created scope or the name of a {@link angular.Module#controller registered controller}\n     if passed as a string.\n   - `template` � `{string=|function()=}` � html template as a string or function that returns\n     an html template as a string which should be used by {@link ng.directive:ngView ngView} or\n     {@link ng.directive:ngInclude ngInclude} directives.\n     This property takes precedence over `templateUrl`.\n\n     If `template` is a function, it will be called with the following parameters:\n\n     - `{Array.<Object>}` - route parameters extracted from the current\n       `$location.path()` by applying the current route\n\n   - `templateUrl` � `{string=|function()=}` � path or function that returns a path to an html\n     template that should be used by {@link ng.directive:ngView ngView}.\n\n     If `templateUrl` is a function, it will be called with the following parameters:\n\n     - `{Array.<Object>}` - route parameters extracted from the current\n       `$location.path()` by applying the current route\n\n   - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n     be injected into the controller. If any of these dependencies are promises, they will be\n     resolved and converted to a value before the controller is instantiated and the\n     `$routeChangeSuccess` event is fired. The map object is:\n\n     - `key` � `{string}`: a name of a dependency to be injected into the controller.\n     - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n       Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}\n       and the return value is treated as the dependency. If the result is a promise, it is resolved\n       before its value is injected into the controller.\n\n   - `redirectTo` � {(string|function())=} � value to update\n     {@link ng.$location $location} path with and trigger route redirection.\n\n     If `redirectTo` is a function, it will be called with the following parameters:\n\n     - `{Object.<string>}` - route parameters extracted from the current\n       `$location.path()` by applying the current route templateUrl.\n     - `{string}` - current `$location.path()`\n     - `{Object}` - current `$location.search()`\n\n     The custom `redirectTo` function is expected to return a string which will be used\n     to update `$location.path()` and `$location.search()`.\n\n   - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()\n   changes.\n\n     If the option is set to `false` and url in the browser changes, then\n     `$routeUpdate` event is broadcasted on the root scope.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "self",
                "type": "Object"
            },
            "description": "Adds a new route definition to the `$route` service.",
            "class": ""
        },
        {
            "file": "build\\angular-routing.js",
            "line": 168,
            "ngdoc": "method",
            "name": "ng.$routeProvider#otherwise",
            "methodof": "ng.$routeProvider",
            "description": "Sets route definition that will be used on route change when no other route definition\nis matched.",
            "params": [
                {
                    "name": "params",
                    "description": "Mapping information to be assigned to `$route.current`.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "self",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "build\\angular-routing.js",
            "line": 409,
            "ngdoc": "object",
            "name": "current Reference to the current route definition.!~YUIDOC_LINE~!The route definition contains:!~YUIDOC_LINE~!!~YUIDOC_LINE~!  - `controller`: The controller constructor as define in route definition.!~YUIDOC_LINE~!  - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for!~YUIDOC_LINE~!    controller instantiation. The `locals` contain!~YUIDOC_LINE~!    the resolved values of the `resolve` map. Additionally the `locals` also contain:!~YUIDOC_LINE~!!~YUIDOC_LINE~!    - `$scope` - The current route scope.!~YUIDOC_LINE~!    - `$template` - The current route template HTML.",
            "requires": [
                "$location",
                "$routeParams"
            ],
            "itemtype": "property",
            "type": "Object",
            "description": "Is used for deep-linking URLs to controllers and views (HTML partials).\nIt watches `$location.url()` and tries to map the path to an existing route definition.\n\nYou can define routes through {@link ng.$routeProvider $routeProvider}'s API.\n\nThe `$route` service is typically used in conjunction with {@link ng.directive:ngView ngView}\ndirective and the {@link ng.$routeParams $routeParams} service.",
            "example": [
                "\n           This example shows how changing the URL hash causes the `$route` to match a route against the\n           URL, and the `ngView` pulls in the partial.\n           \n           Note that this example is using {@link ng.directive:script inlined templates}\n           to get it working on jsfiddle as well.\n           \n           <example module=\"ngView\">\n           <file name=\"index.html\">\n           <div ng-controller=\"MainCntl\">\n           Choose:\n           <a href=\"Book/Moby\">Moby</a> |\n           <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n           <a href=\"Book/Gatsby\">Gatsby</a> |\n           <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n           <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n           \n           <div ng-view></div>\n           <hr />\n           \n           <pre>$location.path() = {{$location.path()}}</pre>\n           <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n           <pre>$route.current.params = {{$route.current.params}}</pre>\n           <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n           <pre>$routeParams = {{$routeParams}}</pre>\n           </div>\n           </file>\n           \n           <file name=\"book.html\">\n           controller: {{name}}<br />\n           Book Id: {{params.bookId}}<br />\n           </file>\n           \n           <file name=\"chapter.html\">\n           controller: {{name}}<br />\n           Book Id: {{params.bookId}}<br />\n           Chapter Id: {{params.chapterId}}\n           </file>\n           \n           <file name=\"script.js\">\n           angular.module('ngView', [], function($routeProvider, $locationProvider) {\n           $routeProvider.when('/Book/:bookId', {\n           templateUrl: 'book.html',\n           controller: BookCntl,\n           resolve: {\n           // I will cause a 1 second delay\n           delay: function($q, $timeout) {\n           var delay = $q.defer();\n           $timeout(delay.resolve, 1000);\n           return delay.promise;\n           }\n           }\n           });\n           $routeProvider.when('/Book/:bookId/ch/:chapterId', {\n           templateUrl: 'chapter.html',\n           controller: ChapterCntl\n           });\n           \n           // configure html5 to get links working on jsfiddle\n           $locationProvider.html5Mode(true);\n           });\n           \n           function MainCntl($scope, $route, $routeParams, $location) {\n           $scope.$route = $route;\n           $scope.$location = $location;\n           $scope.$routeParams = $routeParams;\n           }\n           \n           function BookCntl($scope, $routeParams) {\n           $scope.name = \"BookCntl\";\n           $scope.params = $routeParams;\n           }\n           \n           function ChapterCntl($scope, $routeParams) {\n           $scope.name = \"ChapterCntl\";\n           $scope.params = $routeParams;\n           }\n           </file>\n           \n           <file name=\"scenario.js\">\n           it('should load and compile correct template', function() {\n           element('a:contains(\"Moby: Ch1\")').click();\n           var content = element('.doc-example-live [ng-view]').text();\n           expect(content).toMatch(/controller\\: ChapterCntl/);\n           expect(content).toMatch(/Book Id\\: Moby/);\n           expect(content).toMatch(/Chapter Id\\: 1/);\n           \n           element('a:contains(\"Scarlet\")').click();\n           sleep(2); // promises are not part of scenario waiting\n           content = element('.doc-example-live [ng-view]').text();\n           expect(content).toMatch(/controller\\: BookCntl/);\n           expect(content).toMatch(/Book Id\\: Scarlet/);\n           });\n           </file>\n           </example>"
            ],
            "class": "",
            "subprops": [
                {
                    "name": "routes",
                    "description": "Array of all configured routes.",
                    "type": "Array.<Object>"
                }
            ]
        },
        {
            "file": "build\\angular-routing.js",
            "line": 533,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeStart",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted before a route change. At this  point the route services starts\nresolving all of the dependencies needed for the route change to occurs.\nTypically this involves fetching the view template as well as any dependencies\ndefined in `resolve` route property. Once  all of the dependencies are resolved\n`$routeChangeSuccess` is fired.",
            "params": [
                {
                    "name": "next",
                    "description": "Future route information.",
                    "type": "Route"
                },
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "build\\angular-routing.js",
            "line": 548,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeSuccess",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted after a route dependencies are resolved.\n{@link ng.directive:ngView ngView} listens for the directive\nto instantiate the controller and render the view.",
            "params": [
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                },
                {
                    "name": "previous",
                    "description": "Previous route information.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "build\\angular-routing.js",
            "line": 561,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeError",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted if any of the resolve promises are rejected.",
            "params": [
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                },
                {
                    "name": "previous",
                    "description": "Previous route information.",
                    "type": "Route"
                },
                {
                    "name": "rejection",
                    "description": "Rejection of the promise. Usually the error of the failed promise.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "build\\angular-routing.js",
            "line": 573,
            "ngdoc": "event",
            "name": "ng.$route#$routeUpdate",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "The `reloadOnSearch` property has been set to false, and we are reusing the same\ninstance of the Controller.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1,
            "license": "AngularJS v1.0.5\n(c) 2010-2012 Google, Inc. http://angularjs.org\nLicense: MIT",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 28,
            "description": "http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\nhttp://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 308,
            "fileoverview": "some functions for browser-side pretty printing of code contained in html.\n\n<p>\nFor a fairly comprehensive set of languages see the\n<a href=\"http://google-code-prettify.googlecode.com/svn/trunk/README.html#langs\">README</a>\nfile that came with this source.  At a minimum, the lexer should work on a\nnumber of languages including C and friends, Java, Python, Bash, SQL, HTML,\nXML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\nand a subset of Perl, but, because of commenting conventions, doesn't work on\nSmalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n<p>\nUsage: <ol>\n<li> include this source file in an html page via\n  {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n<li> define style rules.  See the example page for examples.\n<li> mark the {@code <pre>} and {@code <code>} tags in your source with\n   {@code class=prettyprint.}\n   You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n   printer needs to do more substantial DOM manipulations to support that, so\n   some css styles may not be preserved.\n</ol>\nThat's it.  I wanted to keep the API as simple as possible, so there's no\nneed to specify which language the code is in, but if you wish, you can add\nanother class to the {@code <pre>} or {@code <code>} element to specify the\nlanguage, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\nstarts with \"lang-\" followed by a file extension, specifies the file type.\nSee the \"lang-*.js\" files in this directory for code that implements\nper-language file handlers.\n<p>\nChange log:<br>\ncbeust, 2006/08/22\n<blockquote>\n  Java annotations (start with \"@\") are now captured as literals (\"lit\")\n</blockquote>",
            "requires": [
                "console"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 350,
            "description": "Split {@code prettyPrint} into multiple timeouts so as not to interfere with\nUI events.\nIf set to {@code false}, {@code prettyPrint()} is synchronous.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 357,
            "description": "Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n{@code class=prettyprint} and prettify them.",
            "params": [
                {
                    "name": "opt_whenDone",
                    "description": "if specified, called when the last entry\n    has been finished.",
                    "type": "Function?"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 365,
            "description": "Pretty print a chunk of code.",
            "params": [
                {
                    "name": "sourceCodeHtml",
                    "description": "code as html",
                    "type": "String"
                }
            ],
            "return": {
                "description": "code as html, but prettier",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 425,
            "description": "token style for a string literal",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 430,
            "description": "token style for a keyword",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 435,
            "description": "token style for a comment",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 440,
            "description": "token style for a type",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 445,
            "description": "token style for a literal value.  e.g. 1, null, true.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 450,
            "description": "token style for a punctuation string.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 455,
            "description": "token style for plain text.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 461,
            "description": "token style for an sgml tag.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 466,
            "description": "token style for a markup declaration such as a DOCTYPE.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 471,
            "description": "token style for embedded source.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 476,
            "description": "token style for an sgml attribute name.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 481,
            "description": "token style for an sgml attribute value.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 487,
            "description": "A class that indicates a section of markup that is not code, e.g. to allow\nembedding of line numbers within code listings.",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 496,
            "description": "A set of tokens that can precede a regular expression literal in\njavascript\nhttp://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\nhas the full list, but I've removed ones that might be problematic when\nseen in languages that don't support regular expression literals.\n\n<p>Specifically, I've removed any keywords that can't precede a regexp\nliteral in a syntactically legal javascript program, and I've removed the\n\"in\" keyword since it's not a keyword in many languages, and might be used\nas a count of inches.\n\n<p>The link above does not accurately describe EcmaScript rules since\nit fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\nvery well in practice.",
            "access": "private",
            "tagname": "",
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 524,
            "description": "Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\nmatches the union of the sets of strings matched by the input RegExp.\nSince it matches globally, if the input strings have a start-of-input\nanchor (/^.../), it is ignored for the purposes of unioning.",
            "params": [
                {
                    "name": "regexs",
                    "description": "non multiline, non-global regexs.",
                    "type": "Array.<RegExp>"
                }
            ],
            "return": {
                "description": "a global regex.",
                "type": "RegExp"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 766,
            "description": "Split markup into a string of source code and an array mapping ranges in\nthat string to the text nodes in which they appear.\n\n<p>\nThe HTML DOM structure:</p>\n<pre>\n(Element   \"p\"\n  (Element \"b\"\n    (Text  \"print \"))       ; #1\n  (Text    \"'Hello '\")      ; #2\n  (Element \"br\")            ; #3\n  (Text    \"  + 'World';\")) ; #4\n</pre>\n<p>\ncorresponds to the HTML\n{@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n\n<p>\nIt will produce the output:</p>\n<pre>\n{\n  sourceCode: \"print 'Hello '\\n  + 'World';\",\n  //                     1          2\n  //           012345678901234 5678901234567\n  spans: [0, #1, 6, #2, 14, #3, 15, #4]\n}\n</pre>\n<p>\nwhere #1 is a reference to the {@code \"print \"} text node above, and so\non for the other text nodes.\n</p>\n\n<p>\nThe {@code} spans array is an array of pairs.  Even elements are the start\nindices of substrings, and odd elements are the text nodes (or BR elements)\nthat contain the text for those substrings.\nSubstrings continue until the next index or the end of the source.\n</p>",
            "params": [
                {
                    "name": "node",
                    "description": "an HTML DOM subtree containing source-code.",
                    "type": "Node"
                },
                {
                    "name": "isPreformatted",
                    "description": "true if white-space in text nodes should\n   be considered significant.",
                    "type": "Boolean"
                }
            ],
            "return": {
                "description": "source code and the text nodes in which they occur.",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 860,
            "description": "Apply the given language handler to sourceCode and add the resulting\ndecorations to out.",
            "params": [
                {
                    "name": "basePos",
                    "description": "the index of sourceCode within the chunk of source\n   whose decorations are already present on out.",
                    "type": "Number"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 878,
            "description": "Given an element, if it contains only one child element and any text nodes\nit contains contain only space characters, return the sole child element.\nOtherwise returns undefined.\n<p>\nThis is meant to return the CODE element in {@code <pre><code ...>} when\nthere is a single child element that contains all the non-space textual\ncontent, but not to return anything where there are multiple child elements\nas in {@code <pre><code>...</code><code>...</code></pre>} or when there\nis textual content.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 902,
            "description": "The lexing function interprets the patterns to find token boundaries and\nreturns a decoration list of the form\n[index_0, style_0, index_1, style_1, ..., index_n, style_n]\nwhere index_n is an index into the sourceCode, and style_n is a style\nconstant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\nall characters in sourceCode[index_n-1:index_n].\n\nThe stylePatterns is a list whose elements have the form\n[style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n\nStyle is a style constant like PR_PLAIN, or can be a string of the\nform 'lang-FOO', where FOO is a language extension describing the\nlanguage of the portion of the token in $1 after pattern executes.\nE.g., if style is 'lang-lisp', and group 1 contains the text\n'(hello (world))', then that portion of the token will be passed to the\nregistered lisp handler for formatting.\nThe text before and after group 1 will be restyled using this decorator\nso decorators should take care that this doesn't result in infinite\nrecursion.  For example, the HTML lexer rule for SCRIPT elements looks\nsomething like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n'<script>foo()<\\/script>', which would cause the current decorator to\nbe called with '<script>' which would not match the same rule since\ngroup 1 must not be empty, so it would be instead styled as PR_TAG by\nthe generic tag rule.  The handler registered for the 'js' extension would\nthen be called with 'foo()', and finally, the current decorator would\nbe called with '<\\/script>' which would not match the original rule and\nso the generic tag rule would identify it as a tag.\n\nPattern must only match prefixes, and if it matches a prefix, then that\nmatch is considered a token with the same style.\n\nContext is applied to the last non-whitespace, non-comment token\nrecognized.\n\nShortcut is an optional string of characters, any of which, if the first\ncharacter, gurantee that this pattern and only this pattern matches.",
            "params": [
                {
                    "name": "shortcutStylePatterns",
                    "description": "patterns that always start with\n  a known character.  Must have a shortcut string.",
                    "type": "Array"
                },
                {
                    "name": "fallthroughStylePatterns",
                    "description": "patterns that will be tried in\n  order if the shortcut ones fail.  May have shortcuts.",
                    "type": "Array"
                }
            ],
            "return": {
                "description": "a\n  function that takes source code and returns a list of decorations.",
                "type": "Function (Object)"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 976,
            "description": "Lexes job.sourceCode and produces an output array job.decorations of\nstyle classes preceded by the position at which they start in\njob.sourceCode in order.",
            "params": [
                {
                    "name": "job",
                    "description": "an object like <pre>{\n   sourceCode: {string} sourceText plain text,\n   basePos: {int} position of job.sourceCode in the larger chunk of\n       sourceCode.\n}</pre>",
                    "type": "Object"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 989,
            "description": "are style markers (e.g., PR_COMMENT) that run from that position until\nthe end.",
            "type": "{Array.<number|string>}",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1076,
            "description": "This code treats \", ', and ` as string delimiters, and \\ as a string\n escape.  It does not recognize perl's qq() style strings.\n It has no special handling for double delimiter escapes as in basic, or\n the tripled delimiters used in python, but should work on those regardless\n although in those cases a single string literal may be broken up into\n multiple adjacent string literals.\nIt recognizes C, C++, and shell style comments.",
            "params": [
                {
                    "name": "options",
                    "description": "a set of optional parameters.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "a function that examines the source code\n     in the input job and builds the decoration list.",
                "type": "Function (Object)"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1142,
            "itemtype": "property",
            "name": "",
            "final": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1211,
            "description": "Given a DOM subtree, wraps it in a list, and puts each line into its own\nlist item.",
            "params": [
                {
                    "name": "node",
                    "description": "modified in place.  Its content is pulled into an\n    HTMLOListElement, and each line is moved into a separate list item.\n    This requires cloning elements, so the input might not have unique\n    IDs after numbering.",
                    "type": "Node"
                },
                {
                    "name": "isPreformatted",
                    "description": "true iff white-space in text nodes should\n    be treated as significant.",
                    "type": "Boolean"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1350,
            "description": "Breaks {@code job.sourceCode} around style boundaries in\n{@code job.decorations} and modifies {@code job.sourceNode} in place.",
            "params": [
                {
                    "name": "job",
                    "description": "like <pre>{\n   sourceCode: {string} source as plain text,\n   spans: {Array.<number|Node>} alternating span start indices into source\n      and the text node or element (e.g. {@code <BR>}) corresponding to that\n      span.\n   decorations: {Array.<number|string} an array of style classes preceded\n      by the position at which they start in job.sourceCode in order\n}</pre>",
                    "type": "Object"
                }
            ],
            "access": "private",
            "tagname": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1474,
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1476,
            "params": [
                {
                    "name": "handler",
                    "description": "a function from source code to a list\n     of decorations.  Takes a single argument job which describes the\n     state of the computation.   The single parameter has the form\n     {@code {\n       sourceCode: {string} as plain text.\n       decorations: {Array.<number|string>} an array of style classes\n                    preceded by the position at which they start in\n                    job.sourceCode in order.\n                    The language handler should assigned this field.\n       basePos: {int} the position of source in the larger source chunk.\n                All positions in the output decorations array are relative\n                to the larger source chunk.\n     } }",
                    "type": "Function (Object)"
                },
                {
                    "name": "fileExtensions",
                    "description": "",
                    "type": "Array.<string>"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1618,
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1637,
            "params": [
                {
                    "name": "sourceCodeHtml",
                    "description": "The HTML to pretty print.",
                    "type": "String"
                },
                {
                    "name": "opt_langExtension",
                    "description": "The language name to use.\n    Typically, a filename extension like 'cpp' or 'java'.",
                    "type": "String"
                },
                {
                    "name": "opt_numberLines",
                    "description": "True to number lines,\n    or the 1-indexed number of the first line in sourceCodeHtml.",
                    "type": "Number|boolean"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap-prettify.js",
            "line": 1788,
            "description": "Contains functions for creating and registering new language handlers.",
            "type": "{Object}",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-bootstrap.js",
            "line": 1,
            "license": "AngularJS v1.0.5\n(c) 2010-2012 Google, Inc. http://angularjs.org\nLicense: MIT",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1,
            "license": "AngularJS v1.0.5\n(c) 2010-2012 Google, Inc. http://angularjs.org\nLicense: MIT\n\nTODO(vojta): wrap whole file into closure during build",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 9,
            "ngdoc": "overview",
            "name": "angular.mock",
            "description": "Namespace from 'angular-mocks.js' which contains testing related code.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 18,
            "description": "This service is a mock implementation of {@link ng.$browser}. It provides fake\nimplementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,\ncookies, etc...\n\nThe api of this service is the same as that of the real {@link ng.$browser $browser}, except\nthat there are several helper methods available which can be used in tests.",
            "name": "ngMock.$browser",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 97,
            "name": "ngMock.$browser#defer.flush",
            "methodof": "ngMock.$browser",
            "description": "Flushes all pending requests and executes the defer callbacks.",
            "params": [
                {
                    "name": "number",
                    "description": "of milliseconds to flush. See {@link #defer.now}",
                    "type": "Number="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 121,
            "name": "ngMock.$browser#defer.now",
            "propertyof": "ngMock.$browser",
            "description": "Current milliseconds mock time.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 136,
            "name": "ngMock.$browser#poll",
            "methodof": "ngMock.$browser",
            "description": "run all fns in pollFns",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 188,
            "ngdoc": "object",
            "name": "ngMock.$exceptionHandlerProvider",
            "description": "Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors passed\ninto the `$exceptionHandler`.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 197,
            "ngdoc": "object",
            "name": "ngMock.$exceptionHandler",
            "description": "Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed\ninto it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration\ninformation.\n\n\n<pre>\n  describe('$exceptionHandlerProvider', function() {\n\n    it('should capture log messages and exceptions', function() {\n\n      module(function($exceptionHandlerProvider) {\n        $exceptionHandlerProvider.mode('log');\n      });\n\n      inject(function($log, $exceptionHandler, $timeout) {\n        $timeout(function() { $log.log(1); });\n        $timeout(function() { $log.log(2); throw 'banana peel'; });\n        $timeout(function() { $log.log(3); });\n        expect($exceptionHandler.errors).toEqual([]);\n        expect($log.assertEmpty());\n        $timeout.flush();\n        expect($exceptionHandler.errors).toEqual(['banana peel']);\n        expect($log.log.logs).toEqual([[1], [2], [3]]);\n      });\n    });\n  });\n</pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 234,
            "ngdoc": "method",
            "name": "ngMock.$exceptionHandlerProvider#mode",
            "methodof": "ngMock.$exceptionHandlerProvider",
            "description": "Sets the logging mode.",
            "params": [
                {
                    "name": "mode",
                    "description": "Mode of operation, defaults to `rethrow`.\n\n  - `rethrow`: If any errors are are passed into the handler in tests, it typically\n               means that there is a bug in the application or test, so this mock will\n               make these tests fail.\n  - `log`: Sometimes it is desirable to test that an error is throw, for this case the `log` mode stores an\n           array of errors in `$exceptionHandler.errors`, to allow later assertion of them.\n           See {@link ngMock.$log#assertEmpty assertEmpty()} and\n            {@link ngMock.$log#reset reset()}",
                    "type": "String"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 285,
            "ngdoc": "service",
            "name": "ngMock.$log",
            "description": "Mock implementation of {@link ng.$log} that gathers all logged messages in arrays\n(one array per logging level). These arrays are exposed as `logs` property of each of the\nlevel-specific log function, e.g. for level `error` the array is exposed as `$log.error.logs`.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 310,
            "ngdoc": "method",
            "name": "ngMock.$log#reset",
            "methodof": "ngMock.$log",
            "description": "Reset all of the logging arrays to empty.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 319,
            "ngdoc": "property",
            "name": "ngMock.$log#log.logs",
            "propertyof": "ngMock.$log",
            "description": "Array of logged messages.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 328,
            "ngdoc": "property",
            "name": "ngMock.$log#warn.logs",
            "propertyof": "ngMock.$log",
            "description": "Array of logged messages.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 337,
            "ngdoc": "property",
            "name": "ngMock.$log#info.logs",
            "propertyof": "ngMock.$log",
            "description": "Array of logged messages.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 346,
            "ngdoc": "property",
            "name": "ngMock.$log#error.logs",
            "propertyof": "ngMock.$log",
            "description": "Array of logged messages.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 357,
            "ngdoc": "method",
            "name": "ngMock.$log#assertEmpty",
            "methodof": "ngMock.$log",
            "description": "Assert that the all of the logging methods have no logged messages. If messages present, an exception is thrown.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 426,
            "ngdoc": "object",
            "name": "angular.mock.TzDate",
            "description": "*NOTE*: this is not an injectable instance, just a globally available mock class of `Date`.\n\nMock of the Date type which has its timezone specified via constroctor arg.\n\nThe main purpose is to create Date-like instances with timezone fixed to the specified timezone\noffset, so that we can test code that depends on local timezone settings without dependency on\nthe time zone settings of the machine where the code is running.",
            "params": [
                {
                    "name": "offset",
                    "description": "Offset of the *desired* timezone in hours (fractions will be honored)",
                    "type": "Number"
                },
                {
                    "name": "timestamp",
                    "description": "Timestamp representing the desired time in *UTC*",
                    "type": "(number|string)"
                }
            ],
            "example": [
                "\n!!!! WARNING !!!!!\nThis is not a complete Date object so only methods that were implemented can be called safely.\nTo make matters worse, TzDate instances inherit stuff from Date via a prototype.\n\nWe do our best to intercept calls to \"unimplemented\" methods, but since the list of methods is\nincomplete we might be missing some non-standard methods. This can result in errors like:\n\"Date.prototype.foo called on incompatible Object\".\n\n<pre>\nvar newYearInBratislava = new TzDate(-1, '2009-12-31T23:00:00Z');\nnewYearInBratislava.getTimezoneOffset() => -60;\nnewYearInBratislava.getFullYear() => 2010;\nnewYearInBratislava.getMonth() => 0;\nnewYearInBratislava.getDate() => 1;\nnewYearInBratislava.getHours() => 0;\nnewYearInBratislava.getMinutes() => 0;\n</pre>\n"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 586,
            "ngdoc": "function",
            "name": "angular.mock.dump",
            "description": "*NOTE*: this is not an injectable instance, just a globally available function.\n\nMethod for serializing common angular objects (scope, elements, etc..) into strings, useful for debugging.\n\nThis method is also available on window, where it can be used to display objects on debug console.",
            "params": [
                {
                    "name": "object",
                    "description": "- any object to turn into string.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "a serialized string of the argument",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 652,
            "ngdoc": "object",
            "name": "ngMock.$httpBackend",
            "description": "Fake HTTP backend implementation suitable for unit testing application that use the\n{@link ng.$http $http service}.\n\n*Note*: For fake http backend implementation suitable for end-to-end testing or backend-less\ndevelopment please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.\n\nDuring unit testing, we want our unit tests to run quickly and have no external dependencies so\nwe don’t want to send {@link https://developer.mozilla.org/en/xmlhttprequest XHR} or\n{@link http://en.wikipedia.org/wiki/JSONP JSONP} requests to a real server. All we really need is\nto verify whether a certain request has been sent or not, or alternatively just let the\napplication make requests, respond with pre-trained responses and assert that the end result is\nwhat we expect it to be.\n\nThis mock implementation can be used to respond with static or dynamic responses via the\n`expect` and `when` apis and their shortcuts (`expectGET`, `whenPOST`, etc).\n\nWhen an Angular application needs some data from a server, it calls the $http service, which\nsends the request to a real server using $httpBackend service. With dependency injection, it is\neasy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify\nthe requests and respond with some testing data without sending a request to real server.\n\nThere are two ways to specify what test data should be returned as http responses by the mock\nbackend when the code under test makes http requests:\n\n- `$httpBackend.expect` - specifies a request expectation\n- `$httpBackend.when` - specifies a backend definition\n\n\n# Request Expectations vs Backend Definitions\n\nRequest expectations provide a way to make assertions about requests made by the application and\nto define responses for those requests. The test will fail if the expected requests are not made\nor they are made in the wrong order.\n\nBackend definitions allow you to define a fake backend for your application which doesn't assert\nif a particular request was made or not, it just returns a trained response if a request is made.\nThe test will pass whether or not the request gets made during testing.\n\n\n<table class=\"table\">\n  <tr><th width=\"220px\"></th><th>Request expectations</th><th>Backend definitions</th></tr>\n  <tr>\n    <th>Syntax</th>\n    <td>.expect(...).respond(...)</td>\n    <td>.when(...).respond(...)</td>\n  </tr>\n  <tr>\n    <th>Typical usage</th>\n    <td>strict unit tests</td>\n    <td>loose (black-box) unit testing</td>\n  </tr>\n  <tr>\n    <th>Fulfills multiple requests</th>\n    <td>NO</td>\n    <td>YES</td>\n  </tr>\n  <tr>\n    <th>Order of requests matters</th>\n    <td>YES</td>\n    <td>NO</td>\n  </tr>\n  <tr>\n    <th>Request required</th>\n    <td>YES</td>\n    <td>NO</td>\n  </tr>\n  <tr>\n    <th>Response required</th>\n    <td>optional (see below)</td>\n    <td>YES</td>\n  </tr>\n</table>\n\nIn cases where both backend definitions and request expectations are specified during unit\ntesting, the request expectations are evaluated first.\n\nIf a request expectation has no response specified, the algorithm will search your backend\ndefinitions for an appropriate response.\n\nIf a request didn't match any expectation or if the expectation doesn't have the response\ndefined, the backend definitions are evaluated in sequential order to see if any of them match\nthe request. The response from the first matched definition is returned.\n\n\n# Flushing HTTP requests\n\nThe $httpBackend used in production, always responds to requests with responses asynchronously.\nIf we preserved this behavior in unit testing, we'd have to create async unit tests, which are\nhard to write, follow and maintain. At the same time the testing mock, can't respond\nsynchronously because that would change the execution of the code under test. For this reason the\nmock $httpBackend has a `flush()` method, which allows the test to explicitly flush pending\nrequests and thus preserving the async api of the backend, while allowing the test to execute\nsynchronously.\n\n\n# Unit testing with mock $httpBackend\n\n<pre>\n  // controller\n  function MyController($scope, $http) {\n    $http.get('/auth.py').success(function(data) {\n      $scope.user = data;\n    });\n\n    this.saveMessage = function(message) {\n      $scope.status = 'Saving...';\n      $http.post('/add-msg.py', message).success(function(response) {\n        $scope.status = '';\n      }).error(function() {\n        $scope.status = 'ERROR!';\n      });\n    };\n  }\n\n  // testing controller\n  var $httpBackend;\n\n  beforeEach(inject(function($injector) {\n    $httpBackend = $injector.get('$httpBackend');\n\n    // backend definition common for all tests\n    $httpBackend.when('GET', '/auth.py').respond({userId: 'userX'}, {'A-Token': 'xxx'});\n  }));\n\n\n  afterEach(function() {\n    $httpBackend.verifyNoOutstandingExpectation();\n    $httpBackend.verifyNoOutstandingRequest();\n  });\n\n\n  it('should fetch authentication token', function() {\n    $httpBackend.expectGET('/auth.py');\n    var controller = scope.$new(MyController);\n    $httpBackend.flush();\n  });\n\n\n  it('should send msg to server', function() {\n    // now you don’t care about the authentication, but\n    // the controller will still send the request and\n    // $httpBackend will respond without you having to\n    // specify the expectation and response for this request\n    $httpBackend.expectPOST('/add-msg.py', 'message content').respond(201, '');\n\n    var controller = scope.$new(MyController);\n    $httpBackend.flush();\n    controller.saveMessage('message content');\n    expect(controller.status).toBe('Saving...');\n    $httpBackend.flush();\n    expect(controller.status).toBe('');\n  });\n\n\n  it('should send auth header', function() {\n    $httpBackend.expectPOST('/add-msg.py', undefined, function(headers) {\n      // check if the header was send, if it wasn't the expectation won't\n      // match the request and the test will fail\n      return headers['Authorization'] == 'xxx';\n    }).respond(201, '');\n\n    var controller = scope.$new(MyController);\n    controller.saveMessage('whatever');\n    $httpBackend.flush();\n  });\n  </pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 827,
            "description": "General factory function for $httpBackend mock.\nReturns instance for unit testing (when no arguments specified):\n  - passing through is disabled\n  - auto flushing is disabled\n\nReturns instance for e2e testing (when `$delegate` and `$browser` specified):\n  - passing through (delegating request to real backend) is enabled\n  - auto flushing is enabled",
            "params": [
                {
                    "name": "$delegate",
                    "description": "Real $httpBackend instance (allow passing through if specified)",
                    "type": "Object="
                },
                {
                    "name": "$browser",
                    "description": "Auto-flushing enabled if specified",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Instance of $httpBackend mock",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 914,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#when",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new backend definition.",
            "params": [
                {
                    "name": "method",
                    "description": "HTTP method.",
                    "type": "String"
                },
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers or function that receives http header\n  object and returns true if the headers match the current definition.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\n  request is handled.\n\n - respond – `{function([status,] data[, headers])|function(function(method, url, data, headers)}`\n   – The respond method takes a set of static data to be returned or a function that can return\n   an array containing response status (number), response data (string) and response headers\n   (Object).",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 952,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#whenGET",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new backend definition for GET requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\nrequest is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 965,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#whenHEAD",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new backend definition for HEAD requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\nrequest is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 978,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#whenDELETE",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new backend definition for DELETE requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\nrequest is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 991,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#whenPOST",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new backend definition for POST requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\nrequest is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1005,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#whenPUT",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new backend definition for PUT requests.  For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\nrequest is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1019,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#whenJSONP",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new backend definition for JSONP requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\nrequest is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1033,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#expect",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new request expectation.",
            "params": [
                {
                    "name": "method",
                    "description": "HTTP method.",
                    "type": "String"
                },
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers or function that receives http header\n  object and returns true if the headers match the current expectation.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\n request is handled.\n\n - respond – `{function([status,] data[, headers])|function(function(method, url, data, headers)}`\n   – The respond method takes a set of static data to be returned or a function that can return\n   an array containing response status (number), response data (string) and response headers\n   (Object).",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1064,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#expectGET",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new request expectation for GET requests. For more info see `expect()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\nrequest is handled. See #expect for more info.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1077,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#expectHEAD",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new request expectation for HEAD requests. For more info see `expect()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\n  request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1090,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#expectDELETE",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new request expectation for DELETE requests. For more info see `expect()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\n  request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1103,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#expectPOST",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new request expectation for POST requests. For more info see `expect()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\n  request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1117,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#expectPUT",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new request expectation for PUT requests. For more info see `expect()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\n  request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1131,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#expectPATCH",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new request expectation for PATCH requests. For more info see `expect()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\n  request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1145,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#expectJSONP",
            "methodof": "ngMock.$httpBackend",
            "description": "Creates a new request expectation for JSONP requests. For more info see `expect()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                }
            ],
            "return": {
                "description": "Returns an object with `respond` method that control how a matched\n  request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1159,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#flush",
            "methodof": "ngMock.$httpBackend",
            "description": "Flushes all pending requests using the trained responses.",
            "params": [
                {
                    "name": "count",
                    "description": "Number of responses to flush (in the order they arrived). If undefined,\n  all pending requests will be flushed. If there are no pending requests when the flush method\n  is called an exception is thrown (as this typically a sign of programming error).",
                    "type": "Number="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1187,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#verifyNoOutstandingExpectation",
            "methodof": "ngMock.$httpBackend",
            "description": "Verifies that all of the requests defined via the `expect` api were made. If any of the\nrequests were not made, verifyNoOutstandingExpectation throws an exception.\n\nTypically, you would call this method following each test case that asserts requests using an\n\"afterEach\" clause.\n\n<pre>\n  afterEach($httpBackend.verifyExpectations);\n</pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1209,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#verifyNoOutstandingRequest",
            "methodof": "ngMock.$httpBackend",
            "description": "Verifies that there are no outstanding requests that need to be flushed.\n\nTypically, you would call this method following each test case that asserts requests using an\n\"afterEach\" clause.\n\n<pre>\n  afterEach($httpBackend.verifyNoOutstandingRequest);\n</pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1230,
            "ngdoc": "method",
            "name": "ngMock.$httpBackend#resetExpectations",
            "methodof": "ngMock.$httpBackend",
            "description": "Resets all request expectations, but preserves all backend definitions. Typically, you would\ncall resetExpectations during a multiple-phase test when you want to reuse the same instance of\n$httpBackend mock.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1349,
            "ngdoc": "function",
            "name": "ngMock.$timeout",
            "description": "This service is just a simple decorator for {@link ng.$timeout $timeout} service\nthat adds a \"flush\" method.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1358,
            "ngdoc": "method",
            "name": "ngMock.$timeout#flush",
            "methodof": "ngMock.$timeout",
            "description": "Flushes the queue of pending tasks.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1367,
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1376,
            "ngdoc": "overview",
            "name": "ngMock",
            "description": "The `ngMock` is an angular module which is used with `ng` module and adds unit-test configuration as well as useful\nmocks to the {@link AUTO.$injector $injector}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1400,
            "ngdoc": "overview",
            "name": "ngMockE2E",
            "description": "The `ngMockE2E` is an angular module which contains mocks suitable for end-to-end testing.\nCurrently there is only one mock present in this module -\nthe {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1413,
            "ngdoc": "object",
            "name": "ngMockE2E.$httpBackend",
            "description": "Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of\napplications that use the {@link ng.$http $http service}.\n\n*Note*: For fake http backend implementation suitable for unit testing please see\n{@link ngMock.$httpBackend unit-testing $httpBackend mock}.\n\nThis implementation can be used to respond with static or dynamic responses via the `when` api\nand its shortcuts (`whenGET`, `whenPOST`, etc) and optionally pass through requests to the\nreal $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch\ntemplates from a webserver).\n\nAs opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application\nis being developed with the real backend api replaced with a mock, it is often desirable for\ncertain category of requests to bypass the mock and issue a real http request (e.g. to fetch\ntemplates or static files from the webserver). To configure the backend with this behavior\nuse the `passThrough` request handler of `when` instead of `respond`.\n\nAdditionally, we don't want to manually have to flush mocked out requests like we do during unit\ntesting. For this reason the e2e $httpBackend automatically flushes mocked out requests\nautomatically, closely simulating the behavior of the XMLHttpRequest object.\n\nTo setup the application to run with this http backend, you have to create a module that depends\non the `ngMockE2E` and your application modules and defines the fake backend:\n\n<pre>\n  myAppDev = angular.module('myAppDev', ['myApp', 'ngMockE2E']);\n  myAppDev.run(function($httpBackend) {\n    phones = [{name: 'phone1'}, {name: 'phone2'}];\n\n    // returns the current list of phones\n    $httpBackend.whenGET('/phones').respond(phones);\n\n    // adds a new phone to the phones array\n    $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\n      phones.push(angular.fromJSON(data));\n    });\n    $httpBackend.whenGET(/^\\/templates\\//).passThrough();\n    //...\n  });\n</pre>\n\nAfterwards, bootstrap your app with this new module.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1461,
            "ngdoc": "method",
            "name": "ngMockE2E.$httpBackend#when",
            "methodof": "ngMockE2E.$httpBackend",
            "description": "Creates a new backend definition.",
            "params": [
                {
                    "name": "method",
                    "description": "HTTP method.",
                    "type": "String"
                },
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers or function that receives http header\n  object and returns true if the headers match the current definition.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` and `passThrough` methods that\n  control how a matched request is handled.\n\n - respond – `{function([status,] data[, headers])|function(function(method, url, data, headers)}`\n   – The respond method takes a set of static data to be returned or a function that can return\n   an array containing response status (number), response data (string) and response headers\n   (Object).\n - passThrough – `{function()}` – Any request matching a backend definition with `passThrough`\n   handler, will be pass through to the real backend (an XHR request will be made to the\n   server.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1485,
            "ngdoc": "method",
            "name": "ngMockE2E.$httpBackend#whenGET",
            "methodof": "ngMockE2E.$httpBackend",
            "description": "Creates a new backend definition for GET requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` and `passThrough` methods that\n  control how a matched request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1498,
            "ngdoc": "method",
            "name": "ngMockE2E.$httpBackend#whenHEAD",
            "methodof": "ngMockE2E.$httpBackend",
            "description": "Creates a new backend definition for HEAD requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` and `passThrough` methods that\n  control how a matched request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1511,
            "ngdoc": "method",
            "name": "ngMockE2E.$httpBackend#whenDELETE",
            "methodof": "ngMockE2E.$httpBackend",
            "description": "Creates a new backend definition for DELETE requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` and `passThrough` methods that\n  control how a matched request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1524,
            "ngdoc": "method",
            "name": "ngMockE2E.$httpBackend#whenPOST",
            "methodof": "ngMockE2E.$httpBackend",
            "description": "Creates a new backend definition for POST requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` and `passThrough` methods that\n  control how a matched request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1538,
            "ngdoc": "method",
            "name": "ngMockE2E.$httpBackend#whenPUT",
            "methodof": "ngMockE2E.$httpBackend",
            "description": "Creates a new backend definition for PUT requests.  For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` and `passThrough` methods that\n  control how a matched request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1552,
            "ngdoc": "method",
            "name": "ngMockE2E.$httpBackend#whenPATCH",
            "methodof": "ngMockE2E.$httpBackend",
            "description": "Creates a new backend definition for PATCH requests.  For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                },
                {
                    "name": "data",
                    "description": "HTTP request body.",
                    "type": "(string|RegExp)="
                },
                {
                    "name": "headers",
                    "description": "HTTP headers.",
                    "type": "(Object|function(Object))="
                }
            ],
            "return": {
                "description": "Returns an object with `respond` and `passThrough` methods that\n  control how a matched request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1566,
            "ngdoc": "method",
            "name": "ngMockE2E.$httpBackend#whenJSONP",
            "methodof": "ngMockE2E.$httpBackend",
            "description": "Creates a new backend definition for JSONP requests. For more info see `when()`.",
            "params": [
                {
                    "name": "url",
                    "description": "HTTP url.",
                    "type": "String|RegExp"
                }
            ],
            "return": {
                "description": "Returns an object with `respond` and `passThrough` methods that\n  control how a matched request is handled.",
                "type": "RequestHandler"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1597,
            "description": "Global method to output any number of objects into JSTD console. Useful for debugging.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1651,
            "ngdoc": "function",
            "name": "angular.mock.module",
            "description": "*NOTE*: This is function is also published on window for easy access.<br>\n*NOTE*: Only available with {@link http://pivotal.github.com/jasmine/ jasmine}.\n\nThis function registers a module configuration code. It collects the configuration information\nwhich will be used when the injector is created by {@link angular.mock.inject inject}.\n\nSee {@link angular.mock.inject inject} for usage example",
            "params": [
                {
                    "name": "fns",
                    "description": "any number of modules which are represented as string\n       aliases or as anonymous module initialization functions. The modules are used to\n       configure the injector. The 'ng' and 'ngMock' modules are automatically loaded.",
                    "type": "...(string|Function)"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-mocks.js",
            "line": 1685,
            "ngdoc": "function",
            "name": "angular.mock.inject",
            "description": "*NOTE*: This is function is also published on window for easy access.<br>\n*NOTE*: Only available with {@link http://pivotal.github.com/jasmine/ jasmine}.\n\nThe inject function wraps a function into an injectable function. The inject() creates new\ninstance of {@link AUTO.$injector $injector} per test, which is then used for\nresolving references.\n\nSee also {@link angular.mock.module module}\n\nExample of what a typical jasmine tests looks like with the inject method.\n<pre>\n\n  angular.module('myApplicationModule', [])\n      .value('mode', 'app')\n      .value('version', 'v1.0.1');\n\n\n  describe('MyApp', function() {\n\n    // You need to load modules that you want to test,\n    // it loads only the \"ng\" module by default.\n    beforeEach(module('myApplicationModule'));\n\n\n    // inject() is used to inject arguments of all given functions\n    it('should provide a version', inject(function(mode, version) {\n      expect(version).toEqual('v1.0.1');\n      expect(mode).toEqual('app');\n    }));\n\n\n    // The inject and module method can also be used inside of the it or beforeEach\n    it('should override a version and test the new version is injected', function() {\n      // module() takes functions or strings (module aliases)\n      module(function($provide) {\n        $provide.value('version', 'overridden'); // override version here\n      });\n\n      inject(function(version) {\n        expect(version).toEqual('overridden');\n      });\n    ));\n  });\n\n</pre>",
            "params": [
                {
                    "name": "fns",
                    "description": "any number of functions which will be injected using the injector.",
                    "type": "...Function"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-resource.js",
            "line": 1,
            "license": "AngularJS v1.0.5\n(c) 2010-2012 Google, Inc. http://angularjs.org\nLicense: MIT",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-resource.js",
            "line": 9,
            "ngdoc": "overview",
            "name": "ngResource",
            "description": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-resource.js",
            "line": 15,
            "ngdoc": "object",
            "name": "ngResource.$resource",
            "requires": [
                "$http"
            ],
            "description": "A factory which creates a resource object that lets you interact with\n[RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n\nThe returned resource object has action methods which provide high-level behaviors without\nthe need to interact with the low level {@link ng.$http $http} service.",
            "params": [
                {
                    "name": "url",
                    "description": "A parameterized URL template with parameters prefixed by `:` as in\n  `/user/:username`. If you are using a URL with a port number (e.g. \n  `http://example.com:8080/api`), you'll need to escape the colon character before the port\n  number, like this: `$resource('http://example.com\\\\:8080/api')`.",
                    "type": "String"
                },
                {
                    "name": "paramDefaults",
                    "description": "Default values for `url` parameters. These can be overridden in\n  `actions` methods.\n\n  Each key value in the parameter object is first bound to url template if present and then any\n  excess keys are appended to the url search query after the `?`.\n\n  Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n  URL `/path/greet?salutation=Hello`.\n\n  If the parameter value is prefixed with `@` then the value of that parameter is extracted from\n  the data object (useful for non-GET operations).",
                    "type": "Object="
                },
                {
                    "name": "actions",
                    "description": "Hash with declaration of custom action that should extend the\n  default set of resource actions. The declaration should be created in the following format:\n\n      {action1: {method:?, params:?, isArray:?},\n       action2: {method:?, params:?, isArray:?},\n       ...}\n\n  Where:\n\n  - `action` – {string} – The name of action. This name becomes the name of the method on your\n    resource object.\n  - `method` – {string} – HTTP request method. Valid methods are: `GET`, `POST`, `PUT`, `DELETE`,\n    and `JSONP`\n  - `params` – {object=} – Optional set of pre-bound parameters for this action.\n  - isArray – {boolean=} – If true then the returned object for this action is an array, see\n    `returns` section.",
                    "type": "Object.<Object>="
                }
            ],
            "return": {
                "description": "A resource \"class\" object with methods for the default set of resource actions\n  optionally extended with custom `actions`. The default set contains these actions:\n\n      { 'get':    {method:'GET'},\n        'save':   {method:'POST'},\n        'query':  {method:'GET', isArray:true},\n        'remove': {method:'DELETE'},\n        'delete': {method:'DELETE'} };\n\n  Calling these methods invoke an {@link ng.$http} with the specified http method,\n  destination and parameters. When the data is returned from the server then the object is an\n  instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n  as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n  read, update, delete) on server-side data like this:\n  <pre>\n       var User = $resource('/user/:userId', {userId:'@id'});\n       var user = User.get({userId:123}, function() {\n         user.abc = true;\n         user.$save();\n       });\n    </pre>\n\n  It is important to realize that invoking a $resource object method immediately returns an\n  empty reference (object or array depending on `isArray`). Once the data is returned from the\n  server the existing reference is populated with the actual data. This is a useful trick since\n  usually the resource is assigned to a model which is then rendered by the view. Having an empty\n  object results in no rendering, once the data arrives from the server then the object is\n  populated with the data and the view automatically re-renders itself showing the new data. This\n  means that in most case one never has to write a callback function for the action methods.\n\n  The action methods on the class object or instance object can be invoked with the following\n  parameters:\n\n  - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n  - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n  - non-GET instance actions:  `instance.$action([parameters], [success], [error])`",
                "type": "Object"
            },
            "example": [
                "\n\n# Credit card resource\n\n<pre>\n    // Define CreditCard class\n    var CreditCard = $resource('/user/:userId/card/:cardId',\n     {userId:123, cardId:'@id'}, {\n      charge: {method:'POST', params:{charge:true}}\n     });\n\n    // We can retrieve a collection from the server\n    var cards = CreditCard.query(function() {\n      // GET: /user/123/card\n      // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\n      var card = cards[0];\n      // each item is an instance of CreditCard\n      expect(card instanceof CreditCard).toEqual(true);\n      card.name = \"J. Smith\";\n      // non GET methods are mapped onto the instances\n      card.$save();\n      // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n      // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\n      // our custom method is mapped as well.\n      card.$charge({amount:9.99});\n      // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n    });\n\n    // we can create an instance as well\n    var newCard = new CreditCard({number:'0123'});\n    newCard.name = \"Mike Smith\";\n    newCard.$save();\n    // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n    // server returns: {id:789, number:'01234', name: 'Mike Smith'};\n    expect(newCard.id).toEqual(789);\n</pre>\n\nThe object returned from this function execution is a resource \"class\" which has \"static\" method\nfor each action in the definition.\n\nCalling these methods invoke `$http` on the `url` template with the given `method` and `params`.\nWhen the data is returned from the server then the object is an instance of the resource type and\nall of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\noperations (create, read, update, delete) on server-side data.\n\n  <pre>\n    var User = $resource('/user/:userId', {userId:'@id'});\n    var user = User.get({userId:123}, function() {\n      user.abc = true;\n      user.$save();\n    });\n  </pre>\n\nIt's worth noting that the success callback for `get`, `query` and other method gets passed\nin the response that came from the server as well as $http header getter function, so one\ncould rewrite the above example and get access to http headers as:\n\n  <pre>\n    var User = $resource('/user/:userId', {userId:'@id'});\n    User.get({userId:123}, function(u, getResponseHeaders){\n      u.abc = true;\n      u.$save(function(u, putResponseHeaders) {\n        //u => saved user object\n        //putResponseHeaders => $http header getter\n      });\n    });\n  </pre>\n\n# Buzz client\n\n  Let's look at what a buzz client created with the `$resource` service looks like:\n   <doc:example>\n     <doc:source jsfiddle=\"false\">\n      <script>\n        function BuzzController($resource) {\n          this.userId = 'googlebuzz';\n          this.Activity = $resource(\n            'https://www.googleapis.com/buzz/v1/activities/:userId/:visibility/:activityId/:comments',\n            {alt:'json', callback:'JSON_CALLBACK'},\n            {get:{method:'JSONP', params:{visibility:'@self'}}, replies: {method:'JSONP', params:{visibility:'@self', comments:'@comments'}}}\n          );\n        }\n\n        BuzzController.prototype = {\n          fetch: function() {\n            this.activities = this.Activity.get({userId:this.userId});\n          },\n          expandReplies: function(activity) {\n            activity.replies = this.Activity.replies({userId:this.userId, activityId:activity.id});\n          }\n        };\n        BuzzController.$inject = ['$resource'];\n      </script>\n\n      <div ng-controller=\"BuzzController\">\n        <input ng-model=\"userId\"/>\n        <button ng-click=\"fetch()\">fetch</button>\n        <hr/>\n        <div ng-repeat=\"item in activities.data.items\">\n          <h1 style=\"font-size: 15px;\">\n            <img src=\"{{item.actor.thumbnailUrl}}\" style=\"max-height:30px;max-width:30px;\"/>\n            <a href=\"{{item.actor.profileUrl}}\">{{item.actor.name}}</a>\n            <a href ng-click=\"expandReplies(item)\" style=\"float: right;\">Expand replies: {{item.links.replies[0].count}}</a>\n          </h1>\n          {{item.object.content | html}}\n          <div ng-repeat=\"reply in item.replies.data.items\" style=\"margin-left: 20px;\">\n            <img src=\"{{reply.actor.thumbnailUrl}}\" style=\"max-height:30px;max-width:30px;\"/>\n            <a href=\"{{reply.actor.profileUrl}}\">{{reply.actor.name}}</a>: {{reply.content | html}}\n          </div>\n        </div>\n      </div>\n     </doc:source>\n     <doc:scenario>\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-resource.js",
            "line": 235,
            "description": "We need our custom method because encodeURIComponent is too aggressive and doesn't follow\nhttp://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\nsegments:\n   segment       = *pchar\n   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular-resource.js",
            "line": 254,
            "description": "This method is intended for encoding *key* or *value* parts of query component. We need a custom\nmethod becuase encodeURIComponent is too agressive and encodes stuff that doesn't have to be\nencoded per http://tools.ietf.org/html/rfc3986:\n   query       = *( pchar / \"/\" / \"?\" )\n   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1,
            "license": "AngularJS v1.0.5\n(c) 2010-2012 Google, Inc. http://angularjs.org\nLicense: MIT",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Converts the specified string to lowercase.",
            "params": [
                {
                    "name": "string",
                    "description": "String to be converted to lowercase.",
                    "type": "String"
                }
            ],
            "return": {
                "description": "Lowercased string.",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 23,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Converts the specified string to uppercase.",
            "params": [
                {
                    "name": "string",
                    "description": "String to be converted to uppercase.",
                    "type": "String"
                }
            ],
            "return": {
                "description": "Uppercased string.",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 66,
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 72,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Invokes the `iterator` function once for each item in `obj` collection, which can be either an\nobject or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`\nis the value of an object property or an array element and `key` is the object property key or\narray element index. Specifying a `context` for the function is optional.\n\nNote: this function was previously known as `angular.foreach`.\n\n  <pre>\n    var values = {name: 'misko', gender: 'male'};\n    var log = [];\n    angular.forEach(values, function(value, key){\n      this.push(key + ': ' + value);\n    }, log);\n    expect(log).toEqual(['name: misko', 'gender:male']);\n  </pre>",
            "params": [
                {
                    "name": "obj",
                    "description": "Object to iterate over.",
                    "type": "Object|Array"
                },
                {
                    "name": "iterator",
                    "description": "Iterator function.",
                    "type": "Function"
                },
                {
                    "name": "context",
                    "description": "Object to become context (`this`) for the iterator function.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Reference to `obj`.",
                "type": "Object|Array"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 101,
            "access": "private",
            "tagname": "",
            "params": [
                {
                    "name": "obj",
                    "description": "",
                    "type": "*"
                }
            ],
            "return": {
                "description": "Returns true if `obj` is an array or array-like object (NodeList, Arguments, ...)",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 167,
            "description": "when using forEach the params are value, key, but it is often useful to have key, value.",
            "params": [
                {
                    "name": "iteratorFn",
                    "description": "",
                    "type": "Function(string, *)"
                }
            ],
            "return": {
                "description": "",
                "type": "Function(*, string)"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 176,
            "description": "A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric\ncharacters such as '012ABC'. The reason why we are not using simply a number counter is that\nthe number string gets longer over time, and it can also overflow, where as the nextId\nwill grow much slower, it is a string, and it will never overflow.",
            "return": {
                "description": "an unique alpha-numeric string"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 206,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Extends the destination object `dst` by copying all of the properties from the `src` object(s)\nto `dst`. You can specify multiple `src` objects.",
            "params": [
                {
                    "name": "dst",
                    "description": "Destination object.",
                    "type": "Object"
                },
                {
                    "name": "src",
                    "description": "Source object(s).",
                    "type": "...Object"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 239,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "A function that performs no operations. This function can be useful when writing code in the\nfunctional style.\n  <pre>\n    function foo(callback) {\n      var result = calculateResult();\n      (callback || angular.noop)(result);\n    }\n  </pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 258,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "A function that returns its first argument. This function is useful when writing code in the\nfunctional style.\n\n  <pre>\n    function transformer(transformationFn, value) {\n      return (transformationFn || identity)(value);\n    };\n  </pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 279,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a reference is undefined.",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is undefined.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 293,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a reference is defined.",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is defined.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 307,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\nconsidered to be objects.",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is an `Object` but not `null`.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 322,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a reference is a `String`.",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is a `String`.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 336,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a reference is a `Number`.",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is a `Number`.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 350,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a value is a date.",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is a `Date`.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 366,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a reference is an `Array`.",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is an `Array`.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 382,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a reference is a `Function`.",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is a `Function`.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 396,
            "description": "Checks if `obj` is a window object.",
            "access": "private",
            "tagname": "",
            "params": [
                {
                    "name": "obj",
                    "description": "Object to check",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `obj` is a window obj.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 427,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if a reference is a DOM element (or wrapped jQuery element).",
            "params": [
                {
                    "name": "value",
                    "description": "Reference to check.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if `value` is a DOM element (or wrapped jQuery element).",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 444,
            "params": [
                {
                    "name": "str",
                    "description": "'key1,key2,...'"
                }
            ],
            "return": {
                "description": "in the form of {key1:true, key2:true, ...}",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 478,
            "description": "Determines the number of elements in an array, the number of properties an object has, or\nthe length of a string.\n\nNote: This function is used to augment the Object type in Angular expressions. See\n{@link angular.Object} for more information about Angular arrays.",
            "params": [
                {
                    "name": "obj",
                    "description": "Object, array, or string to inspect.",
                    "type": "Object|Array|string"
                },
                {
                    "name": "ownPropsOnly",
                    "description": "Count only \"own\" properties in an object",
                    "type": "Boolean",
                    "optional": true,
                    "optdefault": "false"
                }
            ],
            "return": {
                "description": "The size of `obj` or `0` if `obj` is neither an object nor an array.",
                "type": "Number"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 537,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Creates a deep copy of `source`, which should be an object or an array.\n\n* If no destination is supplied, a copy of the object or array is created.\n* If a destination is provided, all of its elements (for array) or properties (for objects)\n  are deleted and then all elements/properties from the source are copied to it.\n* If  `source` is not an object or array, `source` is returned.\n\nNote: this function is used to augment the Object type in Angular expressions. See\n{@link ng.$filter} for more information about Angular arrays.",
            "params": [
                {
                    "name": "source",
                    "description": "The source that will be used to make a copy.\n                  Can be any type, including primitives, `null`, and `undefined`.",
                    "type": "*"
                },
                {
                    "name": "destination",
                    "description": "Destination into which the source is copied. If\n    provided, must be of the same type as `source`.",
                    "type": "(Object|Array)="
                }
            ],
            "return": {
                "description": "The copy or updated `destination`, if `destination` was specified.",
                "type": "*"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 591,
            "description": "Create a shallow copy of an object",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 607,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Determines if two objects or two values are equivalent. Supports value types, arrays and\nobjects.\n\nTwo objects or values are considered equivalent if at least one of the following is true:\n\n* Both objects or values pass `===` comparison.\n* Both objects or values are of the same type and all of their properties pass `===` comparison.\n* Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)\n\nDuring a property comparision, properties of `function` type and properties with names\nthat begin with `$` are ignored.\n\nScope and DOMWindow objects are being compared only be identify (`===`).",
            "params": [
                {
                    "name": "o1",
                    "description": "Object or value to compare.",
                    "type": "*"
                },
                {
                    "name": "o2",
                    "description": "Object or value to compare.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "True if arguments are equal.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 678,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\n`fn`). You can supply optional `args` that are are prebound to the function. This feature is also\nknown as [function currying](http://en.wikipedia.org/wiki/Currying).",
            "params": [
                {
                    "name": "self",
                    "description": "Context which `fn` should be evaluated in.",
                    "type": "Object"
                },
                {
                    "name": "fn",
                    "description": "Function to be bound.",
                    "type": "Function()"
                },
                {
                    "name": "args",
                    "description": "Optional arguments to be prebound to the `fn` function call.",
                    "type": "...*"
                }
            ],
            "return": {
                "description": "Function that wraps the `fn` with all the specified bindings.",
                "type": "Function()"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 731,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Serializes input into a JSON-formatted string.",
            "params": [
                {
                    "name": "obj",
                    "description": "Input to be serialized into JSON.",
                    "type": "Object|Array|Date|string|number"
                },
                {
                    "name": "pretty",
                    "description": "If set to true, the JSON output will contain newlines and whitespace.",
                    "type": "Boolean="
                }
            ],
            "return": {
                "description": "Jsonified string representing `obj`.",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 748,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Deserializes a JSON string.",
            "params": [
                {
                    "name": "json",
                    "description": "JSON string to deserialize.",
                    "type": "String"
                }
            ],
            "return": {
                "description": "Deserialized thingy.",
                "type": "Object|Array|Date|string|number"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 776,
            "return": {
                "description": "Returns the string representation of the element.",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 803,
            "description": "Parses an escaped url query string into key-value pairs.",
            "return": {
                "description": "Object.<(string|boolean)>"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 828,
            "description": "We need our custom method because encodeURIComponent is too agressive and doesn't follow\nhttp://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\nsegments:\n   segment       = *pchar\n   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 847,
            "description": "This method is intended for encoding *key* or *value* parts of query component. We need a custom\nmethod becuase encodeURIComponent is too agressive and encodes stuff that doesn't have to be\nencoded per http://tools.ietf.org/html/rfc3986:\n   query       = *( pchar / \"/\" / \"?\" )\n   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 868,
            "ngdoc": "directive",
            "name": "ng.directive:ngApp",
            "element": "ANY",
            "params": [
                {
                    "name": "ngApp",
                    "description": "an optional application\n  {@link angular.module module} name to load.",
                    "type": "angular.Module"
                }
            ],
            "description": "Use this directive to auto-bootstrap on application. Only\none directive can be used per HTML document. The directive\ndesignates the root of the application and is typically placed\nat the root of the page.\n\nIn the example below if the `ngApp` directive would not be placed\non the `html` element then the document would not be compiled\nand the `{{ 1+2 }}` would not be resolved to `3`.\n\n`ngApp` is the easiest way to bootstrap an application.\n\n<doc:example>\n  <doc:source>\n   I can add: 1 + 2 =  {{ 1+2 }}\n  </doc:source>\n</doc:example>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 940,
            "ngdoc": "function",
            "name": "angular.bootstrap",
            "description": "Use this function to manually start up angular application.\n\nSee: {@link guide/bootstrap Bootstrap}",
            "params": [
                {
                    "name": "element",
                    "description": "DOM element which is the root of angular application.",
                    "type": "Element"
                },
                {
                    "name": "modules",
                    "description": "an array of module declarations. See: {@link angular.module modules}",
                    "type": "Array<String|Function>="
                }
            ],
            "return": {
                "description": "Returns the newly created injector for this app.",
                "type": "AUTO.$injector"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1000,
            "description": "throw error of the argument is falsy.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1020,
            "ngdoc": "interface",
            "name": "angular.Module",
            "description": "Interface for configuring angular {@link angular.module modules}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1035,
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1038,
            "ngdoc": "function",
            "name": "angular.module",
            "description": "The `angular.module` is a global place for creating and registering Angular modules. All\nmodules (angular core or 3rd party) that should be available to an application must be\nregistered using this mechanism.\n\n\n# Module\n\nA module is a collocation of services, directives, filters, and configuration information. Module\nis used to configure the {@link AUTO.$injector $injector}.\n\n<pre>\n// Create a new module\nvar myModule = angular.module('myModule', []);\n\n// register a new service\nmyModule.value('appName', 'MyCoolApp');\n\n// configure existing services inside initialization blocks.\nmyModule.config(function($locationProvider) {\n  // Configure existing providers\n  $locationProvider.hashPrefix('!');\n});\n</pre>\n\nThen you can create an injector and load your modules like this:\n\n<pre>\nvar injector = angular.injector(['ng', 'MyModule'])\n</pre>\n\nHowever it's more likely that you'll just use\n{@link ng.directive:ngApp ngApp} or\n{@link angular.bootstrap} to simplify this process for you.",
            "params": [
                {
                    "name": "name",
                    "description": "The name of the module to create or retrieve.",
                    "type": "!string"
                },
                {
                    "name": "requires",
                    "description": "If specified then new module is being created. If unspecified then the\n       the module is being retrieved for further configuration.",
                    "type": "Array.<string>="
                },
                {
                    "name": "configFn",
                    "description": "Optional configuration function for the module. Same as\n       {@link angular.Module#config Module#config()}.",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "new module with the {@link angular.Module} api.",
                "type": "Module"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1093,
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1096,
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1101,
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1107,
            "ngdoc": "property",
            "name": "angular.Module#requires",
            "propertyof": "angular.Module",
            "return": {
                "description": "List of module names which must be loaded before this module.",
                "type": "Array.<string>"
            },
            "description": "Holds the list of modules which the injector will load before the current module is loaded.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1117,
            "ngdoc": "property",
            "name": "angular.Module#name",
            "propertyof": "angular.Module",
            "return": {
                "description": "Name of the module.",
                "type": "String"
            },
            "description": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1127,
            "ngdoc": "method",
            "name": "angular.Module#provider",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "name",
                    "description": "service name",
                    "type": "String"
                },
                {
                    "name": "providerType",
                    "description": "Construction function for creating new instance of the service.",
                    "type": "Function"
                }
            ],
            "description": "See {@link AUTO.$provide#provider $provide.provider()}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1138,
            "ngdoc": "method",
            "name": "angular.Module#factory",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "name",
                    "description": "service name",
                    "type": "String"
                },
                {
                    "name": "providerFunction",
                    "description": "Function for creating new instance of the service.",
                    "type": "Function"
                }
            ],
            "description": "See {@link AUTO.$provide#factory $provide.factory()}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1149,
            "ngdoc": "method",
            "name": "angular.Module#service",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "name",
                    "description": "service name",
                    "type": "String"
                },
                {
                    "name": "constructor",
                    "description": "A constructor function that will be instantiated.",
                    "type": "Function"
                }
            ],
            "description": "See {@link AUTO.$provide#service $provide.service()}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1160,
            "ngdoc": "method",
            "name": "angular.Module#value",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "name",
                    "description": "service name",
                    "type": "String"
                },
                {
                    "name": "object",
                    "description": "Service instance object.",
                    "type": "*"
                }
            ],
            "description": "See {@link AUTO.$provide#value $provide.value()}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1171,
            "ngdoc": "method",
            "name": "angular.Module#constant",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "name",
                    "description": "constant name",
                    "type": "String"
                },
                {
                    "name": "object",
                    "description": "Constant value.",
                    "type": "*"
                }
            ],
            "description": "Because the constant are fixed, they get applied before other provide methods.\nSee {@link AUTO.$provide#constant $provide.constant()}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1183,
            "ngdoc": "method",
            "name": "angular.Module#filter",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "name",
                    "description": "Filter name.",
                    "type": "String"
                },
                {
                    "name": "filterFactory",
                    "description": "Factory function for creating new instance of filter.",
                    "type": "Function"
                }
            ],
            "description": "See {@link ng.$filterProvider#register $filterProvider.register()}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1194,
            "ngdoc": "method",
            "name": "angular.Module#controller",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "name",
                    "description": "Controller name.",
                    "type": "String"
                },
                {
                    "name": "constructor",
                    "description": "Controller constructor function.",
                    "type": "Function"
                }
            ],
            "description": "See {@link ng.$controllerProvider#register $controllerProvider.register()}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1205,
            "ngdoc": "method",
            "name": "angular.Module#directive",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "name",
                    "description": "directive name",
                    "type": "String"
                },
                {
                    "name": "directiveFactory",
                    "description": "Factory function for creating new instance of\ndirectives.",
                    "type": "Function"
                }
            ],
            "description": "See {@link ng.$compileProvider#directive $compileProvider.directive()}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1217,
            "ngdoc": "method",
            "name": "angular.Module#config",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "configFn",
                    "description": "Execute this function on module load. Useful for service\n   configuration.",
                    "type": "Function"
                }
            ],
            "description": "Use this method to register work which needs to be performed on module loading.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1228,
            "ngdoc": "method",
            "name": "angular.Module#run",
            "methodof": "angular.Module",
            "params": [
                {
                    "name": "initializationFn",
                    "description": "Execute this function after injector creation.\n   Useful for application initialization.",
                    "type": "Function"
                }
            ],
            "description": "Use this method to register work which should be performed when the injector is done\nloading all modules.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1250,
            "params": [
                {
                    "name": "provider",
                    "description": "",
                    "type": "String"
                },
                {
                    "name": "method",
                    "description": "",
                    "type": "String"
                },
                {
                    "name": "insertMethod",
                    "description": "",
                    "type": "String="
                }
            ],
            "return": {
                "description": "",
                "type": "angular.Module"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1268,
            "ngdoc": "property",
            "name": "angular.version",
            "description": "An object that contains information about the current AngularJS version. This object has the\nfollowing properties:\n\n- `full` – `{string}` – Full version string, such as \"0.9.18\".\n- `major` – `{number}` – Major version number, such as \"0\".\n- `minor` – `{number}` – Minor version number, such as \"9\".\n- `dot` – `{number}` – Dot version number, such as \"18\".\n- `codeName` – `{string}` – Code name of the release, such as \"jiggling-armfat\".",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1403,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.\n`angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if\njQuery is available, or a function that wraps the element or string in Angular's jQuery lite\nimplementation (commonly referred to as jqLite).\n\nReal jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`\nevent fired.\n\njqLite is a tiny, API-compatible subset of jQuery that allows\nAngular to manipulate the DOM. jqLite implements only the most commonly needed functionality\nwithin a very small footprint, so only a subset of the jQuery API - methods, arguments and\ninvocation styles - are supported.\n\nNote: All element references in Angular are always wrapped with jQuery or jqLite; they are never\nraw DOM references.\n\n## Angular's jQuery lite provides the following methods:\n\n- [addClass()](http://api.jquery.com/addClass/)\n- [after()](http://api.jquery.com/after/)\n- [append()](http://api.jquery.com/append/)\n- [attr()](http://api.jquery.com/attr/)\n- [bind()](http://api.jquery.com/bind/)\n- [children()](http://api.jquery.com/children/)\n- [clone()](http://api.jquery.com/clone/)\n- [contents()](http://api.jquery.com/contents/)\n- [css()](http://api.jquery.com/css/)\n- [data()](http://api.jquery.com/data/)\n- [eq()](http://api.jquery.com/eq/)\n- [find()](http://api.jquery.com/find/) - Limited to lookups by tag name.\n- [hasClass()](http://api.jquery.com/hasClass/)\n- [html()](http://api.jquery.com/html/)\n- [next()](http://api.jquery.com/next/)\n- [parent()](http://api.jquery.com/parent/)\n- [prepend()](http://api.jquery.com/prepend/)\n- [prop()](http://api.jquery.com/prop/)\n- [ready()](http://api.jquery.com/ready/)\n- [remove()](http://api.jquery.com/remove/)\n- [removeAttr()](http://api.jquery.com/removeAttr/)\n- [removeClass()](http://api.jquery.com/removeClass/)\n- [removeData()](http://api.jquery.com/removeData/)\n- [replaceWith()](http://api.jquery.com/replaceWith/)\n- [text()](http://api.jquery.com/text/)\n- [toggleClass()](http://api.jquery.com/toggleClass/)\n- [triggerHandler()](http://api.jquery.com/triggerHandler/) - Doesn't pass native event objects to handlers.\n- [unbind()](http://api.jquery.com/unbind/)\n- [val()](http://api.jquery.com/val/)\n- [wrap()](http://api.jquery.com/wrap/)\n\n## In addtion to the above, Angular provides additional methods to both jQuery and jQuery lite:\n\n- `controller(name)` - retrieves the controller of the current element or its parent. By default\n  retrieves controller associated with the `ngController` directive. If `name` is provided as\n  camelCase directive name, then the controller for this directive will be retrieved (e.g.\n  `'ngModel'`).\n- `injector()` - retrieves the injector of the current element or its parent.\n- `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current\n  element or its parent.\n- `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top\n  parent element is reached.",
            "params": [
                {
                    "name": "element",
                    "description": "HTML string or DOMElement to be wrapped into jQuery.",
                    "type": "String|DOMElement"
                }
            ],
            "return": {
                "description": "jQuery object.",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1490,
            "description": "Converts snake_case to camelCase.\nAlso there is special case for Moz prefix starting with upper case letter.",
            "params": [
                {
                    "name": "name",
                    "description": "Name to normalize"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 1885,
            "description": "Properties: writes return selection, reads return first value",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2142,
            "description": "chaining functions",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2162,
            "description": "Computes a hash of an 'obj'.\nHash of a:\n string is string\n number is number as string\n object is either result of calling $$hashKey function on the object or uniquely generated id,\n        that is also assigned to the $$hashKey property of the object.",
            "params": [
                {
                    "name": "obj",
                    "description": ""
                }
            ],
            "return": {
                "description": "hash string such that the same input will have the same hash string.\n        The resulting string key is in 'type:hashKey' format.",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2192,
            "description": "HashMap which can use objects as keys",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2199,
            "description": "Store key value pair",
            "params": [
                {
                    "name": "key",
                    "description": "key to store can be any type"
                },
                {
                    "name": "value",
                    "description": "value to store can be any type"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2208,
            "params": [
                {
                    "name": "key",
                    "description": ""
                }
            ],
            "return": {
                "description": "the value for the key"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2216,
            "description": "Remove the key/value pair",
            "params": [
                {
                    "name": "key",
                    "description": ""
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2227,
            "description": "A map where multiple values can be added to the same key such that they form a queue.",
            "return": {
                "description": "",
                "type": "HashQueueMap"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2233,
            "description": "Same as array push, but using an array as the value for the hash",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2245,
            "description": "Same as array shift, but using an array as the value for the hash",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2260,
            "description": "return the first item without deleting it",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2271,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Creates an injector function that can be used for retrieving services as well as for\ndependency injection (see {@link guide/di dependency injection}).",
            "params": [
                {
                    "name": "modules",
                    "description": "A list of module functions or their aliases. See\n       {@link angular.module}. The `ng` module must be explicitly added.",
                    "type": "Array.<string|Function>"
                }
            ],
            "return": {
                "description": "Injector function. See {@link AUTO.$injector $injector}.",
                "type": "Function()"
            },
            "example": [
                "\nTypical usage\n<pre>\n  // create an injector\n  var $injector = angular.injector(['ng']);\n\n  // use the injector to kick off your application\n  // use the type inference to auto inject arguments, or use implicit injection\n  $injector.invoke(function($rootScope, $compile, $document){\n    $compile($document)($rootScope);\n    $rootScope.$digest();\n  });\n</pre>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2301,
            "ngdoc": "overview",
            "name": "AUTO",
            "description": "Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2343,
            "ngdoc": "object",
            "name": "",
            "itemtype": "method",
            "description": "`$injector` is used to retrieve object instances as defined by\n{@link AUTO.$provide provider}, instantiate types, invoke methods,\nand load modules.\n\nThe following always holds true:\n\n<pre>\n  var $injector = angular.injector();\n  expect($injector.get('$injector')).toBe($injector);\n  expect($injector.invoke(function($injector){\n    return $injector;\n  }).toBe($injector);\n</pre>\n\n# Injection Function Annotation\n\nJavaScript does not have annotations, and annotations are needed for dependency injection. The\nfollowing ways are all valid way of annotating function with injection arguments and are equivalent.\n\n<pre>\n  // inferred (only works if code not minified/obfuscated)\n  $inject.invoke(function(serviceA){});\n\n  // annotated\n  function explicit(serviceA) {};\n  explicit.$inject = ['serviceA'];\n  $inject.invoke(explicit);\n\n  // inline\n  $inject.invoke(['serviceA', function(serviceA){}]);\n</pre>\n\n## Inference\n\nIn JavaScript calling `toString()` on a function returns the function definition. The definition can then be\nparsed and the function arguments can be extracted. *NOTE:* This does not work with minification, and obfuscation\ntools since these tools change the argument names.\n\n## `$inject` Annotation\nBy adding a `$inject` property onto a function the injection parameters can be specified.\n\n## Inline\nAs an array of injection names, where the last item in the array is the function to call.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2395,
            "ngdoc": "method",
            "name": "AUTO.$injector#get",
            "methodof": "AUTO.$injector",
            "description": "Return an instance of the service.",
            "params": [
                {
                    "name": "name",
                    "description": "The name of the instance to retrieve.",
                    "type": "String"
                }
            ],
            "return": {
                "description": "The instance.",
                "type": "*"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2407,
            "ngdoc": "method",
            "name": "AUTO.$injector#invoke",
            "methodof": "AUTO.$injector",
            "description": "Invoke the method and supply the method arguments from the `$injector`.",
            "params": [
                {
                    "name": "fn",
                    "description": "The function to invoke. The function arguments come form the function annotation.",
                    "type": "!function"
                },
                {
                    "name": "self",
                    "description": "The `this` for the invoked method.",
                    "type": "Object="
                },
                {
                    "name": "locals",
                    "description": "Optional object. If preset then any argument names are read from this object first, before\n  the `$injector` is consulted.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "the value returned by the invoked `fn` function.",
                "type": "*"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2422,
            "ngdoc": "method",
            "name": "AUTO.$injector#instantiate",
            "methodof": "AUTO.$injector",
            "description": "Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies\nall of the arguments to the constructor function as specified by the constructor annotation.",
            "params": [
                {
                    "name": "Type",
                    "description": "Annotated constructor function.",
                    "type": "Function"
                },
                {
                    "name": "locals",
                    "description": "Optional object. If preset then any argument names are read from this object first, before\n  the `$injector` is consulted.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "new instance of `Type`.",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2436,
            "ngdoc": "method",
            "name": "AUTO.$injector#annotate",
            "methodof": "AUTO.$injector",
            "description": "Returns an array of service names which the function is requesting for injection. This API is used by the injector\nto determine which services need to be injected into the function when the function is invoked. There are three\nways in which the function can be annotated with the needed dependencies.\n\n# Argument names\n\nThe simplest form is to extract the dependencies from the arguments of the function. This is done by converting\nthe function into a string using `toString()` method and extracting the argument names.\n<pre>\n  // Given\n  function MyController($scope, $route) {\n    // ...\n  }\n\n  // Then\n  expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\n</pre>\n\nThis method does not work with code minfication / obfuscation. For this reason the following annotation strategies\nare supported.\n\n# The `$inject` property\n\nIf a function has an `$inject` property and its value is an array of strings, then the strings represent names of\nservices to be injected into the function.\n<pre>\n  // Given\n  var MyController = function(obfuscatedScope, obfuscatedRoute) {\n    // ...\n  }\n  // Define function dependencies\n  MyController.$inject = ['$scope', '$route'];\n\n  // Then\n  expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\n</pre>\n\n# The array notation\n\nIt is often desirable to inline Injected functions and that's when setting the `$inject` property is very\ninconvenient. In these situations using the array notation to specify the dependencies in a way that survives\nminification is a better choice:\n\n<pre>\n  // We wish to write this (not minification / obfuscation safe)\n  injector.invoke(function($compile, $rootScope) {\n    // ...\n  });\n\n  // We are forced to write break inlining\n  var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {\n    // ...\n  };\n  tmpFn.$inject = ['$compile', '$rootScope'];\n  injector.invoke(tempFn);\n\n  // To better support inline function the inline annotation is supported\n  injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {\n    // ...\n  }]);\n\n  // Therefore\n  expect(injector.annotate(\n     ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])\n   ).toEqual(['$compile', '$rootScope']);\n</pre>",
            "params": [
                {
                    "name": "fn",
                    "description": "Function for which dependent service names need to be retrieved as described\n  above.",
                    "type": "function|Array.<string|Function>"
                }
            ],
            "return": {
                "description": "The names of the services which the function requires.",
                "type": "Array.<string>"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2518,
            "ngdoc": "object",
            "name": "AUTO.$provide",
            "description": "Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.\nThe providers share the same name as the instance they create with the `Provider` suffixed to them.\n\nA provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of\na service. The Provider can have additional methods which would allow for configuration of the provider.\n\n<pre>\n  function GreetProvider() {\n    var salutation = 'Hello';\n\n    this.salutation = function(text) {\n      salutation = text;\n    };\n\n    this.$get = function() {\n      return function (name) {\n        return salutation + ' ' + name + '!';\n      };\n    };\n  }\n\n  describe('Greeter', function(){\n\n    beforeEach(module(function($provide) {\n      $provide.provider('greet', GreetProvider);\n    });\n\n    it('should greet', inject(function(greet) {\n      expect(greet('angular')).toEqual('Hello angular!');\n    }));\n\n    it('should allow configuration of salutation', function() {\n      module(function(greetProvider) {\n        greetProvider.salutation('Ahoj');\n      });\n      inject(function(greet) {\n        expect(greet('angular')).toEqual('Ahoj angular!');\n      });\n    )};\n\n  });\n</pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2568,
            "ngdoc": "method",
            "name": "AUTO.$provide#provider",
            "methodof": "AUTO.$provide",
            "description": "Register a provider for a service. The providers can be retrieved and can have additional configuration methods.",
            "params": [
                {
                    "name": "name",
                    "description": "The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.",
                    "type": "String"
                },
                {
                    "name": "provider",
                    "description": "If the provider is:\n\n  - `Object`: then it should have a `$get` method. The `$get` method will be invoked using\n              {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.\n  - `Constructor`: a new instance of the provider will be created using\n              {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.",
                    "type": "(Object|function())"
                }
            ],
            "return": {
                "description": "registered provider instance",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2587,
            "ngdoc": "method",
            "name": "AUTO.$provide#factory",
            "methodof": "AUTO.$provide",
            "description": "A short hand for configuring services if only `$get` method is required.",
            "params": [
                {
                    "name": "name",
                    "description": "The name of the instance.",
                    "type": "String"
                },
                {
                    "name": "$getFn",
                    "description": "The $getFn for the instance creation. Internally this is a short hand for\n`$provide.provider(name, {$get: $getFn})`.",
                    "type": "Function()"
                }
            ],
            "return": {
                "description": "registered provider instance",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2602,
            "ngdoc": "method",
            "name": "AUTO.$provide#service",
            "methodof": "AUTO.$provide",
            "description": "A short hand for registering service of given class.",
            "params": [
                {
                    "name": "name",
                    "description": "The name of the instance.",
                    "type": "String"
                },
                {
                    "name": "constructor",
                    "description": "A class (constructor function) that will be instantiated.",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "registered provider instance",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2616,
            "ngdoc": "method",
            "name": "AUTO.$provide#value",
            "methodof": "AUTO.$provide",
            "description": "A short hand for configuring services if the `$get` method is a constant.",
            "params": [
                {
                    "name": "name",
                    "description": "The name of the instance.",
                    "type": "String"
                },
                {
                    "name": "value",
                    "description": "The value.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "registered provider instance",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2630,
            "ngdoc": "method",
            "name": "AUTO.$provide#constant",
            "methodof": "AUTO.$provide",
            "description": "A constant value, but unlike {@link AUTO.$provide#value value} it can be injected\ninto configuration function (other modules) and it is not interceptable by\n{@link AUTO.$provide#decorator decorator}.",
            "params": [
                {
                    "name": "name",
                    "description": "The name of the constant.",
                    "type": "String"
                },
                {
                    "name": "value",
                    "description": "The constant value.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "registered instance",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2646,
            "ngdoc": "method",
            "name": "AUTO.$provide#decorator",
            "methodof": "AUTO.$provide",
            "description": "Decoration of service, allows the decorator to intercept the service instance creation. The\nreturned instance may be the original instance, or a new instance which delegates to the\noriginal instance.",
            "params": [
                {
                    "name": "name",
                    "description": "The name of the service to decorate.",
                    "type": "String"
                },
                {
                    "name": "decorator",
                    "description": "This function will be invoked when the service needs to be\n   instanciated. The function is called using the {@link AUTO.$injector#invoke\n   injector.invoke} method and is therefore fully injectable. Local injection arguments:\n\n   * `$delegate` - The original service instance, which can be monkey patched, configured,\n     decorated or delegated to.",
                    "type": "Function()"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2873,
            "ngdoc": "function",
            "name": "ng.$anchorScroll",
            "requires": [
                "$window",
                "$location",
                "$rootScope"
            ],
            "description": "When called, it checks current value of `$location.hash()` and scroll to related element,\naccording to rules specified in\n{@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.\n\nIt also watches the `$location.hash()` and scroll whenever it changes to match any anchor.\nThis can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2940,
            "description": "This object has two goals:\n\n- hide all the global state in the browser caused by the window object\n- abstract away all the browser specific features and inconsistencies\n\nFor tests we provide {@link ngMock.$browser mock implementation} of the `$browser`\nservice, which can be used for convenient testing of the application without the interaction with\nthe real browser apis.",
            "name": "ng.$browser",
            "requires": [
                "$log"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2955,
            "params": [
                {
                    "name": "window",
                    "description": "The global window object.",
                    "type": "Object"
                },
                {
                    "name": "document",
                    "description": "jQuery wrapped document.",
                    "type": "Object"
                },
                {
                    "name": "XHR",
                    "description": "XMLHttpRequest constructor.",
                    "type": "Function()"
                },
                {
                    "name": "$log",
                    "description": "console.log or an object with the same interface.",
                    "type": "Object"
                },
                {
                    "name": "$sniffer",
                    "description": "$sniffer service",
                    "type": "Object"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 2980,
            "description": "Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`\ncounter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3001,
            "access": "private",
            "tagname": "Note: this method is used only by scenario runner\nTODO(vojta): prefix this method with $$ ?",
            "params": [
                {
                    "name": "callback",
                    "description": "Function that will be called when no outstanding request",
                    "type": "Function()"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3026,
            "name": "ng.$browser#addPollFn",
            "methodof": "ng.$browser",
            "params": [
                {
                    "name": "fn",
                    "description": "Poll function to add",
                    "type": "Function()"
                }
            ],
            "description": "Adds a function to the list of functions that poller periodically executes,\nand starts polling if not started yet.",
            "return": {
                "description": "the added function",
                "type": "Function()"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3044,
            "params": [
                {
                    "name": "interval",
                    "description": "How often should browser call poll functions (ms)",
                    "type": "Number"
                },
                {
                    "name": "setTimeout",
                    "description": "Reference to a real or fake `setTimeout` function.",
                    "type": "Function()"
                }
            ],
            "description": "Configures the poller to run in the specified intervals, using the specified\nsetTimeout fn and kicks it off.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3066,
            "name": "ng.$browser#url",
            "methodof": "ng.$browser",
            "description": "GETTER:\nWithout any argument, this method just returns current value of location.href.\n\nSETTER:\nWith at least one argument, this method sets url to new value.\nIf html5 history api supported, pushState/replaceState is used, otherwise\nlocation.href/location.replace is used.\nReturns its own instance to allow chaining\n\nNOTE: this api is intended for use only by the $location service. Please use the\n{@link ng.$location $location service} to change url.",
            "params": [
                {
                    "name": "url",
                    "description": "New url (when used as setter)",
                    "type": "String"
                },
                {
                    "name": "replace",
                    "description": "Should new url replace current history record ?",
                    "type": "Boolean="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3122,
            "name": "ng.$browser#onUrlChange",
            "methodof": "ng.$browser",
            "todo": [
                "(vojta): refactor to use node's syntax for events"
            ],
            "description": "Register callback function that will be called, when url changes.\n\nIt's only called when the url is changed by outside of angular:\n- user types different url into address bar\n- user clicks on history (forward/back) button\n- user clicks on a link\n\nIt's not called when url is changed by $browser.url() method\n\nThe listener gets called with new url as parameter.\n\nNOTE: this api is intended for use only by the $location service. Please use the\n{@link ng.$location $location service} to monitor url changes in angular apps.",
            "params": [
                {
                    "name": "listener",
                    "description": "Listener function to be called when url changes.",
                    "type": "Function(string)"
                }
            ],
            "return": {
                "description": "Returns the registered listener fn - handy if the fn is anonymous.",
                "type": "Function(string)"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3169,
            "description": "Returns current <base href>\n(always relative - without domain)",
            "return": {
                "description": "",
                "type": "String="
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3187,
            "name": "ng.$browser#cookies",
            "methodof": "ng.$browser",
            "params": [
                {
                    "name": "name",
                    "description": "Cookie name",
                    "type": "String="
                },
                {
                    "name": "value",
                    "description": "Cokkie value",
                    "type": "String="
                }
            ],
            "description": "The cookies method provides a 'private' low level access to browser cookies.\nIt is not meant to be used directly, use the $cookie service instead.\n\nThe return values vary depending on the arguments that the method was called with as follows:\n<ul>\n  <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>\n  <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>\n  <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>\n</ul>",
            "return": {
                "description": "Hash of all cookies (if called without any parameter)",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3246,
            "name": "ng.$browser#defer",
            "methodof": "ng.$browser",
            "params": [
                {
                    "name": "fn",
                    "description": "A function, who's execution should be defered.",
                    "type": "Function()"
                },
                {
                    "name": "delay",
                    "description": "of milliseconds to defer the function execution.",
                    "type": "Number=",
                    "optional": true,
                    "optdefault": "0"
                }
            ],
            "return": {
                "description": "DeferId that can be used to cancel the task via `$browser.defer.cancel()`.",
                "type": "*"
            },
            "description": "Executes a fn asynchroniously via `setTimeout(fn, delay)`.\n\nUnlike when calling `setTimeout` directly, in test this function is mocked and instead of using\n`setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed\nvia `$browser.defer.flush()`.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3273,
            "name": "ng.$browser#defer.cancel",
            "methodof": "ng.$browser.defer",
            "description": "Cancels a defered task identified with `deferId`.",
            "params": [
                {
                    "name": "deferId",
                    "description": "Token returned by the `$browser.defer` function.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "Returns `true` if the task hasn't executed yet and was successfuly canceled.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3301,
            "ngdoc": "object",
            "name": "ng.$cacheFactory",
            "description": "Factory that constructs cache objects.",
            "params": [
                {
                    "name": "cacheId",
                    "description": "Name or id of the newly created cache.",
                    "type": "String"
                },
                {
                    "name": "options",
                    "description": "Options object that specifies the cache behavior. Properties:\n\n  - `{number=}` `capacity` — turns the cache into LRU cache.",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Newly created cache object with the following set of methods:\n\n- `{object}` `info()` — Returns id, size, and options of cache.\n- `{void}` `put({string} key, {*} value)` — Puts a new key-value pair into the cache.\n- `{{*}}` `get({string} key)` — Returns cached value for `key` or undefined for cache miss.\n- `{void}` `remove({string} key)` — Removes a key-value pair from the cache.\n- `{void}` `removeAll()` — Removes all cached values.\n- `{void}` `destroy()` — Removes references to this cache from $cacheFactory.",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3407,
            "description": "makes the `entry` the freshEnd of the LRU linked list",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3426,
            "description": "bidirectionally links two entries of the LRU linked list",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3456,
            "ngdoc": "object",
            "name": "ng.$templateCache",
            "description": "Cache used for storing html templates.\n\nSee {@link ng.$cacheFactory $cacheFactory}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3493,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Compiles a piece of HTML string or DOM into a template and produces a template function, which\ncan then be used to link {@link ng.$rootScope.Scope scope} and the template together.\n\nThe compilation is a process of walking the DOM tree and trying to match DOM elements to\n{@link ng.$compileProvider#directive directives}. For each match it\nexecutes corresponding template function and collects the\ninstance functions into a single template function which is then returned.\n\nThe template function can then be used once to produce the view or as it is the case with\n{@link ng.directive:ngRepeat repeater} many-times, in which\ncase each call results in a view that is a DOM clone of the original template.\n\n<doc:example module=\"compile\">\n  <doc:source>\n   <script>\n     // declare a new module, and inject the $compileProvider\n     angular.module('compile', [], function($compileProvider) {\n       // configure new 'compile' directive by passing a directive\n       // factory function. The factory function injects the '$compile'\n       $compileProvider.directive('compile', function($compile) {\n         // directive factory creates a link function\n         return function(scope, element, attrs) {\n           scope.$watch(\n             function(scope) {\n                // watch the 'compile' expression for changes\n               return scope.$eval(attrs.compile);\n             },\n             function(value) {\n               // when the 'compile' expression changes\n               // assign it into the current DOM\n               element.html(value);\n\n               // compile the new DOM and link it to the current\n               // scope.\n               // NOTE: we only compile .childNodes so that\n               // we don't get into infinite loop compiling ourselves\n               $compile(element.contents())(scope);\n             }\n           );\n         };\n       })\n     });\n\n     function Ctrl($scope) {\n       $scope.name = 'Angular';\n       $scope.html = 'Hello {{name}}';\n     }\n   </script>\n   <div ng-controller=\"Ctrl\">\n     <input ng-model=\"name\"> <br>\n     <textarea ng-model=\"html\"></textarea> <br>\n     <div compile=\"html\"></div>\n   </div>\n  </doc:source>\n  <doc:scenario>\n    it('should auto compile', function() {\n      expect(element('div[compile]').text()).toBe('Hello Angular');\n      input('html').enter('{{name}}!');\n      expect(element('div[compile]').text()).toBe('Angular!');\n    });\n  </doc:scenario>\n</doc:example>",
            "params": [
                {
                    "name": "element",
                    "description": "Element or HTML string to compile into a template function.",
                    "type": "String|DOMElement"
                },
                {
                    "name": "transclude",
                    "description": "function available to directives.",
                    "type": "function(angular.Scope[, cloneAttachFn]"
                },
                {
                    "name": "maxPriority",
                    "description": "only apply directives lower then given priority (Only effects the\n                root element(s), not their children)",
                    "type": "Number"
                }
            ],
            "return": {
                "description": "a link function which is used to bind template\n(a DOM element/tree) to a scope. Where:\n\n * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.\n * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the\n              `template` and call the `cloneAttachFn` function allowing the caller to attach the\n              cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is\n              called as: <br> `cloneAttachFn(clonedElement, scope)` where:\n\n     * `clonedElement` - is a clone of the original `element` passed into the compiler.\n     * `scope` - is the current scope with which the linking function is working with.\n\nCalling the linking function returns the element of the template. It is either the original element\npassed in, or the clone of the element if the `cloneAttachFn` is provided.\n\nAfter linking the view is not updated until after a call to $digest which typically is done by\nAngular automatically.\n\nIf you need access to the bound view, there are two ways to do it:\n\n- If you are not asking the linking function to clone the template, create the DOM element(s)\n  before you send them to the compiler and keep this reference around.\n  <pre>\n    var element = $compile('<p>{{total}}</p>')(scope);\n  </pre>\n\n- if on the other hand, you need the element to be cloned, the view reference from the original\n  example would not point to the clone, but rather to the original template that was cloned. In\n  this case, you can access the clone via the cloneAttachFn:\n  <pre>\n    var templateHTML = angular.element('<p>{{total}}</p>'),\n        scope = ....;\n\n    var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {\n      //attach the clone to DOM document at the right place\n    });\n\n    //now we have reference to the cloned DOM via `clone`\n  </pre>\n\n\nFor information on how the compiler works, see the\n{@link guide/compiler Angular HTML Compiler} section of the Developer Guide.",
                "type": "Function(scope[, cloneAttachFn])"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3614,
            "ngdoc": "service",
            "name": "",
            "itemtype": "method",
            "description": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3631,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$compileProvider",
            "itemtype": "method",
            "description": "Register a new directives with the compiler.",
            "params": [
                {
                    "name": "name",
                    "description": "Name of the directive in camel-case. (ie <code>ngBind</code> which will match as\n               <code>ng-bind</code>).",
                    "type": "String"
                },
                {
                    "name": "directiveFactory",
                    "description": "An injectable directive factroy function. See {@link guide/directive} for more\n               info.",
                    "type": "Function"
                }
            ],
            "return": {
                "description": "Self for chaining.",
                "type": "ng.$compileProvider"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3682,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$compileProvider",
            "itemtype": "method",
            "description": "Retrieves or overrides the default regular expression that is used for whitelisting of safe\nurls during a[href] sanitization.\n\nThe sanitization is a security measure aimed at prevent XSS attacks via html links.\n\nAny url about to be assigned to a[href] via data-binding is first normalized and turned into an\nabsolute url. Afterwards the url is matched against the `urlSanitizationWhitelist` regular\nexpression. If a match is found the original url is written into the dom. Otherwise the\nabsolute url is prefixed with `'unsafe:'` string and only then it is written into the DOM.",
            "params": [
                {
                    "name": "regexp",
                    "description": "New regexp to whitelist urls with.",
                    "type": "RegExp="
                }
            ],
            "return": {
                "description": "Current RegExp if called without value or self for\n   chaining otherwise.",
                "type": "RegExp|ng.$compileProvider"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3727,
            "description": "Set a normalized attribute on the element in a way such that all directives\ncan share the attribute. This function properly handles boolean attributes.",
            "params": [
                {
                    "name": "key",
                    "description": "Normalized key. (ie ngAttribute)",
                    "type": "String"
                },
                {
                    "name": "value",
                    "description": "The value to set. If `null` attribute will be deleted.",
                    "type": "String|boolean"
                },
                {
                    "name": "writeAttr",
                    "description": "If false, does not write the value to DOM element attribute.\n    Defaults to true.",
                    "type": "Boolean="
                },
                {
                    "name": "attrName",
                    "description": "Optional none normalized name. Defaults to key.",
                    "type": "String="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3790,
            "description": "Observe an interpolated attribute.\nThe observer will never be called, if given attribute is not interpolated.",
            "params": [
                {
                    "name": "key",
                    "description": "Normalized key. (ie ngAttribute) .",
                    "type": "String"
                },
                {
                    "name": "fn",
                    "description": "Function that will be called whenever the attribute value changes.",
                    "type": "Function(*)"
                }
            ],
            "return": {
                "description": "the `fn` Function passed in.",
                "type": "Function(*)"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3876,
            "description": "Compile function matches each node in nodeList against the directives. Once all directives\nfor a particular node are collected their compile functions are executed. The compile\nfunctions return values - the linking functions - are combined into a composite linking\nfunction, which is the a linking function for the node.",
            "params": [
                {
                    "name": "nodeList",
                    "description": "an array of nodes to compile",
                    "type": "NodeList"
                },
                {
                    "name": "transcludeFn",
                    "description": "A linking function, where the\n       scope argument is auto-generated to the new child of the transcluded parent scope.",
                    "type": "function(angular.Scope[, cloneAttachFn]"
                },
                {
                    "name": "$rootElement",
                    "description": "If the nodeList is the root of the compilation tree then the\n       rootElement must be set the jqLite collection of the compile root. This is\n       needed so that the jqLite collection items can be replaced with widgets.",
                    "type": "DOMElement="
                },
                {
                    "name": "max",
                    "description": "directive priority",
                    "type": "Number="
                }
            ],
            "return": {
                "description": "A composite linking function of all of the matched directives or null.",
                "type": "?function"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 3963,
            "description": "Looks for directives on the given node and adds them to the directive collection which is\nsorted.",
            "params": [
                {
                    "name": "node",
                    "description": "Node to search."
                },
                {
                    "name": "directives",
                    "description": "An array to which the directives are added to. This array is sorted before\n       the function returns."
                },
                {
                    "name": "attrs",
                    "description": "The shared attrs object which is used to populate the normalized attributes."
                },
                {
                    "name": "maxPriority",
                    "description": "Max directive priority.",
                    "type": "Number="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4040,
            "description": "Once the directives have been collected their compile functions is executed. This method\nis responsible for inlining directive templates as well as terminating the application\nof the directives if the terminal directive has been reached..",
            "params": [
                {
                    "name": "directives",
                    "description": "Array of collected directives to execute their compile function.\n       this needs to be pre-sorted by priority order.",
                    "type": "Array"
                },
                {
                    "name": "compileNode",
                    "description": "The raw DOM node to apply the compile functions to",
                    "type": "Node"
                },
                {
                    "name": "templateAttrs",
                    "description": "The shared attribute function",
                    "type": "Object"
                },
                {
                    "name": "transcludeFn",
                    "description": "A linking function, where the\n       scope argument is auto-generated to the new child of the transcluded parent scope.",
                    "type": "function(angular.Scope[, cloneAttachFn]"
                },
                {
                    "name": "$rootElement",
                    "description": "If we are working on the root of the compile tree then this\n       argument has the root jqLite array so that we can replace widgets on it.",
                    "type": "DOMElement"
                }
            ],
            "return": {
                "description": "linkFn"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4354,
            "description": "looks up the directive and decorates it with exception handling and proper parameters. We\ncall this the boundDirective.",
            "params": [
                {
                    "name": "name",
                    "description": "name of the directive to look up.",
                    "type": "String"
                },
                {
                    "name": "location",
                    "description": "The directive must be found in specific format.\n  String containing any of theses characters:\n\n  * `E`: element name\n  * `A': attribute\n  * `C`: class\n  * `M`: comment",
                    "type": "String"
                }
            ],
            "return": {
                "description": "true if directive was added."
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4387,
            "description": "When the element is replaced with HTML template then the new attributes\non the template need to be merged with the existing attributes in the DOM.\nThe desired effect is to have both of the attributes present.",
            "params": [
                {
                    "name": "dst",
                    "description": "destination attributes (original DOM)",
                    "type": "Object"
                },
                {
                    "name": "src",
                    "description": "source attributes (from the directive template)",
                    "type": "Object"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4505,
            "description": "Sorting function for bound directives.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4569,
            "description": "This is a special jqLite.replaceWith, which can replace items which\nhave no parents, provided that the containing jqLite collection is provided.",
            "params": [
                {
                    "name": "$rootElement",
                    "description": "The root of the compile tree. Used so that we can replace nodes\n   in the root of the tree.",
                    "type": "JqLite="
                },
                {
                    "name": "$element",
                    "description": "The jqLite element which we are going to replace. We keep the shell,\n   but replace its DOM node reference.",
                    "type": "JqLite"
                },
                {
                    "name": "newNode",
                    "description": "The new DOM node.",
                    "type": "Node"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4604,
            "description": "Converts all accepted directives format into proper directive name.\nAll of these will become 'myDirective':\n  my:DiRective\n  my-directive\n  x-my-directive\n  data-my:directive\n\nAlso there is special case for Moz prefix starting with upper case letter.",
            "params": [
                {
                    "name": "name",
                    "description": "Name to normalize"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4619,
            "ngdoc": "object",
            "name": "ng.$compile.directive.Attributes",
            "description": "A shared object between directive compile / linking functions which contains normalized DOM element\nattributes. The the values reflect current binding state `{{ }}`. The normalization is needed\nsince all of these are treated as equivalent in Angular:\n\n         <span ng:bind=\"a\" ng-bind=\"a\" data-ng-bind=\"a\" x-ng-bind=\"a\">",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4631,
            "ngdoc": "property",
            "name": "ng.$compile.directive.Attributes#$attr",
            "propertyof": "ng.$compile.directive.Attributes",
            "return": {
                "description": "A map of DOM element attribute names to the normalized name. This is\n         needed to do reverse lookup from normalized name back to actual name.",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4640,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$compile.directive.Attributes",
            "itemtype": "method",
            "description": "Set DOM element attribute value.",
            "params": [
                {
                    "name": "name",
                    "description": "Normalized element attribute name of the property to modify. The name is\n         revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}\n         property to the original name.",
                    "type": "String"
                },
                {
                    "name": "value",
                    "description": "Value to set the attribute to.",
                    "type": "String"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4658,
            "description": "Closure compiler type information",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4677,
            "ngdoc": "object",
            "name": "ng.$controllerProvider",
            "description": "The {@link ng.$controller $controller service} is used by Angular to create new\ncontrollers.\n\nThis provider allows controller registration via the\n{@link ng.$controllerProvider#register register} method.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4691,
            "ngdoc": "function",
            "name": "ng.$controllerProvider#register",
            "methodof": "ng.$controllerProvider",
            "params": [
                {
                    "name": "name",
                    "description": "Controller name",
                    "type": "String"
                },
                {
                    "name": "constructor",
                    "description": "Controller constructor fn (optionally decorated with DI\n   annotations in the array notation).",
                    "type": "Function|Array"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4710,
            "ngdoc": "function",
            "name": "ng.$controller",
            "requires": [
                "$injector"
            ],
            "params": [
                {
                    "name": "constructor",
                    "description": "If called with a function then it's considered to be the\n   controller constructor function. Otherwise it's considered to be a string which is used\n   to retrieve the controller constructor using the following steps:\n\n   * check if a controller with given name is registered via `$controllerProvider`\n   * check if evaluating the string on the current scope returns a constructor\n   * check `window[constructor]` on the global `window` object",
                    "type": "Function|string"
                },
                {
                    "name": "locals",
                    "description": "Injection locals for Controller.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "Instance of given controller.",
                "type": "Object"
            },
            "description": "`$controller` service is responsible for instantiating controllers.\n\nIt's just simple call to {@link AUTO.$injector $injector}, but extracted into\na service, so that one can override this service with {@link https://gist.github.com/1649788\nBC version}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4748,
            "ngdoc": "object",
            "name": "ng.$document",
            "requires": [
                "$window"
            ],
            "description": "A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`\nelement.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4763,
            "ngdoc": "function",
            "name": "ng.$exceptionHandler",
            "requires": [
                "$log"
            ],
            "description": "Any uncaught exception in angular expressions is delegated to this service.\nThe default implementation simply delegates to `$log.error` which logs it into\nthe browser console.\n\nIn unit tests, if `angular-mocks.js` is loaded, this service is overridden by\n{@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.",
            "params": [
                {
                    "name": "exception",
                    "description": "Exception associated with the error.",
                    "type": "Error"
                },
                {
                    "name": "cause",
                    "description": "optional information about the context in which\n      the error was thrown.",
                    "type": "String="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4789,
            "ngdoc": "object",
            "name": "",
            "itemtype": "method",
            "description": "Used for configuring the interpolation markup. Defaults to `{{` and `}}`.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4802,
            "ngdoc": "method",
            "name": "ng.$interpolateProvider#startSymbol",
            "methodof": "ng.$interpolateProvider",
            "description": "Symbol to denote start of expression in the interpolated string. Defaults to `{{`.",
            "params": [
                {
                    "name": "value",
                    "description": "new value to set the starting symbol to.",
                    "type": "String="
                }
            ],
            "return": {
                "description": "Returns the symbol when used as getter and self if used as setter.",
                "type": "String|self"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4821,
            "ngdoc": "method",
            "name": "ng.$interpolateProvider#endSymbol",
            "methodof": "ng.$interpolateProvider",
            "description": "Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.",
            "params": [
                {
                    "name": "value",
                    "description": "new value to set the ending symbol to.",
                    "type": "String="
                }
            ],
            "return": {
                "description": "Returns the symbol when used as getter and self if used as setter.",
                "type": "String|self"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4845,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "requires": [
                "$parse"
            ],
            "description": "Compiles a string with markup into an interpolation function. This service is used by the\nHTML {@link ng.$compile $compile} service for data binding. See\n{@link ng.$interpolateProvider $interpolateProvider} for configuring the\ninterpolation markup.\n\n\n      <pre>\n        var $interpolate = ...; // injected\n        var exp = $interpolate('Hello {{name}}!');\n        expect(exp({name:'Angular'}).toEqual('Hello Angular!');\n      </pre>",
            "params": [
                {
                    "name": "text",
                    "description": "The text with markup to interpolate.",
                    "type": "String"
                },
                {
                    "name": "mustHaveExpression",
                    "description": "if set to true then the interpolation string must have\n   embedded expression in order to return an interpolation function. Strings with no\n   embedded expression will return null for the interpolation function.",
                    "type": "Boolean="
                }
            ],
            "return": {
                "description": "an interpolation function which is used to compute the interpolated\n   string. The function has these parameters:\n\n   * `context`: an object against which any expressions embedded in the strings are evaluated\n     against.",
                "type": "Function(context)"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4933,
            "ngdoc": "method",
            "name": "ng.$interpolate#startSymbol",
            "methodof": "ng.$interpolate",
            "description": "Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.\n\nUse {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change\nthe symbol.",
            "return": {
                "description": "start symbol.",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4950,
            "ngdoc": "method",
            "name": "ng.$interpolate#endSymbol",
            "methodof": "ng.$interpolate",
            "description": "Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\n\nUse {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change\nthe symbol.",
            "return": {
                "description": "start symbol.",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 4976,
            "description": "Encode path using encodeUriSegment, ignoring forward slashes",
            "params": [
                {
                    "name": "path",
                    "description": "Path to encode",
                    "type": "String"
                }
            ],
            "return": {
                "description": "",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5068,
            "description": "LocationUrl represents an url\nThis object is exposed as $location service when HTML5 mode is enabled and supported",
            "is_constructor": 1,
            "params": [
                {
                    "name": "url",
                    "description": "HTML5 url",
                    "type": "String"
                },
                {
                    "name": "pathPrefix",
                    "description": "",
                    "type": "String"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5079,
            "description": "Parse given html5 (regular) url string into properties",
            "params": [
                {
                    "name": "newAbsoluteUrl",
                    "description": "HTML5 url",
                    "type": "String"
                }
            ],
            "access": "private",
            "tagname": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5098,
            "description": "Compose url and update `absUrl` property",
            "access": "private",
            "tagname": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5123,
            "description": "LocationHashbangUrl represents url\nThis object is exposed as $location service when html5 history api is disabled or not supported",
            "is_constructor": 1,
            "params": [
                {
                    "name": "url",
                    "description": "Legacy url",
                    "type": "String"
                },
                {
                    "name": "hashPrefix",
                    "description": "Prefix for hash part (containing path and search)",
                    "type": "String"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5134,
            "description": "Parse given hashbang url into properties",
            "params": [
                {
                    "name": "url",
                    "description": "Hashbang url",
                    "type": "String"
                }
            ],
            "access": "private",
            "tagname": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5161,
            "description": "Compose hashbang url and update `absUrl` property",
            "access": "private",
            "tagname": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5187,
            "description": "Has any change been replacing ?",
            "access": "private",
            "tagname": "",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5193,
            "ngdoc": "method",
            "name": "ng.$location#absUrl",
            "methodof": "ng.$location",
            "description": "This method is getter only.\n\nReturn full url representation with all segments encoded according to rules specified in\n{@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.",
            "return": {
                "description": "full url",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5208,
            "ngdoc": "method",
            "name": "ng.$location#url",
            "methodof": "ng.$location",
            "description": "This method is getter / setter.\n\nReturn url (e.g. `/path?a=b#hash`) when called without any parameter.\n\nChange path, search and hash, when called with parameter and return `$location`.",
            "params": [
                {
                    "name": "url",
                    "description": "New url without base prefix (e.g. `/path?a=b#hash`)",
                    "type": "String="
                }
            ],
            "return": {
                "description": "url",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5235,
            "ngdoc": "method",
            "name": "ng.$location#protocol",
            "methodof": "ng.$location",
            "description": "This method is getter only.\n\nReturn protocol of current url.",
            "return": {
                "description": "protocol of current url",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5249,
            "ngdoc": "method",
            "name": "ng.$location#host",
            "methodof": "ng.$location",
            "description": "This method is getter only.\n\nReturn host of current url.",
            "return": {
                "description": "host of current url.",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5263,
            "ngdoc": "method",
            "name": "ng.$location#port",
            "methodof": "ng.$location",
            "description": "This method is getter only.\n\nReturn port of current url.",
            "return": {
                "description": "port",
                "type": "Number"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5277,
            "ngdoc": "method",
            "name": "ng.$location#path",
            "methodof": "ng.$location",
            "description": "This method is getter / setter.\n\nReturn path of current url when called without any parameter.\n\nChange path when called with parameter and return `$location`.\n\nNote: Path should always begin with forward slash (/), this method will add the forward slash\nif it is missing.",
            "params": [
                {
                    "name": "path",
                    "description": "New path",
                    "type": "String="
                }
            ],
            "return": {
                "description": "path",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5299,
            "ngdoc": "method",
            "name": "ng.$location#search",
            "methodof": "ng.$location",
            "description": "This method is getter / setter.\n\nReturn search part (as object) of current url when called without any parameter.\n\nChange search part when called with parameter and return `$location`.",
            "params": [
                {
                    "name": "search",
                    "description": "New search params - string or hash object",
                    "type": "String|object<string,string>="
                },
                {
                    "name": "paramValue",
                    "description": "If `search` is a string, then `paramValue` will override only a\n   single search parameter. If the value is `null`, the parameter will be deleted.",
                    "type": "String="
                }
            ],
            "return": {
                "description": "search",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5335,
            "ngdoc": "method",
            "name": "ng.$location#hash",
            "methodof": "ng.$location",
            "description": "This method is getter / setter.\n\nReturn hash fragment when called without any parameter.\n\nChange hash fragment when called with parameter and return `$location`.",
            "params": [
                {
                    "name": "hash",
                    "description": "New hash fragment",
                    "type": "String="
                }
            ],
            "return": {
                "description": "hash",
                "type": "String"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5352,
            "ngdoc": "method",
            "name": "ng.$location#replace",
            "methodof": "ng.$location",
            "description": "If called, all changes to $location during current `$digest` will be replacing current history\nrecord, instead of adding new one.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5402,
            "ngdoc": "object",
            "name": "ng.$location",
            "requires": [
                "$browser",
                "$sniffer",
                "$rootElement"
            ],
            "description": "The $location service parses the URL in the browser address bar (based on the\n{@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL\navailable to your application. Changes to the URL in the address bar are reflected into\n$location service and changes to $location are reflected into the browser address bar.\n\n**The $location service:**\n\n- Exposes the current URL in the browser address bar, so you can\n  - Watch and observe the URL.\n  - Change the URL.\n- Synchronizes the URL with the browser when the user\n  - Changes the address bar.\n  - Clicks the back or forward button (or clicks a History link).\n  - Clicks on a link.\n- Represents the URL object as a set of methods (protocol, host, port, path, search, hash).\n\nFor more information see {@link guide/dev_guide.services.$location Developer Guide: Angular\nServices: Using $location}",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5431,
            "ngdoc": "object",
            "name": "ng.$locationProvider",
            "description": "Use the `$locationProvider` to configure how the application deep linking paths are stored.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5441,
            "ngdoc": "property",
            "name": "ng.$locationProvider#hashPrefix",
            "methodof": "ng.$locationProvider",
            "description": "",
            "params": [
                {
                    "name": "prefix",
                    "description": "Prefix for hash part (containing path and search)",
                    "type": "String="
                }
            ],
            "return": {
                "description": "current value if used as getter or itself (chaining) if used as setter",
                "type": "*"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5458,
            "ngdoc": "property",
            "name": "ng.$locationProvider#html5Mode",
            "methodof": "ng.$locationProvider",
            "description": "",
            "params": [
                {
                    "name": "mode",
                    "description": "Use HTML5 strategy if available.",
                    "type": "String="
                }
            ],
            "return": {
                "description": "current value if used as getter or itself (chaining) if used as setter",
                "type": "*"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5587,
            "ngdoc": "object",
            "name": "ng.$log",
            "requires": [
                "$window"
            ],
            "description": "Simple service for logging. Default implementation writes the message\ninto the browser's console (if present).\n\nThe main purpose of this service is to simplify debugging and troubleshooting.",
            "example": [
                "\n  <example>\n    <file name=\"script.js\">\n      function LogCtrl($scope, $log) {\n        $scope.$log = $log;\n        $scope.message = 'Hello World!';\n      }\n    </file>\n    <file name=\"index.html\">\n      <div ng-controller=\"LogCtrl\">\n        <p>Reload this page with open console, enter text and hit the log button...</p>\n        Message:\n        <input type=\"text\" ng-model=\"message\"/>\n        <button ng-click=\"$log.log(message)\">log</button>\n        <button ng-click=\"$log.warn(message)\">warn</button>\n        <button ng-click=\"$log.info(message)\">info</button>\n        <button ng-click=\"$log.error(message)\">error</button>\n      </div>\n    </file>\n  </example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5623,
            "ngdoc": "method",
            "name": "ng.$log#log",
            "methodof": "ng.$log",
            "description": "Write a log message",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5633,
            "ngdoc": "method",
            "name": "ng.$log#warn",
            "methodof": "ng.$log",
            "description": "Write a warning message",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5643,
            "ngdoc": "method",
            "name": "ng.$log#info",
            "methodof": "ng.$log",
            "description": "Write an information message",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 5653,
            "ngdoc": "method",
            "name": "ng.$log#error",
            "methodof": "ng.$log",
            "description": "Write an error message",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6364,
            "description": "Return the value accesible from the object by path. Any undefined traversals are ignored",
            "params": [
                {
                    "name": "obj",
                    "description": "starting object",
                    "type": "Object"
                },
                {
                    "name": "path",
                    "description": "path to traverse",
                    "type": "String"
                },
                {
                    "name": "bindFnToScope",
                    "description": "",
                    "type": "Boolean=true"
                }
            ],
            "return": {
                "description": "value as accesbile by path"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6393,
            "description": "Implementation of the \"Black Hole\" variant from:\n- http://jsperf.com/angularjs-parse-getter/4\n- http://jsperf.com/path-evaluation-simplified/7",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6515,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Converts Angular {@link guide/expression expression} into a function.\n\n<pre>\n  var getter = $parse('user.name');\n  var setter = getter.assign;\n  var context = {user:{name:'angular'}};\n  var locals = {user:{name:'local'}};\n\n  expect(getter(context)).toEqual('angular');\n  setter(context, 'newValue');\n  expect(context.user.name).toEqual('newValue');\n  expect(getter(context, locals)).toEqual('local');\n</pre>",
            "params": [
                {
                    "name": "expression",
                    "description": "String expression to compile.",
                    "type": "String"
                }
            ],
            "return": {
                "description": "a function which represents the compiled expression:\n\n   * `context` – `{object}` – an object against which any expressions embedded in the strings\n     are evaluated against (tipically a scope object).\n   * `locals` – `{object=}` – local variables context object, useful for overriding values in\n     `context`.\n\n   The return function also has an `assign` property, if the expression is assignable, which\n   allows one to set values to expressions.",
                "type": "Function(context, locals)"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6567,
            "ngdoc": "service",
            "name": "ng.$q",
            "requires": [
                "$rootScope"
            ],
            "description": "A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).\n\n[The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an\ninterface for interacting with an object that represents the result of an action that is\nperformed asynchronously, and may or may not be finished at any given point in time.\n\nFrom the perspective of dealing with error handling, deferred and promise APIs are to\nasynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.\n\n<pre>\n  // for the purpose of this example let's assume that variables `$q` and `scope` are\n  // available in the current lexical scope (they could have been injected or passed in).\n\n  function asyncGreet(name) {\n    var deferred = $q.defer();\n\n    setTimeout(function() {\n      // since this fn executes async in a future turn of the event loop, we need to wrap\n      // our code into an $apply call so that the model changes are properly observed.\n      scope.$apply(function() {\n        if (okToGreet(name)) {\n          deferred.resolve('Hello, ' + name + '!');\n        } else {\n          deferred.reject('Greeting ' + name + ' is not allowed.');\n        }\n      });\n    }, 1000);\n\n    return deferred.promise;\n  }\n\n  var promise = asyncGreet('Robin Hood');\n  promise.then(function(greeting) {\n    alert('Success: ' + greeting);\n  }, function(reason) {\n    alert('Failed: ' + reason);\n  });\n</pre>\n\nAt first it might not be obvious why this extra complexity is worth the trouble. The payoff\ncomes in the way of\n[guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).\n\nAdditionally the promise api allows for composition that is very hard to do with the\ntraditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.\nFor more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the\nsection on serial or parallel joining of promises.\n\n\n# The Deferred API\n\nA new instance of deferred is constructed by calling `$q.defer()`.\n\nThe purpose of the deferred object is to expose the associated Promise instance as well as APIs\nthat can be used for signaling the successful or unsuccessful completion of the task.\n\n**Methods**\n\n- `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection\n  constructed via `$q.reject`, the promise will be rejected instead.\n- `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to\n  resolving it with a rejection constructed via `$q.reject`.\n\n**Properties**\n\n- promise – `{Promise}` – promise object associated with this deferred.\n\n\n# The Promise API\n\nA new promise instance is created when a deferred instance is created and can be retrieved by\ncalling `deferred.promise`.\n\nThe purpose of the promise object is to allow for interested parties to get access to the result\nof the deferred task when it completes.\n\n**Methods**\n\n- `then(successCallback, errorCallback)` – regardless of when the promise was or will be resolved\n  or rejected calls one of the success or error callbacks asynchronously as soon as the result\n  is available. The callbacks are called with a single argument the result or rejection reason.\n\n  This method *returns a new promise* which is resolved or rejected via the return value of the\n  `successCallback` or `errorCallback`.\n\n\n# Chaining promises\n\nBecause calling `then` api of a promise returns a new derived promise, it is easily possible\nto create a chain of promises:\n\n<pre>\n  promiseB = promiseA.then(function(result) {\n    return result + 1;\n  });\n\n  // promiseB will be resolved immediately after promiseA is resolved and its value will be\n  // the result of promiseA incremented by 1\n</pre>\n\nIt is possible to create chains of any length and since a promise can be resolved with another\npromise (which will defer its resolution further), it is possible to pause/defer resolution of\nthe promises at any point in the chain. This makes it possible to implement powerful apis like\n$http's response interceptors.\n\n\n# Differences between Kris Kowal's Q and $q\n\n There are three main differences:\n\n- $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation\n  mechanism in angular, which means faster propagation of resolution or rejection into your\n  models and avoiding unnecessary browser repaints, which would result in flickering UI.\n- $q promises are recognized by the templating engine in angular, which means that in templates\n  you can treat promises attached to a scope as if they were the resulting values.\n- Q has many more features that $q, but that comes at a cost of bytes. $q is tiny, but contains\n  all the important functionality needed for common async tasks.\n\n # Testing\n\n <pre>\n   it('should simulate promise', inject(function($q, $rootScope) {\n     var deferred = $q.defer();\n     var promise = deferred.promise;\n     var resolvedValue;\n\n     promise.then(function(value) { resolvedValue = value; });\n     expect(resolvedValue).toBeUndefined();\n\n     // Simulate resolving of promise\n     deferred.resolve(123);\n     // Note that the 'then' function does not get called synchronously.\n     // This is because we want the promise API to always be async, whether or not\n     // it got called synchronously or asynchronously.\n     expect(resolvedValue).toBeUndefined();\n\n     // Propagate promise resolution to 'then' functions using $apply().\n     $rootScope.$apply();\n     expect(resolvedValue).toEqual(123);\n   });\n </pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6725,
            "description": "Constructs a promise manager.",
            "params": [
                {
                    "name": "nextTick",
                    "description": "Function for executing functions in the next turn.",
                    "type": "Function(function)"
                },
                {
                    "name": "exceptionHandler",
                    "description": "Function into which unexpected exceptions are passed for\n    debugging purposes.",
                    "type": "function(...*)"
                }
            ],
            "return": {
                "description": "Promise manager.",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6735,
            "ngdoc": "",
            "name": "ng.$q#defer",
            "methodof": "ng.$q",
            "description": "Creates a `Deferred` object which represents a task which will finish in the future.",
            "return": {
                "description": "Returns a new instance of deferred.",
                "type": "Deferred"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6825,
            "ngdoc": "",
            "name": "ng.$q#reject",
            "methodof": "ng.$q",
            "description": "Creates a promise that is resolved as rejected with the specified `reason`. This api should be\nused to forward rejection in a chain of promises. If you are dealing with the last promise in\na promise chain, you don't need to worry about it.\n\nWhen comparing deferreds/promises to the familiar behavior of try/catch/throw, think of\n`reject` as the `throw` keyword in JavaScript. This also means that if you \"catch\" an error via\na promise error callback and you want to forward the error to the promise derived from the\ncurrent promise, you have to \"rethrow\" the error by returning a rejection constructed via\n`reject`.\n\n<pre>\n  promiseB = promiseA.then(function(result) {\n    // success: do something and resolve promiseB\n    //          with the old or a new result\n    return result;\n  }, function(reason) {\n    // error: handle the error if possible and\n    //        resolve promiseB with newPromiseOrValue,\n    //        otherwise forward the rejection to promiseB\n    if (canHandle(reason)) {\n     // handle the error and recover\n     return newPromiseOrValue;\n    }\n    return $q.reject(reason);\n  });\n</pre>",
            "params": [
                {
                    "name": "reason",
                    "description": "Constant, message, exception or an object representing the rejection reason.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "Returns a promise that was already resolved as rejected with the `reason`.",
                "type": "Promise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6873,
            "ngdoc": "",
            "name": "ng.$q#when",
            "methodof": "ng.$q",
            "description": "Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.\nThis is useful when you are dealing with an object that might or might not be a promise, or if\nthe promise comes from a source that can't be trusted.",
            "params": [
                {
                    "name": "value",
                    "description": "Value or a promise",
                    "type": "*"
                }
            ],
            "return": {
                "description": "Returns a single promise that will be resolved with an array of values,\n  each value corresponding to the promise at the same index in the `promises` array. If any of\n  the promises is resolved with a rejection, this resulting promise will be resolved with the\n  same rejection.",
                "type": "Promise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6936,
            "ngdoc": "",
            "name": "ng.$q#all",
            "methodof": "ng.$q",
            "description": "Combines multiple promises into a single promise that is resolved when all of the input\npromises are resolved.",
            "params": [
                {
                    "name": "promises",
                    "description": "An array of promises.",
                    "type": "Array.<Promise>"
                }
            ],
            "return": {
                "description": "Returns a single promise that will be resolved with an array of values,\n  each value corresponding to the promise at the same index in the `promises` array. If any of\n  the promises is resolved with a rejection, this resulting promise will be resolved with the\n  same rejection.",
                "type": "Promise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6981,
            "ngdoc": "object",
            "name": "",
            "itemtype": "method",
            "description": "Used for configuring routes. See {@link ng.$route $route} for an example.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 6993,
            "ngdoc": "method",
            "name": "ng.$routeProvider#when",
            "methodof": "ng.$routeProvider",
            "params": [
                {
                    "name": "path",
                    "description": "Route path (matched against `$location.path`). If `$location.path`\n   contains redundant trailing slash or is missing one, the route will still match and the\n   `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   route definition.\n\n   `path` can contain named groups starting with a colon (`:name`). All characters up to the\n   next slash are matched and stored in `$routeParams` under the given `name` when the route\n   matches.",
                    "type": "String"
                },
                {
                    "name": "route",
                    "description": "Mapping information to be assigned to `$route.current` on route\n   match.\n\n   Object properties:\n\n   - `controller` – `{(string|function()=}` – Controller fn that should be associated with newly\n     created scope or the name of a {@link angular.Module#controller registered controller}\n     if passed as a string.\n   - `template` – `{string=}` –  html template as a string that should be used by\n     {@link ng.directive:ngView ngView} or\n     {@link ng.directive:ngInclude ngInclude} directives.\n     this property takes precedence over `templateUrl`.\n   - `templateUrl` – `{string=}` – path to an html template that should be used by\n     {@link ng.directive:ngView ngView}.\n   - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n     be injected into the controller. If any of these dependencies are promises, they will be\n     resolved and converted to a value before the controller is instantiated and the\n     `$routeChangeSuccess` event is fired. The map object is:\n\n     - `key` – `{string}`: a name of a dependency to be injected into the controller.\n     - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n       Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}\n       and the return value is treated as the dependency. If the result is a promise, it is resolved\n       before its value is injected into the controller.\n\n   - `redirectTo` – {(string|function())=} – value to update\n     {@link ng.$location $location} path with and trigger route redirection.\n\n     If `redirectTo` is a function, it will be called with the following parameters:\n\n     - `{Object.<string>}` - route parameters extracted from the current\n       `$location.path()` by applying the current route templateUrl.\n     - `{string}` - current `$location.path()`\n     - `{Object}` - current `$location.search()`\n\n     The custom `redirectTo` function is expected to return a string which will be used\n     to update `$location.path()` and `$location.search()`.\n\n   - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()\n   changes.\n\n     If the option is set to `false` and url in the browser changes, then\n     `$routeUpdate` event is broadcasted on the root scope.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "self",
                "type": "Object"
            },
            "description": "Adds a new route definition to the `$route` service.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7071,
            "ngdoc": "method",
            "name": "ng.$routeProvider#otherwise",
            "methodof": "ng.$routeProvider",
            "description": "Sets route definition that will be used on route change when no other route definition\nis matched.",
            "params": [
                {
                    "name": "params",
                    "description": "Mapping information to be assigned to `$route.current`.",
                    "type": "Object"
                }
            ],
            "return": {
                "description": "self",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7092,
            "ngdoc": "object",
            "name": "current Reference to the current route definition.!~YUIDOC_LINE~!The route definition contains:!~YUIDOC_LINE~!!~YUIDOC_LINE~!  - `controller`: The controller constructor as define in route definition.!~YUIDOC_LINE~!  - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for!~YUIDOC_LINE~!    controller instantiation. The `locals` contain!~YUIDOC_LINE~!    the resolved values of the `resolve` map. Additionally the `locals` also contain:!~YUIDOC_LINE~!!~YUIDOC_LINE~!    - `$scope` - The current route scope.!~YUIDOC_LINE~!    - `$template` - The current route template HTML.",
            "requires": [
                "$location",
                "$routeParams"
            ],
            "itemtype": "property",
            "type": "Object",
            "description": "Is used for deep-linking URLs to controllers and views (HTML partials).\nIt watches `$location.url()` and tries to map the path to an existing route definition.\n\nYou can define routes through {@link ng.$routeProvider $routeProvider}'s API.\n\nThe `$route` service is typically used in conjunction with {@link ng.directive:ngView ngView}\ndirective and the {@link ng.$routeParams $routeParams} service.",
            "example": [
                "\n      This example shows how changing the URL hash causes the `$route` to match a route against the\n      URL, and the `ngView` pulls in the partial.\n\n      Note that this example is using {@link ng.directive:script inlined templates}\n      to get it working on jsfiddle as well.\n\n    <example module=\"ngView\">\n      <file name=\"index.html\">\n        <div ng-controller=\"MainCntl\">\n          Choose:\n          <a href=\"Book/Moby\">Moby</a> |\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n          <a href=\"Book/Gatsby\">Gatsby</a> |\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n          <div ng-view></div>\n          <hr />\n\n          <pre>$location.path() = {{$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{$route.current.params}}</pre>\n          <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n          <pre>$routeParams = {{$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name=\"book.html\">\n        controller: {{name}}<br />\n        Book Id: {{params.bookId}}<br />\n      </file>\n\n      <file name=\"chapter.html\">\n        controller: {{name}}<br />\n        Book Id: {{params.bookId}}<br />\n        Chapter Id: {{params.chapterId}}\n      </file>\n\n      <file name=\"script.js\">\n        angular.module('ngView', [], function($routeProvider, $locationProvider) {\n          $routeProvider.when('/Book/:bookId', {\n            templateUrl: 'book.html',\n            controller: BookCntl,\n            resolve: {\n              // I will cause a 1 second delay\n              delay: function($q, $timeout) {\n                var delay = $q.defer();\n                $timeout(delay.resolve, 1000);\n                return delay.promise;\n              }\n            }\n          });\n          $routeProvider.when('/Book/:bookId/ch/:chapterId', {\n            templateUrl: 'chapter.html',\n            controller: ChapterCntl\n          });\n\n          // configure html5 to get links working on jsfiddle\n          $locationProvider.html5Mode(true);\n        });\n\n        function MainCntl($scope, $route, $routeParams, $location) {\n          $scope.$route = $route;\n          $scope.$location = $location;\n          $scope.$routeParams = $routeParams;\n        }\n\n        function BookCntl($scope, $routeParams) {\n          $scope.name = \"BookCntl\";\n          $scope.params = $routeParams;\n        }\n\n        function ChapterCntl($scope, $routeParams) {\n          $scope.name = \"ChapterCntl\";\n          $scope.params = $routeParams;\n        }\n      </file>\n\n      <file name=\"scenario.js\">\n        it('should load and compile correct template', function() {\n          element('a:contains(\"Moby: Ch1\")').click();\n          var content = element('.doc-example-live [ng-view]').text();\n          expect(content).toMatch(/controller\\: ChapterCntl/);\n          expect(content).toMatch(/Book Id\\: Moby/);\n          expect(content).toMatch(/Chapter Id\\: 1/);\n\n          element('a:contains(\"Scarlet\")').click();\n          sleep(2); // promises are not part of scenario waiting\n          content = element('.doc-example-live [ng-view]').text();\n          expect(content).toMatch(/controller\\: BookCntl/);\n          expect(content).toMatch(/Book Id\\: Scarlet/);\n        });\n      </file>\n    </example>"
            ],
            "class": "",
            "subprops": [
                {
                    "name": "routes",
                    "description": "Array of all configured routes.",
                    "type": "Array.<Object>"
                }
            ]
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7217,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeStart",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted before a route change. At this  point the route services starts\nresolving all of the dependencies needed for the route change to occurs.\nTypically this involves fetching the view template as well as any dependencies\ndefined in `resolve` route property. Once  all of the dependencies are resolved\n`$routeChangeSuccess` is fired.",
            "params": [
                {
                    "name": "next",
                    "description": "Future route information.",
                    "type": "Route"
                },
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7233,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeSuccess",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted after a route dependencies are resolved.\n{@link ng.directive:ngView ngView} listens for the directive\nto instantiate the controller and render the view.",
            "params": [
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                },
                {
                    "name": "previous",
                    "description": "Previous route information.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7247,
            "ngdoc": "event",
            "name": "ng.$route#$routeChangeError",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "Broadcasted if any of the resolve promises are rejected.",
            "params": [
                {
                    "name": "current",
                    "description": "Current route information.",
                    "type": "Route"
                },
                {
                    "name": "previous",
                    "description": "Previous route information.",
                    "type": "Route"
                },
                {
                    "name": "rejection",
                    "description": "Rejection of the promise. Usually the error of the failed promise.",
                    "type": "Route"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7260,
            "ngdoc": "event",
            "name": "ng.$route#$routeUpdate",
            "eventof": "ng.$route",
            "eventtype": "broadcast on root scope",
            "description": "The `reloadOnSearch` property has been set to false, and we are reusing the same\ninstance of the Controller.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7275,
            "ngdoc": "method",
            "name": "ng.$route#reload",
            "methodof": "ng.$route",
            "description": "Causes `$route` service to reload the current route even if\n{@link ng.$location $location} hasn't changed.\n\nAs a result of that, {@link ng.directive:ngView ngView}\ncreates new scope, reinstantiates the controller.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7299,
            "params": [
                {
                    "name": "on",
                    "description": "current url",
                    "type": "String"
                },
                {
                    "name": "when",
                    "description": "route when template to match the url against",
                    "type": "String"
                }
            ],
            "return": {
                "description": "",
                "type": "?Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7410,
            "return": {
                "description": "the current active route, by matching it against the URL"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7428,
            "return": {
                "description": "interpolation of the redirect path with the parametrs"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7449,
            "ngdoc": "object",
            "name": "ng.$routeParams",
            "requires": [
                "$route"
            ],
            "description": "Current set of route parameters. The route parameters are a combination of the\n{@link ng.$location $location} `search()`, and `path()`. The `path` parameters\nare extracted when the {@link ng.$route $route} path is matched.\n\nIn case of parameter name collision, `path` params take precedence over `search` params.\n\nThe service guarantees that the identity of the `$routeParams` object will remain unchanged\n(but its properties will likely change) even when a route change occurs.",
            "example": [
                "\n<pre>\n // Given:\n // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n // Route: /Chapter/:chapterId/Section/:sectionId\n //\n // Then\n $routeParams ==> {chapterId:1, sectionId:2, search:'moby'}\n</pre>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7478,
            "description": "DESIGN NOTES\n\nThe design decisions behind the scope ware heavily favored for speed and memory consumption.\n\nThe typical use of scope is to watch the expressions, which most of the time return the same\nvalue as last time so we optimize the operation.\n\nClosures construction is expensive from speed as well as memory:\n  - no closures, instead ups prototypical inheritance for API\n  - Internal state needs to be stored on scope directly, which means that private state is\n    exposed as $$____ properties\n\nLoop operations are optimized by using while(count--) { ... }\n  - this means that in order to keep the same order of execution as addition we have to add\n    items to the array at the begging (shift) instead of at the end (push)\n\nChild scopes are created and removed often\n  - Using array would be slow since inserts in meddle are expensive so we use linked list\n\nThere are few watches then a lot of observers. This is why you don't want the observer to be\nimplemented in the same way as watch. Watch requires return of initialization function which\nare expensive to construct.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7504,
            "ngdoc": "object",
            "name": "ng.$rootScopeProvider",
            "description": "Provider for the $rootScope service.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7512,
            "ngdoc": "function",
            "name": "ng.$rootScopeProvider#digestTtl",
            "methodof": "ng.$rootScopeProvider",
            "description": "Sets the number of digest iteration the scope should attempt to execute before giving up and\nassuming that the model is unstable.\n\nThe current default is 10 iterations.",
            "params": [
                {
                    "name": "limit",
                    "description": "The number of digest iterations.",
                    "type": "Number"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7527,
            "ngdoc": "object",
            "name": "ng.$rootScope",
            "description": "Every application has a single root {@link ng.$rootScope.Scope scope}.\nAll other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide\nevent processing life-cycle. See {@link guide/scope developer guide on scopes}.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7549,
            "ngdoc": "function",
            "name": "ng.$rootScope.Scope",
            "description": "A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the\n{@link AUTO.$injector $injector}. Child scopes are created using the\n{@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when\ncompiled HTML template is executed.)\n\nHere is a simple scope snippet to show how you can interact with the scope.\n<pre>\n       angular.injector(['ng']).invoke(function($rootScope) {\n          var scope = $rootScope.$new();\n          scope.salutation = 'Hello';\n          scope.name = 'World';\n\n          expect(scope.greeting).toEqual(undefined);\n\n          scope.$watch('name', function() {\n            scope.greeting = scope.salutation + ' ' + scope.name + '!';\n          }); // initialize the watch\n\n          expect(scope.greeting).toEqual(undefined);\n          scope.name = 'Misko';\n          // still old value, since watches have not been called yet\n          expect(scope.greeting).toEqual(undefined);\n\n          scope.$digest(); // fire all  the watches\n          expect(scope.greeting).toEqual('Hello Misko!');\n       });\n</pre>\n\n# Inheritance\nA scope can inherit from a parent scope, as in this example:\n<pre>\n        var parent = $rootScope;\n        var child = parent.$new();\n\n        parent.salutation = \"Hello\";\n        child.name = \"World\";\n        expect(child.salutation).toEqual('Hello');\n\n        child.salutation = \"Welcome\";\n        expect(child.salutation).toEqual('Welcome');\n        expect(parent.salutation).toEqual('Hello');\n</pre>",
            "params": [
                {
                    "name": "providers",
                    "description": "Map of service factory which need to be provided\n    for the current scope. Defaults to {@link ng}.",
                    "type": "Object.<string, function()>="
                },
                {
                    "name": "instanceCache",
                    "description": "Provides pre-instantiated services which should\n    append/override services provided by `providers`. This is handy when unit-testing and having\n    the need to override a default service.",
                    "type": "Object.<string, *>="
                }
            ],
            "return": {
                "description": "Newly created scope.",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7618,
            "ngdoc": "property",
            "name": "ng.$rootScope.Scope#$id",
            "propertyof": "ng.$rootScope.Scope",
            "return": {
                "description": "Unique scope ID (monotonically increasing alphanumeric sequence) useful for\n  debugging.",
                "type": "Number"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7628,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Creates a new child {@link ng.$rootScope.Scope scope}.\n\nThe parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and\n{@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope\nhierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.\n\n{@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for\nthe scope and its child scopes to be permanently detached from the parent and thus stop\nparticipating in model change detection and listener notification by invoking.",
            "params": [
                {
                    "name": "isolate",
                    "description": "if true then the scope does not prototypically inherit from the\n        parent scope. The scope is isolated, as it can not see parent scope properties.\n        When creating widgets it is useful for the widget to not accidentally read parent\n        state.",
                    "type": "Boolean"
                }
            ],
            "return": {
                "description": "The newly created child scope.",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7687,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Registers a `listener` callback to be executed whenever the `watchExpression` changes.\n\n- The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest $digest()} and\n  should return the value which will be watched. (Since {@link ng.$rootScope.Scope#$digest $digest()}\n  reruns when it detects changes the `watchExpression` can execute multiple times per\n  {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)\n- The `listener` is called only when the value from the current `watchExpression` and the\n  previous call to `watchExpression` are not equal (with the exception of the initial run,\n  see below). The inequality is determined according to\n  {@link angular.equals} function. To save the value of the object for later comparison, the\n  {@link angular.copy} function is used. It also means that watching complex options will\n  have adverse memory and performance implications.\n- The watch `listener` may change the model, which may trigger other `listener`s to fire. This\n  is achieved by rerunning the watchers until no changes are detected. The rerun iteration\n  limit is 10 to prevent an infinite loop deadlock.\n\n\nIf you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,\nyou can register a `watchExpression` function with no `listener`. (Since `watchExpression`\ncan execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a change is\ndetected, be prepared for multiple calls to your listener.)\n\nAfter a watcher is registered with the scope, the `listener` fn is called asynchronously\n(via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the\nwatcher. In rare cases, this is undesirable because the listener is called when the result\nof `watchExpression` didn't change. To detect this scenario within the `listener` fn, you\ncan compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the\nlistener was called due to initialization.\n\n\n# Example\n<pre>\n          // let's assume that scope was dependency injected as the $rootScope\n          var scope = $rootScope;\n          scope.name = 'misko';\n          scope.counter = 0;\n\n          expect(scope.counter).toEqual(0);\n          scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; });\n          expect(scope.counter).toEqual(0);\n\n          scope.$digest();\n          // no variable change\n          expect(scope.counter).toEqual(0);\n\n          scope.name = 'adam';\n          scope.$digest();\n          expect(scope.counter).toEqual(1);\n</pre>",
            "params": [
                {
                    "name": "watchExpression",
                    "description": "Expression that is evaluated on each\n   {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a\n   call to the `listener`.\n\n   - `string`: Evaluated as {@link guide/expression expression}\n   - `function(scope)`: called with current `scope` as a parameter.",
                    "type": "(function()|string)"
                },
                {
                    "name": "listener",
                    "description": "Callback called whenever the return value of\n  the `watchExpression` changes.\n\n   - `string`: Evaluated as {@link guide/expression expression}\n   - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.",
                    "type": "(function()|string)="
                },
                {
                    "name": "objectEquality",
                    "description": "Compare object for equality rather than for reference.",
                    "type": "Boolean="
                }
            ],
            "return": {
                "description": "Returns a deregistration function for this listener.",
                "type": "Function()"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7791,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Process all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and its children.\nBecause a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the\n`$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} until no more listeners are\nfiring. This means that it is possible to get into an infinite loop. This function will throw\n`'Maximum iteration limit exceeded.'` if the number of iterations exceeds 10.\n\nUsually you don't call `$digest()` directly in\n{@link ng.directive:ngController controllers} or in\n{@link ng.$compileProvider#directive directives}.\nInstead a call to {@link ng.$rootScope.Scope#$apply $apply()} (typically from within a\n{@link ng.$compileProvider#directive directives}) will force a `$digest()`.\n\nIf you want to be notified whenever `$digest()` is called,\nyou can register a `watchExpression` function  with {@link ng.$rootScope.Scope#$watch $watch()}\nwith no `listener`.\n\nYou may have a need to call `$digest()` from within unit-tests, to simulate the scope\nlife-cycle.\n\n# Example\n<pre>\n          var scope = ...;\n          scope.name = 'misko';\n          scope.counter = 0;\n\n          expect(scope.counter).toEqual(0);\n          scope.$watch('name', function(newValue, oldValue) {\n            scope.counter = scope.counter + 1;\n          });\n          expect(scope.counter).toEqual(0);\n\n          scope.$digest();\n          // no variable change\n          expect(scope.counter).toEqual(0);\n\n          scope.name = 'adam';\n          scope.$digest();\n          expect(scope.counter).toEqual(1);\n</pre>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7916,
            "ngdoc": "event",
            "name": "ng.$rootScope.Scope#$destroy",
            "eventof": "ng.$rootScope.Scope",
            "eventtype": "broadcast on scope being destroyed",
            "description": "Broadcasted when a scope and its children are being destroyed.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7926,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Removes the current scope (and all of its children) from the parent scope. Removal implies\nthat calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer\npropagate to the current scope and its children. Removal also implies that the current\nscope is eligible for garbage collection.\n\nThe `$destroy()` is usually used by directives such as\n{@link ng.directive:ngRepeat ngRepeat} for managing the\nunrolling of the loop.\n\nJust before a scope is destroyed a `$destroy` event is broadcasted on this scope.\nApplication code can register a `$destroy` event handler that will give it chance to\nperform any necessary cleanup.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7965,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Executes the `expression` on the current scope returning the result. Any exceptions in the\nexpression are propagated (uncaught). This is useful when evaluating Angular expressions.\n\n# Example\n<pre>\n          var scope = ng.$rootScope.Scope();\n          scope.a = 1;\n          scope.b = 2;\n\n          expect(scope.$eval('a+b')).toEqual(3);\n          expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);\n</pre>",
            "params": [
                {
                    "name": "expression",
                    "description": "An angular expression to be executed.\n\n   - `string`: execute using the rules as defined in  {@link guide/expression expression}.\n   - `function(scope)`: execute the function with the current `scope` parameter.",
                    "type": "(string|function())="
                }
            ],
            "return": {
                "description": "The result of evaluating the expression.",
                "type": "*"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 7996,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Executes the expression on the current scope at a later point in time.\n\nThe `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:\n\n  - it will execute in the current script execution context (before any DOM rendering).\n  - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after\n    `expression` execution.\n\nAny exceptions from the execution of the expression are forwarded to the\n{@link ng.$exceptionHandler $exceptionHandler} service.",
            "params": [
                {
                    "name": "expression",
                    "description": "An angular expression to be executed.\n\n   - `string`: execute using the rules as defined in  {@link guide/expression expression}.\n   - `function(scope)`: execute the function with the current `scope` parameter.",
                    "type": "(string|function())="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8024,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "`$apply()` is used to execute an expression in angular from outside of the angular framework.\n(For example from browser DOM events, setTimeout, XHR or third party libraries).\nBecause we are calling into the angular framework we need to perform proper scope life-cycle\nof {@link ng.$exceptionHandler exception handling},\n{@link ng.$rootScope.Scope#$digest executing watches}.\n\n## Life cycle\n\n# Pseudo-Code of `$apply()`\n<pre>\n          function $apply(expr) {\n            try {\n              return $eval(expr);\n            } catch (e) {\n              $exceptionHandler(e);\n            } finally {\n              $root.$digest();\n            }\n          }\n</pre>\n\n\nScope's `$apply()` method transitions through the following stages:\n\n1. The {@link guide/expression expression} is executed using the\n   {@link ng.$rootScope.Scope#$eval $eval()} method.\n2. Any exceptions from the execution of the expression are forwarded to the\n   {@link ng.$exceptionHandler $exceptionHandler} service.\n3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression\n   was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.",
            "params": [
                {
                    "name": "exp",
                    "description": "An angular expression to be executed.\n\n   - `string`: execute using the rules as defined in {@link guide/expression expression}.\n   - `function(scope)`: execute the function with current `scope` parameter.",
                    "type": "(string|function())="
                }
            ],
            "return": {
                "description": "The result of evaluating the expression.",
                "type": "*"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8087,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for discussion of\nevent life cycle.\n\nThe event listener function format is: `function(event, args...)`. The `event` object\npassed into the listener has the following attributes:\n\n  - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or `$broadcast`-ed.\n  - `currentScope` - `{Scope}`: the current scope which is handling the event.\n  - `name` - `{string}`: Name of the event.\n  - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel further event\n    propagation (available only for events that were `$emit`-ed).\n  - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag to true.\n  - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.",
            "params": [
                {
                    "name": "name",
                    "description": "Event name to listen on.",
                    "type": "String"
                },
                {
                    "name": "listener",
                    "description": "Function to call when the event is emitted.",
                    "type": "function(event, args...)"
                }
            ],
            "return": {
                "description": "Returns a deregistration function for this listener.",
                "type": "Function()"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8125,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Dispatches an event `name` upwards through the scope hierarchy notifying the\nregistered {@link ng.$rootScope.Scope#$on} listeners.\n\nThe event life cycle starts at the scope on which `$emit` was called. All\n{@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.\nAfterwards, the event traverses upwards toward the root scope and calls all registered\nlisteners along the way. The event will stop propagating if one of the listeners cancels it.\n\nAny exception emmited from the {@link ng.$rootScope.Scope#$on listeners} will be passed\nonto the {@link ng.$exceptionHandler $exceptionHandler} service.",
            "params": [
                {
                    "name": "name",
                    "description": "Event name to emit.",
                    "type": "String"
                },
                {
                    "name": "args",
                    "description": "Optional set of arguments which will be passed onto the event listeners.",
                    "type": "...*"
                }
            ],
            "return": {
                "description": "Event object, see {@link ng.$rootScope.Scope#$on}",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8191,
            "ngdoc": "function",
            "name": "",
            "methodof": "ng.$rootScope.Scope",
            "itemtype": "method",
            "description": "Dispatches an event `name` downwards to all child scopes (and their children) notifying the\nregistered {@link ng.$rootScope.Scope#$on} listeners.\n\nThe event life cycle starts at the scope on which `$broadcast` was called. All\n{@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.\nAfterwards, the event propagates to all direct and indirect scopes of the current scope and\ncalls all registered listeners along the way. The event cannot be canceled.\n\nAny exception emmited from the {@link ng.$rootScope.Scope#$on listeners} will be passed\nonto the {@link ng.$exceptionHandler $exceptionHandler} service.",
            "params": [
                {
                    "name": "name",
                    "description": "Event name to emit.",
                    "type": "String"
                },
                {
                    "name": "args",
                    "description": "Optional set of arguments which will be passed onto the event listeners.",
                    "type": "...*"
                }
            ],
            "return": {
                "description": "Event object, see {@link ng.$rootScope.Scope#$on}",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8286,
            "description": "function used as an initial value for watchers.\nbecause it's unique we can easily tell it apart from other values",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8294,
            "description": "This is very simple implementation of testing browser's features.",
            "name": "{boolean} hashchange Does the browser support hashchange event ?",
            "requires": [
                "$window"
            ],
            "itemtype": "property",
            "type": "Boolean",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8339,
            "ngdoc": "object",
            "name": "ng.$window",
            "description": "A reference to the browser's `window` object. While `window`\nis globally available in JavaScript, it causes testability problems, because\nit is a global variable. In angular we always refer to it through the\n`$window` service, so it may be overriden, removed or mocked for testing.\n\nAll expressions are evaluated with respect to current scope so they don't\nsuffer from window globality.",
            "example": [
                "\n  <doc:example>\n    <doc:source>\n      <input ng-init=\"$window = $service('$window'); greeting='Hello World!'\" type=\"text\" ng-model=\"greeting\" />\n      <button ng-click=\"$window.alert(greeting)\">ALERT</button>\n    </doc:source>\n    <doc:scenario>\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8366,
            "description": "Parse headers into key value object",
            "params": [
                {
                    "name": "headers",
                    "description": "Raw headers as a string",
                    "type": "String"
                }
            ],
            "return": {
                "description": "Parsed headers as key value object",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8395,
            "description": "Returns a function that provides access to parsed headers.\n\nHeaders are lazy parsed when first requested.",
            "see": [
                "parseHeaders"
            ],
            "params": [
                {
                    "name": "headers",
                    "description": "Headers to provide access to.",
                    "type": "(string|Object)"
                }
            ],
            "return": {
                "description": "Returns a getter function which if called with:\n\n  - if called with single an argument returns a single header value or null\n  - if called with no arguments returns an object containing all headers.",
                "type": "Function(string=)"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8422,
            "description": "Chain all given functions\n\nThis function is used for both request and response transforming",
            "params": [
                {
                    "name": "data",
                    "description": "Data to transform.",
                    "type": "*"
                },
                {
                    "name": "headers",
                    "description": "Http headers getter fn.",
                    "type": "Function(string=)"
                },
                {
                    "name": "fns",
                    "description": "Function or an array of functions.",
                    "type": "(function|Array.<function>)"
                }
            ],
            "return": {
                "description": "Transformed data.",
                "type": "*"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8499,
            "ngdoc": "function",
            "name": "pendingRequests Array of config objects for currently pending!~YUIDOC_LINE~!  requests. This is primarily meant to be used for debugging purposes.",
            "requires": [
                "$httpBackend",
                "$browser",
                "$cacheFactory",
                "$rootScope",
                "$q",
                "$injector"
            ],
            "description": "The `$http` service is a core Angular service that facilitates communication with the remote\nHTTP servers via browser's {@link https://developer.mozilla.org/en/xmlhttprequest\nXMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.\n\nFor unit testing applications that use `$http` service, see\n{@link ngMock.$httpBackend $httpBackend mock}.\n\nFor a higher level of abstraction, please check out the {@link ngResource.$resource\n$resource} service.\n\nThe $http API is based on the {@link ng.$q deferred/promise APIs} exposed by\nthe $q service. While for simple usage patters this doesn't matter much, for advanced usage,\nit is important to familiarize yourself with these apis and guarantees they provide.\n\n\n# General usage\nThe `$http` service is a function which takes a single argument — a configuration object —\nthat is used to generate an http request and returns  a {@link ng.$q promise}\nwith two $http specific methods: `success` and `error`.\n\n<pre>\n  $http({method: 'GET', url: '/someUrl'}).\n    success(function(data, status, headers, config) {\n      // this callback will be called asynchronously\n      // when the response is available\n    }).\n    error(function(data, status, headers, config) {\n      // called asynchronously if an error occurs\n      // or server returns response with an error status.\n    });\n</pre>\n\nSince the returned value of calling the $http function is a Promise object, you can also use\nthe `then` method to register callbacks, and these callbacks will receive a single argument –\nan object representing the response. See the api signature and type info below for more\ndetails.\n\nA response status code that falls in the [200, 300) range is considered a success status and\nwill result in the success callback being called. Note that if the response is a redirect,\nXMLHttpRequest will transparently follow it, meaning that the error callback will not be\ncalled for such responses.\n\n# Shortcut methods\n\nSince all invocation of the $http service require definition of the http method and url and\nPOST and PUT requests require response body/data to be provided as well, shortcut methods\nwere created to simplify using the api:\n\n<pre>\n  $http.get('/someUrl').success(successCallback);\n  $http.post('/someUrl', data).success(successCallback);\n</pre>\n\nComplete list of shortcut methods:\n\n- {@link ng.$http#get $http.get}\n- {@link ng.$http#head $http.head}\n- {@link ng.$http#post $http.post}\n- {@link ng.$http#put $http.put}\n- {@link ng.$http#delete $http.delete}\n- {@link ng.$http#jsonp $http.jsonp}\n\n\n# Setting HTTP Headers\n\nThe $http service will automatically add certain http headers to all requests. These defaults\ncan be fully configured by accessing the `$httpProvider.defaults.headers` configuration\nobject, which currently contains this default configuration:\n\n- `$httpProvider.defaults.headers.common` (headers that are common for all requests):\n  - `Accept: application/json, text/plain, * / *`\n  - `X-Requested-With: XMLHttpRequest`\n- `$httpProvider.defaults.headers.post`: (header defaults for HTTP POST requests)\n  - `Content-Type: application/json`\n- `$httpProvider.defaults.headers.put` (header defaults for HTTP PUT requests)\n  - `Content-Type: application/json`\n\nTo add or overwrite these defaults, simply add or remove a property from this configuration\nobjects. To add headers for an HTTP method other than POST or PUT, simply add a new object\nwith name equal to the lower-cased http method name, e.g.\n`$httpProvider.defaults.headers.get['My-Header']='value'`.\n\nAdditionally, the defaults can be set at runtime via the `$http.defaults` object in a similar\nfassion as described above.\n\n\n# Transforming Requests and Responses\n\nBoth requests and responses can be transformed using transform functions. By default, Angular\napplies these transformations:\n\nRequest transformations:\n\n- if the `data` property of the request config object contains an object, serialize it into\n  JSON format.\n\nResponse transformations:\n\n - if XSRF prefix is detected, strip it (see Security Considerations section below)\n - if json response is detected, deserialize it using a JSON parser\n\nTo override these transformation locally, specify transform functions as `transformRequest`\nand/or `transformResponse` properties of the config object. To globally override the default\ntransforms, override the `$httpProvider.defaults.transformRequest` and\n`$httpProvider.defaults.transformResponse` properties of the `$httpProvider`.\n\n\n# Caching\n\nTo enable caching set the configuration property `cache` to `true`. When the cache is\nenabled, `$http` stores the response from the server in local cache. Next time the\nresponse is served from the cache without sending a request to the server.\n\nNote that even if the response is served from cache, delivery of the data is asynchronous in\nthe same way that real requests are.\n\nIf there are multiple GET requests for the same url that should be cached using the same\ncache, but the cache is not populated yet, only one request to the server will be made and\nthe remaining requests will be fulfilled using the response for the first request.\n\n\n# Response interceptors\n\nBefore you start creating interceptors, be sure to understand the\n{@link ng.$q $q and deferred/promise APIs}.\n\nFor purposes of global error handling, authentication or any kind of synchronous or\nasynchronous preprocessing of received responses, it is desirable to be able to intercept\nresponses for http requests before they are handed over to the application code that\ninitiated these requests. The response interceptors leverage the {@link ng.$q\npromise apis} to fulfil this need for both synchronous and asynchronous preprocessing.\n\nThe interceptors are service factories that are registered with the $httpProvider by\nadding them to the `$httpProvider.responseInterceptors` array. The factory is called and\ninjected with dependencies (if specified) and returns the interceptor  — a function that\ntakes a {@link ng.$q promise} and returns the original or a new promise.\n\n<pre>\n  // register the interceptor as a service\n  $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {\n    return function(promise) {\n      return promise.then(function(response) {\n        // do something on success\n      }, function(response) {\n        // do something on error\n        if (canRecover(response)) {\n          return responseOrNewPromise\n        }\n        return $q.reject(response);\n      });\n    }\n  });\n\n  $httpProvider.responseInterceptors.push('myHttpInterceptor');\n\n\n  // register the interceptor via an anonymous factory\n  $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {\n    return function(promise) {\n      // same as above\n    }\n  });\n</pre>\n\n\n# Security Considerations\n\nWhen designing web applications, consider security threats from:\n\n- {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\n  JSON Vulnerability}\n- {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}\n\nBoth server and the client must cooperate in order to eliminate these threats. Angular comes\npre-configured with strategies that address these issues, but for this to work backend server\ncooperation is required.\n\n## JSON Vulnerability Protection\n\nA {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\nJSON Vulnerability} allows third party web-site to turn your JSON resource URL into\n{@link http://en.wikipedia.org/wiki/JSON#JSONP JSONP} request under some conditions. To\ncounter this your server can prefix all JSON requests with following string `\")]}',\\n\"`.\nAngular will automatically strip the prefix before processing it as JSON.\n\nFor example if your server needs to return:\n<pre>\n['one','two']\n</pre>\n\nwhich is vulnerable to attack, your server can return:\n<pre>\n)]}',\n['one','two']\n</pre>\n\nAngular will strip the prefix, before processing the JSON.\n\n\n## Cross Site Request Forgery (XSRF) Protection\n\n{@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which\nan unauthorized site can gain your user's private data. Angular provides following mechanism\nto counter XSRF. When performing XHR requests, the $http service reads a token from a cookie\ncalled `XSRF-TOKEN` and sets it as the HTTP header `X-XSRF-TOKEN`. Since only JavaScript that\nruns on your domain could read the cookie, your server can be assured that the XHR came from\nJavaScript running on your domain.\n\nTo take advantage of this, your server needs to set a token in a JavaScript readable session\ncookie called `XSRF-TOKEN` on first HTTP GET request. On subsequent non-GET requests the\nserver can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure\nthat only JavaScript running on your domain could have read the token. The token must be\nunique for each user and must be verifiable by the server (to prevent the JavaScript making\nup its own tokens). We recommend that the token is a digest of your site's authentication\ncookie with {@link http://en.wikipedia.org/wiki/Rainbow_table salt for added security}.",
            "return": {
                "description": "Returns a {@link ng.$q promise} object with the\n  standard `then` method and two http specific methods: `success` and `error`. The `then`\n  method takes two arguments a success and an error callback which will be called with a\n  response object. The `success` and `error` methods take a single argument - a function that\n  will be called when the request succeeds or fails respectively. The arguments passed into\n  these functions are destructured representation of the response object passed into the\n  `then` method. The response object has these properties:\n\n  - **data** – `{string|Object}` – The response body transformed with the transform functions.\n  - **status** – `{number}` – HTTP status code of the response.\n  - **headers** – `{function([headerName])}` – Header getter function.\n  - **config** – `{Object}` – The configuration object that was used to generate the request.",
                "type": "HttpPromise"
            },
            "itemtype": "property",
            "type": "Array.<Object>",
            "example": [
                "\n     <example>\n       <file name=\"index.html\">\n         <div ng-controller=\"FetchCtrl\">\n           <select ng-model=\"method\">\n             <option>GET</option>\n             <option>JSONP</option>\n           </select>\n           <input type=\"text\" ng-model=\"url\" size=\"80\"/>\n           <button ng-click=\"fetch()\">fetch</button><br>\n           <button ng-click=\"updateModel('GET', 'http-hello.html')\">Sample GET</button>\n           <button ng-click=\"updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')\">Sample JSONP</button>\n           <button ng-click=\"updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')\">Invalid JSONP</button>\n           <pre>http status code: {{status}}</pre>\n           <pre>http response data: {{data}}</pre>\n         </div>\n       </file>\n       <file name=\"script.js\">\n         function FetchCtrl($scope, $http, $templateCache) {\n           $scope.method = 'GET';\n           $scope.url = 'http-hello.html';\n\n           $scope.fetch = function() {\n             $scope.code = null;\n             $scope.response = null;\n\n             $http({method: $scope.method, url: $scope.url, cache: $templateCache}).\n               success(function(data, status) {\n                 $scope.status = status;\n                 $scope.data = data;\n               }).\n               error(function(data, status) {\n                 $scope.data = data || \"Request failed\";\n                 $scope.status = status;\n             });\n           };\n\n           $scope.updateModel = function(method, url) {\n             $scope.method = method;\n             $scope.url = url;\n           };\n         }\n       </file>\n       <file name=\"http-hello.html\">\n         Hello, $http!\n       </file>\n       <file name=\"scenario.js\">\n         it('should make an xhr GET request', function() {\n           element(':button:contains(\"Sample GET\")').click();\n           element(':button:contains(\"fetch\")').click();\n           expect(binding('status')).toBe('200');\n           expect(binding('data')).toMatch(/Hello, \\$http!/);\n         });\n\n         it('should make a JSONP request to angularjs.org', function() {\n           element(':button:contains(\"Sample JSONP\")').click();\n           element(':button:contains(\"fetch\")').click();\n           expect(binding('status')).toBe('200');\n           expect(binding('data')).toMatch(/Super Hero!/);\n         });\n\n         it('should make JSONP request to invalid URL and invoke the error handler',\n             function() {\n           element(':button:contains(\"Invalid JSONP\")').click();\n           element(':button:contains(\"fetch\")').click();\n           expect(binding('status')).toBe('0');\n           expect(binding('data')).toBe('Request failed');\n         });\n       </file>\n     </example>"
            ],
            "class": "",
            "subprops": [
                {
                    "name": "config",
                    "description": "Object describing the request to be made and how it should be\n   processed. The object has following properties:\n\n   - **method** – `{string}` – HTTP method (e.g. 'GET', 'POST', etc)\n   - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.\n   - **params** – `{Object.<string|Object>}` – Map of strings or objects which will be turned to\n     `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified.\n   - **data** – `{string|Object}` – Data to be sent as the request message data.\n   - **headers** – `{Object}` – Map of strings representing HTTP headers to send to the server.\n   - **transformRequest** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n     transform function or an array of such functions. The transform function takes the http\n     request body and headers and returns its transformed (typically serialized) version.\n   - **transformResponse** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n     transform function or an array of such functions. The transform function takes the http\n     response body and headers and returns its transformed (typically deserialized) version.\n   - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n     GET request, otherwise if a cache instance built with\n     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n     caching.\n   - **timeout** – `{number}` – timeout in milliseconds.\n   - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the\n     XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5\n     requests with credentials} for more information.",
                    "type": "Object"
                }
            ]
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8896,
            "ngdoc": "method",
            "name": "ng.$http#get",
            "methodof": "ng.$http",
            "description": "Shortcut method to perform `GET` request",
            "params": [
                {
                    "name": "url",
                    "description": "Relative or absolute URL specifying the destination of the request",
                    "type": "String"
                },
                {
                    "name": "config",
                    "description": "Optional configuration object",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Future object",
                "type": "HttpPromise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8909,
            "ngdoc": "method",
            "name": "ng.$http#delete",
            "methodof": "ng.$http",
            "description": "Shortcut method to perform `DELETE` request",
            "params": [
                {
                    "name": "url",
                    "description": "Relative or absolute URL specifying the destination of the request",
                    "type": "String"
                },
                {
                    "name": "config",
                    "description": "Optional configuration object",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Future object",
                "type": "HttpPromise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8922,
            "ngdoc": "method",
            "name": "ng.$http#head",
            "methodof": "ng.$http",
            "description": "Shortcut method to perform `HEAD` request",
            "params": [
                {
                    "name": "url",
                    "description": "Relative or absolute URL specifying the destination of the request",
                    "type": "String"
                },
                {
                    "name": "config",
                    "description": "Optional configuration object",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Future object",
                "type": "HttpPromise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8935,
            "ngdoc": "method",
            "name": "ng.$http#jsonp",
            "methodof": "ng.$http",
            "description": "Shortcut method to perform `JSONP` request",
            "params": [
                {
                    "name": "url",
                    "description": "Relative or absolute URL specifying the destination of the request.\n                    Should contain `JSON_CALLBACK` string.",
                    "type": "String"
                },
                {
                    "name": "config",
                    "description": "Optional configuration object",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Future object",
                "type": "HttpPromise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8950,
            "ngdoc": "method",
            "name": "ng.$http#post",
            "methodof": "ng.$http",
            "description": "Shortcut method to perform `POST` request",
            "params": [
                {
                    "name": "url",
                    "description": "Relative or absolute URL specifying the destination of the request",
                    "type": "String"
                },
                {
                    "name": "data",
                    "description": "Request content",
                    "type": "*"
                },
                {
                    "name": "config",
                    "description": "Optional configuration object",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Future object",
                "type": "HttpPromise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8964,
            "ngdoc": "method",
            "name": "ng.$http#put",
            "methodof": "ng.$http",
            "description": "Shortcut method to perform `PUT` request",
            "params": [
                {
                    "name": "url",
                    "description": "Relative or absolute URL specifying the destination of the request",
                    "type": "String"
                },
                {
                    "name": "data",
                    "description": "Request content",
                    "type": "*"
                },
                {
                    "name": "config",
                    "description": "Optional configuration object",
                    "type": "Object="
                }
            ],
            "return": {
                "description": "Future object",
                "type": "HttpPromise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 8979,
            "ngdoc": "property",
            "name": "ng.$http#defaults",
            "propertyof": "ng.$http",
            "description": "Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of\ndefault headers as well as request and response transformations.\n\nSee \"Setting HTTP Headers\" and \"Transforming Requests and Responses\" sections above.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9021,
            "description": "Makes the request\n\n!!! ACCESSES CLOSURE VARS:\n$httpBackend, $config, $log, $rootScope, defaultCache, $http.pendingRequests",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9072,
            "description": "Callback registered to $httpBackend():\n - caches the response if desired\n - resolves the raw $http promise\n - calls $apply",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9093,
            "description": "Resolves the raw $http promise.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9140,
            "ngdoc": "object",
            "name": "ng.$httpBackend",
            "requires": [
                "$browser",
                "$window",
                "$document"
            ],
            "description": "HTTP backend used by the {@link ng.$http service} that delegates to\nXMLHttpRequest object or JSONP and deals with browser incompatibilities.\n\nYou should never need to use this service directly, instead use the higher-level abstractions:\n{@link ng.$http $http} or {@link ngResource.$resource $resource}.\n\nDuring testing this implementation is swapped with {@link ngMock.$httpBackend mock\n$httpBackend} which can be trained with responses.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9281,
            "ngdoc": "object",
            "name": "ng.$locale",
            "description": "$locale service provides localization rules for various Angular components. As of right now the\nonly public api is:\n\n* `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9358,
            "ngdoc": "function",
            "name": "ng.$timeout",
            "requires": [
                "$browser"
            ],
            "description": "Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch\nblock and delegates any exceptions to\n{@link ng.$exceptionHandler $exceptionHandler} service.\n\nThe return value of registering a timeout function is a promise which will be resolved when\nthe timeout is reached and the timeout function is executed.\n\nTo cancel a the timeout request, call `$timeout.cancel(promise)`.\n\nIn tests you can use {@link ngMock.$timeout `$timeout.flush()`} to\nsynchronously flush the queue of deferred functions.",
            "params": [
                {
                    "name": "fn",
                    "description": "A function, who's execution should be delayed.",
                    "type": "Function()"
                },
                {
                    "name": "delay",
                    "description": "Delay in milliseconds.",
                    "type": "Number=",
                    "optional": true,
                    "optdefault": "0"
                },
                {
                    "name": "invokeApply",
                    "description": "If set to false skips model dirty checking, otherwise\n  will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.",
                    "type": "Boolean=",
                    "optional": true,
                    "optdefault": "true"
                }
            ],
            "return": {
                "description": "Promise that will be resolved when the timeout is reached. The value this\n  promise will be resolved with is the return value of the `fn` function.",
                "type": "Promise"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9412,
            "ngdoc": "function",
            "name": "ng.$timeout#cancel",
            "methodof": "ng.$timeout",
            "description": "Cancels a task associated with the `promise`. As a result of this the promise will be\nresolved with a rejection.",
            "params": [
                {
                    "name": "promise",
                    "description": "Promise returned by the `$timeout` function.",
                    "type": "Promise="
                }
            ],
            "return": {
                "description": "Returns `true` if the task hasn't executed yet and was successfully\n  canceled.",
                "type": "Boolean"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9437,
            "ngdoc": "object",
            "name": "ng.$filterProvider",
            "description": "Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To\nachieve this a filter definition consists of a factory function which is annotated with dependencies and is\nresponsible for creating a the filter function.\n\n<pre>\n  // Filter registration\n  function MyModule($provide, $filterProvider) {\n    // create a service to demonstrate injection (not always needed)\n    $provide.value('greet', function(name){\n      return 'Hello ' + name + '!';\n    });\n\n    // register a filter factory which uses the\n    // greet service to demonstrate DI.\n    $filterProvider.register('greet', function(greet){\n      // return the filter function which uses the greet service\n      // to generate salutation\n      return function(text) {\n        // filters need to be forgiving so check input validity\n        return text && greet(text) || text;\n      };\n    });\n  }\n</pre>\n\nThe filter function is registered with the `$injector` under the filter name suffixe with `Filter`.\n<pre>\n  it('should be the same instance', inject(\n    function($filterProvider) {\n      $filterProvider.register('reverse', function(){\n        return ...;\n      });\n    },\n    function($filter, reverseFilter) {\n      expect($filter('reverse')).toBe(reverseFilter);\n    });\n</pre>\n\n\nFor more information about how angular filters work, and how to create your own filters, see\n{@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer\nGuide.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9485,
            "ngdoc": "method",
            "name": "ng.$filterProvider#register",
            "methodof": "ng.$filterProvider",
            "description": "Register filter factory function.",
            "params": [
                {
                    "name": "name",
                    "description": "Name of the filter.",
                    "type": "String"
                },
                {
                    "name": "fn",
                    "description": "The filter factory function which is injectable.",
                    "type": "Function"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9497,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Filters are used for formatting data displayed to the user.\n\nThe general syntax in templates is as follows:\n\n        {{ expression | [ filter_name ] }}",
            "params": [
                {
                    "name": "name",
                    "description": "Name of the filter function to retrieve",
                    "type": "String"
                }
            ],
            "return": {
                "description": "the filter function",
                "type": "Function"
            },
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9539,
            "ngdoc": "filter",
            "name": "",
            "itemtype": "method",
            "description": "Selects a subset of items from `array` and returns it as a new array.\n\nNote: This function is used to augment the `Array` type in Angular expressions. See\n{@link ng.$filter} for more information about Angular arrays.",
            "params": [
                {
                    "name": "array",
                    "description": "The source array.",
                    "type": "Array"
                },
                {
                    "name": "expression",
                    "description": "The predicate to be used for selecting items from\n  `array`.\n\n  Can be one of:\n\n  - `string`: Predicate that results in a substring match using the value of `expression`\n    string. All strings or objects with string properties in `array` that contain this string\n    will be returned. The predicate can be negated by prefixing the string with `!`.\n\n  - `Object`: A pattern object can be used to filter specific properties on objects contained\n    by `array`. For example `{name:\"M\", phone:\"1\"}` predicate will return an array of items\n    which have property `name` containing \"M\" and property `phone` containing \"1\". A special\n    property name `$` can be used (as in `{$:\"text\"}`) to accept a match against any\n    property of the object. That's equivalent to the simple substring match with a `string`\n    as described above.\n\n  - `function`: A predicate function can be used to write arbitrary filters. The function is\n    called for each element of `array`. The final result is an array of those elements that\n    the predicate returned true for.",
                    "type": "String|Object|function()"
                }
            ],
            "example": [
                "\n  <doc:example>\n    <doc:source>\n      <div ng-init=\"friends = [{name:'John', phone:'555-1276'},\n                               {name:'Mary', phone:'800-BIG-MARY'},\n                               {name:'Mike', phone:'555-4321'},\n                               {name:'Adam', phone:'555-5678'},\n                               {name:'Julie', phone:'555-8765'}]\"></div>\n\n      Search: <input ng-model=\"searchText\">\n      <table id=\"searchTextResults\">\n        <tr><th>Name</th><th>Phone</th><tr>\n        <tr ng-repeat=\"friend in friends | filter:searchText\">\n          <td>{{friend.name}}</td>\n          <td>{{friend.phone}}</td>\n        <tr>\n      </table>\n      <hr>\n      Any: <input ng-model=\"search.$\"> <br>\n      Name only <input ng-model=\"search.name\"><br>\n      Phone only <input ng-model=\"search.phone\"å><br>\n      <table id=\"searchObjResults\">\n        <tr><th>Name</th><th>Phone</th><tr>\n        <tr ng-repeat=\"friend in friends | filter:search\">\n          <td>{{friend.name}}</td>\n          <td>{{friend.phone}}</td>\n        <tr>\n      </table>\n    </doc:source>\n    <doc:scenario>\n      it('should search across all fields when filtering with a string', function() {\n        input('searchText').enter('m');\n        expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).\n          toEqual(['Mary', 'Mike', 'Adam']);\n\n        input('searchText').enter('76');\n        expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).\n          toEqual(['John', 'Julie']);\n      });\n\n      it('should search in specific fields when filtering with a predicate object', function() {\n        input('search.$').enter('i');\n        expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).\n          toEqual(['Mary', 'Mike', 'Julie']);\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9702,
            "ngdoc": "filter",
            "name": "",
            "itemtype": "method",
            "description": "Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default\nsymbol for current locale is used.",
            "params": [
                {
                    "name": "amount",
                    "description": "Input to filter.",
                    "type": "Number"
                },
                {
                    "name": "symbol",
                    "description": "Currency symbol or identifier to be displayed.",
                    "type": "String="
                }
            ],
            "return": {
                "description": "Formatted number.",
                "type": "String"
            },
            "example": [
                "\n  <doc:example>\n    <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.amount = 1234.56;\n        }\n      </script>\n      <div ng-controller=\"Ctrl\">\n        <input type=\"number\" ng-model=\"amount\"> <br>\n        default currency symbol ($): {{amount | currency}}<br>\n        custom currency identifier (USD$): {{amount | currency:\"USD$\"}}\n      </div>\n    </doc:source>\n    <doc:scenario>\n      it('should init with 1234.56', function() {\n        expect(binding('amount | currency')).toBe('$1,234.56');\n        expect(binding('amount | currency:\"USD$\"')).toBe('USD$1,234.56');\n      });\n      it('should update', function() {\n        input('amount').enter('-1234');\n        expect(binding('amount | currency')).toBe('($1,234.00)');\n        expect(binding('amount | currency:\"USD$\"')).toBe('(USD$1,234.00)');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9753,
            "ngdoc": "filter",
            "name": "",
            "itemtype": "method",
            "description": "Formats a number as text.\n\nIf the input is not a number an empty string is returned.",
            "params": [
                {
                    "name": "number",
                    "description": "Number to format.",
                    "type": "Number|string"
                },
                {
                    "name": "fractionSize",
                    "description": "Number of decimal places to round the number to.",
                    "type": "(number|string)=",
                    "optional": true,
                    "optdefault": "2"
                }
            ],
            "return": {
                "description": "Number rounded to decimalPlaces and places a “,” after each third digit.",
                "type": "String"
            },
            "example": [
                "\n  <doc:example>\n    <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.val = 1234.56789;\n        }\n      </script>\n      <div ng-controller=\"Ctrl\">\n        Enter number: <input ng-model='val'><br>\n        Default formatting: {{val | number}}<br>\n        No fractions: {{val | number:0}}<br>\n        Negative number: {{-val | number:4}}\n      </div>\n    </doc:source>\n    <doc:scenario>\n      it('should format numbers', function() {\n        expect(binding('val | number')).toBe('1,234.568');\n        expect(binding('val | number:0')).toBe('1,235');\n        expect(binding('-val | number:4')).toBe('-1,234.5679');\n      });\n\n      it('should update', function() {\n        input('val').enter('3374.333');\n        expect(binding('val | number')).toBe('3,374.333');\n        expect(binding('val | number:0')).toBe('3,374');\n        expect(binding('-val | number:4')).toBe('-3,374.3330');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 9952,
            "ngdoc": "filter",
            "name": "",
            "itemtype": "method",
            "description": "Formats `date` to a string based on the requested `format`.\n\n  `format` string can be composed of the following elements:\n\n  * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)\n  * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)\n  * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)\n  * `'MMMM'`: Month in year (January-December)\n  * `'MMM'`: Month in year (Jan-Dec)\n  * `'MM'`: Month in year, padded (01-12)\n  * `'M'`: Month in year (1-12)\n  * `'dd'`: Day in month, padded (01-31)\n  * `'d'`: Day in month (1-31)\n  * `'EEEE'`: Day in Week,(Sunday-Saturday)\n  * `'EEE'`: Day in Week, (Sun-Sat)\n  * `'HH'`: Hour in day, padded (00-23)\n  * `'H'`: Hour in day (0-23)\n  * `'hh'`: Hour in am/pm, padded (01-12)\n  * `'h'`: Hour in am/pm, (1-12)\n  * `'mm'`: Minute in hour, padded (00-59)\n  * `'m'`: Minute in hour (0-59)\n  * `'ss'`: Second in minute, padded (00-59)\n  * `'s'`: Second in minute (0-59)\n  * `'a'`: am/pm marker\n  * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-1200)\n\n  `format` string can also be one of the following predefined\n  {@link guide/i18n localizable formats}:\n\n  * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale\n    (e.g. Sep 3, 2010 12:05:08 pm)\n  * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)\n  * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale\n    (e.g. Friday, September 3, 2010)\n  * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010\n  * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)\n  * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)\n  * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)\n  * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)\n\n  `format` string can contain literal values. These need to be quoted with single quotes (e.g.\n  `\"h 'in the morning'\"`). In order to output single quote, use two single quotes in a sequence\n  (e.g. `\"h o''clock\"`).",
            "params": [
                {
                    "name": "date",
                    "description": "Date to format either as Date object, milliseconds (string or\n   number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and it's\n   shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is\n   specified in the string input, the time is considered to be in the local timezone.",
                    "type": "(Date|number|string)"
                },
                {
                    "name": "format",
                    "description": "Formatting rules (see Description). If not specified,\n   `mediumDate` is used.",
                    "type": "String="
                }
            ],
            "return": {
                "description": "Formatted string or the input if input is not recognized as date/millis.",
                "type": "String"
            },
            "example": [
                "\n  <doc:example>\n    <doc:source>\n      <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:\n          {{1288323623006 | date:'medium'}}<br>\n      <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:\n         {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>\n      <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:\n         {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>\n    </doc:source>\n    <doc:scenario>\n      it('should format date', function() {\n        expect(binding(\"1288323623006 | date:'medium'\")).\n           toMatch(/Oct 2\\d, 2010 \\d{1,2}:\\d{2}:\\d{2} (AM|PM)/);\n        expect(binding(\"1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'\")).\n           toMatch(/2010\\-10\\-2\\d \\d{2}:\\d{2}:\\d{2} (\\-|\\+)?\\d{4}/);\n        expect(binding(\"'1288323623006' | date:'MM/dd/yyyy @ h:mma'\")).\n           toMatch(/10\\/2\\d\\/2010 @ \\d{1,2}:\\d{2}(AM|PM)/);\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10100,
            "ngdoc": "filter",
            "name": "",
            "itemtype": "method",
            "description": "Allows you to convert a JavaScript object into JSON string.\n\n  This filter is mostly useful for debugging. When using the double curly {{value}} notation\n  the binding is automatically converted to JSON.",
            "params": [
                {
                    "name": "object",
                    "description": "Any JavaScript object (including arrays and primitive types) to filter.",
                    "type": "*"
                }
            ],
            "return": {
                "description": "JSON string.",
                "type": "String"
            },
            "example": [
                ":\n  <doc:example>\n    <doc:source>\n      <pre>{{ {'name':'value'} | json }}</pre>\n    </doc:source>\n    <doc:scenario>\n      it('should jsonify filtered objects', function() {\n        expect(binding(\"{'name':'value'}\")).toMatch(/\\{\\n  \"name\": ?\"value\"\\n}/);\n      });\n    </doc:scenario>\n  </doc:example>\n"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10135,
            "ngdoc": "filter",
            "name": "",
            "itemtype": "method",
            "description": "Converts string to lowercase.",
            "see": [
                "angular.lowercase"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10146,
            "ngdoc": "filter",
            "name": "",
            "itemtype": "method",
            "description": "Converts string to uppercase.",
            "see": [
                "angular.uppercase"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10156,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Creates a new array containing only a specified number of elements in an array. The elements\nare taken from either the beginning or the end of the source array, as specified by the\nvalue and sign (positive or negative) of `limit`.\n\nNote: This function is used to augment the `Array` type in Angular expressions. See\n{@link ng.$filter} for more information about Angular arrays.",
            "params": [
                {
                    "name": "array",
                    "description": "Source array to be limited.",
                    "type": "Array"
                },
                {
                    "name": "limit",
                    "description": "The length of the returned array. If the `limit` number is\n    positive, `limit` number of items from the beginning of the source array are copied.\n    If the number is negative, `limit` number  of items from the end of the source array are\n    copied. The `limit` will be trimmed if it exceeds `array.length`",
                    "type": "String|Number"
                }
            ],
            "return": {
                "description": "A new sub-array of length `limit` or less if input array had less than `limit`\n    elements.",
                "type": "Array"
            },
            "example": [
                "\n  <doc:example>\n    <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.numbers = [1,2,3,4,5,6,7,8,9];\n          $scope.limit = 3;\n        }\n      </script>\n      <div ng-controller=\"Ctrl\">\n        Limit {{numbers}} to: <input type=\"integer\" ng-model=\"limit\">\n        <p>Output: {{ numbers | limitTo:limit }}</p>\n      </div>\n    </doc:source>\n    <doc:scenario>\n      it('should limit the numer array to first three items', function() {\n        expect(element('.doc-example-live input[ng-model=limit]').val()).toBe('3');\n        expect(binding('numbers | limitTo:limit')).toEqual('[1,2,3]');\n      });\n\n      it('should update the output when -3 is entered', function() {\n        input('limit').enter(-3);\n        expect(binding('numbers | limitTo:limit')).toEqual('[7,8,9]');\n      });\n\n      it('should not exceed the maximum size of input array', function() {\n        input('limit').enter(100);\n        expect(binding('numbers | limitTo:limit')).toEqual('[1,2,3,4,5,6,7,8,9]');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10242,
            "ngdoc": "function",
            "name": "",
            "itemtype": "method",
            "description": "Orders a specified `array` by the `expression` predicate.\n\nNote: this function is used to augment the `Array` type in Angular expressions. See\n{@link ng.$filter} for more informaton about Angular arrays.",
            "params": [
                {
                    "name": "array",
                    "description": "The array to sort.",
                    "type": "Array"
                },
                {
                    "name": "expression",
                    "description": "A predicate to be\n   used by the comparator to determine the order of elements.\n\n   Can be one of:\n\n   - `function`: Getter function. The result of this function will be sorted using the\n     `<`, `=`, `>` operator.\n   - `string`: An Angular expression which evaluates to an object to order by, such as 'name'\n     to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control\n     ascending or descending sort order (for example, +name or -name).\n   - `Array`: An array of function or string predicates. The first predicate in the array\n     is used for sorting, but when two items are equivalent, the next predicate is used.",
                    "type": "function(*)|string|Array.<(function(*)|string)>"
                },
                {
                    "name": "reverse",
                    "description": "Reverse the order the array.",
                    "type": "Boolean="
                }
            ],
            "return": {
                "description": "Sorted copy of the source array.",
                "type": "Array"
            },
            "example": [
                "\n  <doc:example>\n    <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.friends =\n              [{name:'John', phone:'555-1212', age:10},\n               {name:'Mary', phone:'555-9876', age:19},\n               {name:'Mike', phone:'555-4321', age:21},\n               {name:'Adam', phone:'555-5678', age:35},\n               {name:'Julie', phone:'555-8765', age:29}]\n          $scope.predicate = '-age';\n        }\n      </script>\n      <div ng-controller=\"Ctrl\">\n        <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>\n        <hr/>\n        [ <a href=\"\" ng-click=\"predicate=''\">unsorted</a> ]\n        <table class=\"friend\">\n          <tr>\n            <th><a href=\"\" ng-click=\"predicate = 'name'; reverse=false\">Name</a>\n                (<a href ng-click=\"predicate = '-name'; reverse=false\">^</a>)</th>\n            <th><a href=\"\" ng-click=\"predicate = 'phone'; reverse=!reverse\">Phone Number</a></th>\n            <th><a href=\"\" ng-click=\"predicate = 'age'; reverse=!reverse\">Age</a></th>\n          <tr>\n          <tr ng-repeat=\"friend in friends | orderBy:predicate:reverse\">\n            <td>{{friend.name}}</td>\n            <td>{{friend.phone}}</td>\n            <td>{{friend.age}}</td>\n          <tr>\n        </table>\n      </div>\n    </doc:source>\n    <doc:scenario>\n      it('should be reverse ordered by aged', function() {\n        expect(binding('predicate')).toBe('-age');\n        expect(repeater('table.friend', 'friend in friends').column('friend.age')).\n          toEqual(['35', '29', '21', '19', '10']);\n        expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n          toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);\n      });\n\n      it('should reorder the table when user selects different predicate', function() {\n        element('.doc-example-live a:contains(\"Name\")').click();\n        expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n          toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);\n        expect(repeater('table.friend', 'friend in friends').column('friend.age')).\n          toEqual(['35', '10', '29', '19', '21']);\n\n        element('.doc-example-live a:contains(\"Phone\")').click();\n        expect(repeater('table.friend', 'friend in friends').column('friend.phone')).\n          toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);\n        expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n          toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10388,
            "ngdoc": "directive",
            "name": "ng.directive:a",
            "restrict": "E",
            "description": "Modifies the default behavior of html A tag, so that the default action is prevented when href\nattribute is empty.\n\nThe reasoning for this change is to allow easy creation of action links with `ngClick` directive\nwithout changing the location or causing page reloads, e.g.:\n`<a href=\"\" ng-click=\"model.$save()\">Save</a>`",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10431,
            "ngdoc": "directive",
            "name": "ng.directive:ngHref",
            "restrict": "A",
            "description": "Using Angular markup like {{hash}} in an href attribute makes\nthe page open to a wrong URL, if the user clicks that link before\nangular has a chance to replace the {{hash}} with actual URL, the\nlink will be broken and will most likely return a 404 error.\nThe `ngHref` directive solves this problem.\n\nThe buggy way to write it:\n<pre>\n<a href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n</pre>\n\nThe correct way to write it:\n<pre>\n<a ng-href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n</pre>",
            "element": "A",
            "params": [
                {
                    "name": "ngHref",
                    "description": "any string which can contain `{{}}` markup.",
                    "type": "Template"
                }
            ],
            "example": [
                "\nThis example uses `link` variable inside `href` attribute:\n   <doc:example>\n     <doc:source>\n       <input ng-model=\"value\" /><br />\n       <a id=\"link-1\" href ng-click=\"value = 1\">link 1</a> (link, don't reload)<br />\n       <a id=\"link-2\" href=\"\" ng-click=\"value = 2\">link 2</a> (link, don't reload)<br />\n       <a id=\"link-3\" ng-href=\"/{{'123'}}\">link 3</a> (link, reload!)<br />\n       <a id=\"link-4\" href=\"\" name=\"xx\" ng-click=\"value = 4\">anchor</a> (link, don't reload)<br />\n       <a id=\"link-5\" name=\"xxx\" ng-click=\"value = 5\">anchor</a> (no link)<br />\n       <a id=\"link-6\" ng-href=\"{{value}}\">link</a> (link, change location)\n     </doc:source>\n     <doc:scenario>\n       it('should execute ng-click but not reload when href without value', function() {\n         element('#link-1').click();\n         expect(input('value').val()).toEqual('1');\n         expect(element('#link-1').attr('href')).toBe(\"\");\n       });\n\n       it('should execute ng-click but not reload when href empty string', function() {\n         element('#link-2').click();\n         expect(input('value').val()).toEqual('2');\n         expect(element('#link-2').attr('href')).toBe(\"\");\n       });\n\n       it('should execute ng-click and change url when ng-href specified', function() {\n         expect(element('#link-3').attr('href')).toBe(\"/123\");\n\n         element('#link-3').click();\n         expect(browser().window().path()).toEqual('/123');\n       });\n\n       it('should execute ng-click but not reload when href empty string and name specified', function() {\n         element('#link-4').click();\n         expect(input('value').val()).toEqual('4');\n         expect(element('#link-4').attr('href')).toBe('');\n       });\n\n       it('should execute ng-click but not reload when no href but name specified', function() {\n         element('#link-5').click();\n         expect(input('value').val()).toEqual('5');\n         expect(element('#link-5').attr('href')).toBe(undefined);\n       });\n\n       it('should only change url when only ng-href', function() {\n         input('value').enter('6');\n         expect(element('#link-6').attr('href')).toBe('6');\n\n         element('#link-6').click();\n         expect(browser().location().url()).toEqual('/6');\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10511,
            "ngdoc": "directive",
            "name": "ng.directive:ngSrc",
            "restrict": "A",
            "description": "Using Angular markup like `{{hash}}` in a `src` attribute doesn't\nwork right: The browser will fetch from the URL with the literal\ntext `{{hash}}` until Angular replaces the expression inside\n`{{hash}}`. The `ngSrc` directive solves this problem.\n\nThe buggy way to write it:\n<pre>\n<img src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n</pre>\n\nThe correct way to write it:\n<pre>\n<img ng-src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n</pre>",
            "element": "IMG",
            "params": [
                {
                    "name": "ngSrc",
                    "description": "any string which can contain `{{}}` markup.",
                    "type": "Template"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10536,
            "ngdoc": "directive",
            "name": "ng.directive:ngDisabled",
            "restrict": "A",
            "description": "The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:\n<pre>\n<div ng-init=\"scope = { isDisabled: false }\">\n <button disabled=\"{{scope.isDisabled}}\">Disabled</button>\n</div>\n</pre>\n\nThe HTML specs do not require browsers to preserve the special attributes such as disabled.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduce the `ngDisabled` directive.",
            "example": [
                "\n   <doc:example>\n     <doc:source>\n       Click me to toggle: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n       <button ng-model=\"button\" ng-disabled=\"checked\">Button</button>\n     </doc:source>\n     <doc:scenario>\n       it('should toggle button', function() {\n         expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();\n         input('checked').check();\n         expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "element": "INPUT",
            "params": [
                {
                    "name": "ngDisabled",
                    "description": "Angular expression that will be evaluated.",
                    "type": "Expression"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10575,
            "ngdoc": "directive",
            "name": "ng.directive:ngChecked",
            "restrict": "A",
            "description": "The HTML specs do not require browsers to preserve the special attributes such as checked.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduce the `ngChecked` directive.",
            "example": [
                "\n   <doc:example>\n     <doc:source>\n       Check me to check both: <input type=\"checkbox\" ng-model=\"master\"><br/>\n       <input id=\"checkSlave\" type=\"checkbox\" ng-checked=\"master\">\n     </doc:source>\n     <doc:scenario>\n       it('should check both checkBoxes', function() {\n         expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();\n         input('master').check();\n         expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "element": "INPUT",
            "params": [
                {
                    "name": "ngChecked",
                    "description": "Angular expression that will be evaluated.",
                    "type": "Expression"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10605,
            "ngdoc": "directive",
            "name": "ng.directive:ngMultiple",
            "restrict": "A",
            "description": "The HTML specs do not require browsers to preserve the special attributes such as multiple.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduce the `ngMultiple` directive.",
            "example": [
                "\n    <doc:example>\n      <doc:source>\n        Check me check multiple: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n        <select id=\"select\" ng-multiple=\"checked\">\n          <option>Misko</option>\n          <option>Igor</option>\n          <option>Vojta</option>\n          <option>Di</option>\n        </select>\n      </doc:source>\n      <doc:scenario>\n        it('should toggle multiple', function() {\n          expect(element('.doc-example-live #select').prop('multiple')).toBeFalsy();\n          input('checked').check();\n          expect(element('.doc-example-live #select').prop('multiple')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>"
            ],
            "element": "SELECT",
            "params": [
                {
                    "name": "ngMultiple",
                    "description": "Angular expression that will be evaluated.",
                    "type": "Expression"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10641,
            "ngdoc": "directive",
            "name": "ng.directive:ngReadonly",
            "restrict": "A",
            "description": "The HTML specs do not require browsers to preserve the special attributes such as readonly.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduce the `ngReadonly` directive.",
            "example": [
                "\n   <doc:example>\n     <doc:source>\n       Check me to make text readonly: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n       <input type=\"text\" ng-readonly=\"checked\" value=\"I'm Angular\"/>\n     </doc:source>\n     <doc:scenario>\n       it('should toggle readonly attr', function() {\n         expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();\n         input('checked').check();\n         expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "element": "INPUT",
            "params": [
                {
                    "name": "expression",
                    "description": "Angular expression that will be evaluated.",
                    "type": "String"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10671,
            "ngdoc": "directive",
            "name": "ng.directive:ngSelected",
            "restrict": "A",
            "description": "The HTML specs do not require browsers to preserve the special attributes such as selected.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduced the `ngSelected` directive.",
            "example": [
                "\n   <doc:example>\n     <doc:source>\n       Check me to select: <input type=\"checkbox\" ng-model=\"selected\"><br/>\n       <select>\n         <option>Hello!</option>\n         <option id=\"greet\" ng-selected=\"selected\">Greetings!</option>\n       </select>\n     </doc:source>\n     <doc:scenario>\n       it('should select Greetings!', function() {\n         expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();\n         input('selected').check();\n         expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "element": "OPTION",
            "params": [
                {
                    "name": "expression",
                    "description": "Angular expression that will be evaluated.",
                    "type": "String"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10756,
            "ngdoc": "object",
            "name": "{Object} $error Is an object hash, containing references to all invalid controls or\n forms, where:\n\n - keys are validation tokens (error names) — such as `required`, `url` or `email`),\n - values are arrays of controls or forms that are invalid with given error.",
            "itemtype": "property",
            "type": "Boolean",
            "description": "`FormController` keeps track of all its controls and nested forms as well as state of them,\nsuch as being valid/invalid or dirty/pristine.\n\nEach {@link ng.directive:form form} directive creates an instance\nof `FormController`.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10871,
            "ngdoc": "directive",
            "name": "ng.directive:ngForm",
            "restrict": "EAC",
            "description": "Nestable alias of {@link ng.directive:form `form`} directive. HTML\ndoes not allow nesting of form elements. It is useful to nest forms, for example if the validity of a\nsub-group of controls needs to be determined.",
            "params": [
                {
                    "name": "name|ngForm",
                    "description": "Name of the form. If specified, the form controller will be published into\n                      related scope, under this name.",
                    "type": "String="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 10886,
            "ngdoc": "directive",
            "name": "ng.directive:form",
            "restrict": "E",
            "description": "Directive that instantiates\n{@link ng.directive:form.FormController FormController}.\n\nIf `name` attribute is specified, the form controller is published onto the current scope under\nthis name.\n\n# Alias: {@link ng.directive:ngForm `ngForm`}\n\nIn angular forms can be nested. This means that the outer form is valid when all of the child\nforms are valid as well. However browsers do not allow nesting of `<form>` elements, for this\nreason angular provides {@link ng.directive:ngForm `ngForm`} alias\nwhich behaves identical to `<form>` but allows form nesting.\n\n\n# CSS classes\n - `ng-valid` Is set if the form is valid.\n - `ng-invalid` Is set if the form is invalid.\n - `ng-pristine` Is set if the form is pristine.\n - `ng-dirty` Is set if the form is dirty.\n\n\n# Submitting a form and preventing default action\n\nSince the role of forms in client-side Angular applications is different than in classical\nroundtrip apps, it is desirable for the browser not to translate the form submission into a full\npage reload that sends the data to the server. Instead some javascript logic should be triggered\nto handle the form submission in application specific way.\n\nFor this reason, Angular prevents the default action (form submission to the server) unless the\n`<form>` element has an `action` attribute specified.\n\nYou can use one of the following two ways to specify what javascript method should be called when\na form is submitted:\n\n- {@link ng.directive:ngSubmit ngSubmit} directive on the form element\n- {@link ng.directive:ngClick ngClick} directive on the first\n button or input field of type submit (input[type=submit])\n\nTo prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This\nis because of the following form submission rules coming from the html spec:\n\n- If a form has only one input field then hitting enter in this field triggers form submit\n(`ngSubmit`)\n- if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter\ndoesn't trigger submit\n- if a form has one or more input fields and one or more buttons or input[type=submit] then\nhitting enter in any of the input fields will trigger the click handler on the *first* button or\ninput[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)",
            "params": [
                {
                    "name": "name",
                    "description": "Name of the form. If specified, the form controller will be published into\n                      related scope, under this name.",
                    "type": "String="
                }
            ],
            "example": [
                "\n   <doc:example>\n     <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.userType = 'guest';\n        }\n      </script>\n      <form name=\"myForm\" ng-controller=\"Ctrl\">\n        userType: <input name=\"input\" ng-model=\"userType\" required>\n        <span class=\"error\" ng-show=\"myForm.input.$error.required\">Required!</span><br>\n        <tt>userType = {{userType}}</tt><br>\n        <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>\n        <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>\n        <tt>myForm.$valid = {{myForm.$valid}}</tt><br>\n        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>\n       </form>\n     </doc:source>\n     <doc:scenario>\n       it('should initialize to model', function() {\n        expect(binding('userType')).toEqual('guest');\n        expect(binding('myForm.input.$valid')).toEqual('true');\n       });\n\n       it('should be invalid if empty', function() {\n        input('userType').enter('');\n        expect(binding('userType')).toEqual('');\n        expect(binding('myForm.input.$valid')).toEqual('false');\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11042,
            "ngdoc": "inputType",
            "name": "ng.directive:input.text",
            "description": "Standard HTML text input with angular data binding.",
            "params": [
                {
                    "name": "ngModel",
                    "description": "Assignable angular expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "name",
                    "description": "Property name of the form under which the control is published.",
                    "type": "String="
                },
                {
                    "name": "required",
                    "description": "Adds `required` validation error key if the value is not entered.",
                    "type": "String="
                },
                {
                    "name": "ngRequired",
                    "description": "Adds `required` attribute and `required` validation constraint to\n   the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   `required` when you want to data-bind to the `required` attribute.",
                    "type": "String="
                },
                {
                    "name": "ngMinlength",
                    "description": "Sets `minlength` validation error key if the value is shorter than\n   minlength.",
                    "type": "Number="
                },
                {
                    "name": "ngMaxlength",
                    "description": "Sets `maxlength` validation error key if the value is longer than\n   maxlength.",
                    "type": "Number="
                },
                {
                    "name": "ngPattern",
                    "description": "Sets `pattern` validation error key if the value does not match the\n   RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   patterns defined as scope expressions.",
                    "type": "String="
                },
                {
                    "name": "ngChange",
                    "description": "Angular expression to be executed when input changes due to user\n   interaction with the input element.",
                    "type": "String="
                }
            ],
            "example": [
                "\n     <doc:example>\n       <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.text = 'guest';\n            $scope.word = /^\\w*$/;\n          }\n        </script>\n        <form name=\"myForm\" ng-controller=\"Ctrl\">\n          Single word: <input type=\"text\" name=\"input\" ng-model=\"text\"\n                              ng-pattern=\"word\" required>\n          <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n            Required!</span>\n          <span class=\"error\" ng-show=\"myForm.input.$error.pattern\">\n            Single word only!</span>\n\n          <tt>text = {{text}}</tt><br/>\n          <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n          <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n          <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n          <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n         </form>\n       </doc:source>\n       <doc:scenario>\n         it('should initialize to model', function() {\n           expect(binding('text')).toEqual('guest');\n           expect(binding('myForm.input.$valid')).toEqual('true');\n         });\n\n         it('should be invalid if empty', function() {\n           input('text').enter('');\n           expect(binding('text')).toEqual('');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n         });\n\n         it('should be invalid if multi word', function() {\n           input('text').enter('hello world');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n         });\n       </doc:scenario>\n     </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11111,
            "ngdoc": "inputType",
            "name": "ng.directive:input.number",
            "description": "Text input with number validation and transformation. Sets the `number` validation\nerror if not a valid number.",
            "params": [
                {
                    "name": "ngModel",
                    "description": "Assignable angular expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "name",
                    "description": "Property name of the form under which the control is published.",
                    "type": "String="
                },
                {
                    "name": "min",
                    "description": "Sets the `min` validation error key if the value entered is less then `min`.",
                    "type": "String="
                },
                {
                    "name": "max",
                    "description": "Sets the `max` validation error key if the value entered is greater then `min`.",
                    "type": "String="
                },
                {
                    "name": "required",
                    "description": "Sets `required` validation error key if the value is not entered.",
                    "type": "String="
                },
                {
                    "name": "ngRequired",
                    "description": "Adds `required` attribute and `required` validation constraint to\n   the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   `required` when you want to data-bind to the `required` attribute.",
                    "type": "String="
                },
                {
                    "name": "ngMinlength",
                    "description": "Sets `minlength` validation error key if the value is shorter than\n   minlength.",
                    "type": "Number="
                },
                {
                    "name": "ngMaxlength",
                    "description": "Sets `maxlength` validation error key if the value is longer than\n   maxlength.",
                    "type": "Number="
                },
                {
                    "name": "ngPattern",
                    "description": "Sets `pattern` validation error key if the value does not match the\n   RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   patterns defined as scope expressions.",
                    "type": "String="
                },
                {
                    "name": "ngChange",
                    "description": "Angular expression to be executed when input changes due to user\n   interaction with the input element.",
                    "type": "String="
                }
            ],
            "example": [
                "\n     <doc:example>\n       <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.value = 12;\n          }\n        </script>\n        <form name=\"myForm\" ng-controller=\"Ctrl\">\n          Number: <input type=\"number\" name=\"input\" ng-model=\"value\"\n                         min=\"0\" max=\"99\" required>\n          <span class=\"error\" ng-show=\"myForm.list.$error.required\">\n            Required!</span>\n          <span class=\"error\" ng-show=\"myForm.list.$error.number\">\n            Not valid number!</span>\n          <tt>value = {{value}}</tt><br/>\n          <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n          <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n          <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n          <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n         </form>\n       </doc:source>\n       <doc:scenario>\n         it('should initialize to model', function() {\n          expect(binding('value')).toEqual('12');\n          expect(binding('myForm.input.$valid')).toEqual('true');\n         });\n\n         it('should be invalid if empty', function() {\n          input('value').enter('');\n          expect(binding('value')).toEqual('');\n          expect(binding('myForm.input.$valid')).toEqual('false');\n         });\n\n         it('should be invalid if over max', function() {\n          input('value').enter('123');\n          expect(binding('value')).toEqual('');\n          expect(binding('myForm.input.$valid')).toEqual('false');\n         });\n       </doc:scenario>\n     </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11182,
            "ngdoc": "inputType",
            "name": "ng.directive:input.url",
            "description": "Text input with URL validation. Sets the `url` validation error key if the content is not a\nvalid URL.",
            "params": [
                {
                    "name": "ngModel",
                    "description": "Assignable angular expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "name",
                    "description": "Property name of the form under which the control is published.",
                    "type": "String="
                },
                {
                    "name": "required",
                    "description": "Sets `required` validation error key if the value is not entered.",
                    "type": "String="
                },
                {
                    "name": "ngRequired",
                    "description": "Adds `required` attribute and `required` validation constraint to\n   the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   `required` when you want to data-bind to the `required` attribute.",
                    "type": "String="
                },
                {
                    "name": "ngMinlength",
                    "description": "Sets `minlength` validation error key if the value is shorter than\n   minlength.",
                    "type": "Number="
                },
                {
                    "name": "ngMaxlength",
                    "description": "Sets `maxlength` validation error key if the value is longer than\n   maxlength.",
                    "type": "Number="
                },
                {
                    "name": "ngPattern",
                    "description": "Sets `pattern` validation error key if the value does not match the\n   RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   patterns defined as scope expressions.",
                    "type": "String="
                },
                {
                    "name": "ngChange",
                    "description": "Angular expression to be executed when input changes due to user\n   interaction with the input element.",
                    "type": "String="
                }
            ],
            "example": [
                "\n     <doc:example>\n       <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.text = 'http://google.com';\n          }\n        </script>\n        <form name=\"myForm\" ng-controller=\"Ctrl\">\n          URL: <input type=\"url\" name=\"input\" ng-model=\"text\" required>\n          <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n            Required!</span>\n          <span class=\"error\" ng-show=\"myForm.input.$error.url\">\n            Not valid url!</span>\n          <tt>text = {{text}}</tt><br/>\n          <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n          <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n          <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n          <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n          <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>\n         </form>\n       </doc:source>\n       <doc:scenario>\n         it('should initialize to model', function() {\n           expect(binding('text')).toEqual('http://google.com');\n           expect(binding('myForm.input.$valid')).toEqual('true');\n         });\n\n         it('should be invalid if empty', function() {\n           input('text').enter('');\n           expect(binding('text')).toEqual('');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n         });\n\n         it('should be invalid if not url', function() {\n           input('text').enter('xxx');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n         });\n       </doc:scenario>\n     </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11250,
            "ngdoc": "inputType",
            "name": "ng.directive:input.email",
            "description": "Text input with email validation. Sets the `email` validation error key if not a valid email\naddress.",
            "params": [
                {
                    "name": "ngModel",
                    "description": "Assignable angular expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "name",
                    "description": "Property name of the form under which the control is published.",
                    "type": "String="
                },
                {
                    "name": "required",
                    "description": "Sets `required` validation error key if the value is not entered.",
                    "type": "String="
                },
                {
                    "name": "ngRequired",
                    "description": "Adds `required` attribute and `required` validation constraint to\n   the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   `required` when you want to data-bind to the `required` attribute.",
                    "type": "String="
                },
                {
                    "name": "ngMinlength",
                    "description": "Sets `minlength` validation error key if the value is shorter than\n   minlength.",
                    "type": "Number="
                },
                {
                    "name": "ngMaxlength",
                    "description": "Sets `maxlength` validation error key if the value is longer than\n   maxlength.",
                    "type": "Number="
                },
                {
                    "name": "ngPattern",
                    "description": "Sets `pattern` validation error key if the value does not match the\n   RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   patterns defined as scope expressions.",
                    "type": "String="
                }
            ],
            "example": [
                "\n     <doc:example>\n       <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.text = 'me@example.com';\n          }\n        </script>\n          <form name=\"myForm\" ng-controller=\"Ctrl\">\n            Email: <input type=\"email\" name=\"input\" ng-model=\"text\" required>\n            <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n              Required!</span>\n            <span class=\"error\" ng-show=\"myForm.input.$error.email\">\n              Not valid email!</span>\n            <tt>text = {{text}}</tt><br/>\n            <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n            <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n            <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n            <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n            <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>\n          </form>\n       </doc:source>\n       <doc:scenario>\n         it('should initialize to model', function() {\n           expect(binding('text')).toEqual('me@example.com');\n           expect(binding('myForm.input.$valid')).toEqual('true');\n         });\n\n         it('should be invalid if empty', function() {\n           input('text').enter('');\n           expect(binding('text')).toEqual('');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n         });\n\n         it('should be invalid if not email', function() {\n           input('text').enter('xxx');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n         });\n       </doc:scenario>\n     </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11316,
            "ngdoc": "inputType",
            "name": "ng.directive:input.radio",
            "description": "HTML radio button.",
            "params": [
                {
                    "name": "ngModel",
                    "description": "Assignable angular expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "value",
                    "description": "The value to which the expression should be set when selected.",
                    "type": "String"
                },
                {
                    "name": "name",
                    "description": "Property name of the form under which the control is published.",
                    "type": "String="
                },
                {
                    "name": "ngChange",
                    "description": "Angular expression to be executed when input changes due to user\n   interaction with the input element.",
                    "type": "String="
                }
            ],
            "example": [
                "\n     <doc:example>\n       <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.color = 'blue';\n          }\n        </script>\n        <form name=\"myForm\" ng-controller=\"Ctrl\">\n          <input type=\"radio\" ng-model=\"color\" value=\"red\">  Red <br/>\n          <input type=\"radio\" ng-model=\"color\" value=\"green\"> Green <br/>\n          <input type=\"radio\" ng-model=\"color\" value=\"blue\"> Blue <br/>\n          <tt>color = {{color}}</tt><br/>\n         </form>\n       </doc:source>\n       <doc:scenario>\n         it('should change state', function() {\n           expect(binding('color')).toEqual('blue');\n\n           input('color').select('red');\n           expect(binding('color')).toEqual('red');\n         });\n       </doc:scenario>\n     </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11357,
            "ngdoc": "inputType",
            "name": "ng.directive:input.checkbox",
            "description": "HTML checkbox.",
            "params": [
                {
                    "name": "ngModel",
                    "description": "Assignable angular expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "name",
                    "description": "Property name of the form under which the control is published.",
                    "type": "String="
                },
                {
                    "name": "ngTrueValue",
                    "description": "The value to which the expression should be set when selected.",
                    "type": "String="
                },
                {
                    "name": "ngFalseValue",
                    "description": "The value to which the expression should be set when not selected.",
                    "type": "String="
                },
                {
                    "name": "ngChange",
                    "description": "Angular expression to be executed when input changes due to user\n   interaction with the input element.",
                    "type": "String="
                }
            ],
            "example": [
                "\n     <doc:example>\n       <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.value1 = true;\n            $scope.value2 = 'YES'\n          }\n        </script>\n        <form name=\"myForm\" ng-controller=\"Ctrl\">\n          Value1: <input type=\"checkbox\" ng-model=\"value1\"> <br/>\n          Value2: <input type=\"checkbox\" ng-model=\"value2\"\n                         ng-true-value=\"YES\" ng-false-value=\"NO\"> <br/>\n          <tt>value1 = {{value1}}</tt><br/>\n          <tt>value2 = {{value2}}</tt><br/>\n         </form>\n       </doc:source>\n       <doc:scenario>\n         it('should change state', function() {\n           expect(binding('value1')).toEqual('true');\n           expect(binding('value2')).toEqual('YES');\n\n           input('value1').check();\n           input('value2').check();\n           expect(binding('value1')).toEqual('false');\n           expect(binding('value2')).toEqual('NO');\n         });\n       </doc:scenario>\n     </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11673,
            "ngdoc": "directive",
            "name": "ng.directive:textarea",
            "restrict": "E",
            "description": "HTML textarea element control with angular data-binding. The data-binding and validation\nproperties of this element are exactly the same as those of the\n{@link ng.directive:input input element}.",
            "params": [
                {
                    "name": "ngModel",
                    "description": "Assignable angular expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "name",
                    "description": "Property name of the form under which the control is published.",
                    "type": "String="
                },
                {
                    "name": "required",
                    "description": "Sets `required` validation error key if the value is not entered.",
                    "type": "String="
                },
                {
                    "name": "ngRequired",
                    "description": "Adds `required` attribute and `required` validation constraint to\n   the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   `required` when you want to data-bind to the `required` attribute.",
                    "type": "String="
                },
                {
                    "name": "ngMinlength",
                    "description": "Sets `minlength` validation error key if the value is shorter than\n   minlength.",
                    "type": "Number="
                },
                {
                    "name": "ngMaxlength",
                    "description": "Sets `maxlength` validation error key if the value is longer than\n   maxlength.",
                    "type": "Number="
                },
                {
                    "name": "ngPattern",
                    "description": "Sets `pattern` validation error key if the value does not match the\n   RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   patterns defined as scope expressions.",
                    "type": "String="
                },
                {
                    "name": "ngChange",
                    "description": "Angular expression to be executed when input changes due to user\n   interaction with the input element.",
                    "type": "String="
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11701,
            "ngdoc": "directive",
            "name": "ng.directive:input",
            "restrict": "E",
            "description": "HTML input element control with angular data-binding. Input control follows HTML5 input types\nand polyfills the HTML5 validation behavior for older browsers.",
            "params": [
                {
                    "name": "ngModel",
                    "description": "Assignable angular expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "name",
                    "description": "Property name of the form under which the control is published.",
                    "type": "String="
                },
                {
                    "name": "required",
                    "description": "Sets `required` validation error key if the value is not entered.",
                    "type": "String="
                },
                {
                    "name": "ngRequired",
                    "description": "Sets `required` attribute if set to true",
                    "type": "Boolean="
                },
                {
                    "name": "ngMinlength",
                    "description": "Sets `minlength` validation error key if the value is shorter than\n   minlength.",
                    "type": "Number="
                },
                {
                    "name": "ngMaxlength",
                    "description": "Sets `maxlength` validation error key if the value is longer than\n   maxlength.",
                    "type": "Number="
                },
                {
                    "name": "ngPattern",
                    "description": "Sets `pattern` validation error key if the value does not match the\n   RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   patterns defined as scope expressions.",
                    "type": "String="
                },
                {
                    "name": "ngChange",
                    "description": "Angular expression to be executed when input changes due to user\n   interaction with the input element.",
                    "type": "String="
                }
            ],
            "example": [
                "\n   <doc:example>\n     <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.user = {name: 'guest', last: 'visitor'};\n        }\n      </script>\n      <div ng-controller=\"Ctrl\">\n        <form name=\"myForm\">\n          User name: <input type=\"text\" name=\"userName\" ng-model=\"user.name\" required>\n          <span class=\"error\" ng-show=\"myForm.userName.$error.required\">\n            Required!</span><br>\n          Last name: <input type=\"text\" name=\"lastName\" ng-model=\"user.last\"\n            ng-minlength=\"3\" ng-maxlength=\"10\">\n          <span class=\"error\" ng-show=\"myForm.lastName.$error.minlength\">\n            Too short!</span>\n          <span class=\"error\" ng-show=\"myForm.lastName.$error.maxlength\">\n            Too long!</span><br>\n        </form>\n        <hr>\n        <tt>user = {{user}}</tt><br/>\n        <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>\n        <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>\n        <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>\n        <tt>myForm.userName.$error = {{myForm.lastName.$error}}</tt><br>\n        <tt>myForm.$valid = {{myForm.$valid}}</tt><br>\n        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>\n        <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>\n        <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>\n      </div>\n     </doc:source>\n     <doc:scenario>\n       it('should initialize to model', function() {\n         expect(binding('user')).toEqual('{\"name\":\"guest\",\"last\":\"visitor\"}');\n         expect(binding('myForm.userName.$valid')).toEqual('true');\n         expect(binding('myForm.$valid')).toEqual('true');\n       });\n\n       it('should be invalid if empty when required', function() {\n         input('user.name').enter('');\n         expect(binding('user')).toEqual('{\"last\":\"visitor\"}');\n         expect(binding('myForm.userName.$valid')).toEqual('false');\n         expect(binding('myForm.$valid')).toEqual('false');\n       });\n\n       it('should be valid if empty when min length is set', function() {\n         input('user.last').enter('');\n         expect(binding('user')).toEqual('{\"name\":\"guest\",\"last\":\"\"}');\n         expect(binding('myForm.lastName.$valid')).toEqual('true');\n         expect(binding('myForm.$valid')).toEqual('true');\n       });\n\n       it('should be invalid if less than required min length', function() {\n         input('user.last').enter('xx');\n         expect(binding('user')).toEqual('{\"name\":\"guest\"}');\n         expect(binding('myForm.lastName.$valid')).toEqual('false');\n         expect(binding('myForm.lastName.$error')).toMatch(/minlength/);\n         expect(binding('myForm.$valid')).toEqual('false');\n       });\n\n       it('should be invalid if longer than max length', function() {\n         input('user.last').enter('some ridiculously long name');\n         expect(binding('user'))\n           .toEqual('{\"name\":\"guest\"}');\n         expect(binding('myForm.lastName.$valid')).toEqual('false');\n         expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);\n         expect(binding('myForm.$valid')).toEqual('false');\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11814,
            "ngdoc": "object",
            "name": "{boolean} $invalid True if at least one error on the control.",
            "itemtype": "property",
            "type": "String",
            "description": "`NgModelController` provides API for the `ng-model` directive. The controller contains\nservices for data-binding, validation, CSS update, value formatting and parsing. It\nspecifically does not contain any logic which deals with DOM rendering or listening to\nDOM events. The `NgModelController` is meant to be extended by other directives where, the\ndirective provides DOM manipulation and the `NgModelController` provides the data-binding.\n\nThis example shows how to use `NgModelController` with a custom control to achieve\ndata-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)\ncollaborate together to achieve the desired result.\n\n<example module=\"customControl\">\n   <file name=\"style.css\">\n     [contenteditable] {\n       border: 1px solid black;\n       background-color: white;\n       min-height: 20px;\n     }\n\n     .ng-invalid {\n       border: 1px solid red;\n     }\n\n   </file>\n   <file name=\"script.js\">\n     angular.module('customControl', []).\n       directive('contenteditable', function() {\n         return {\n           restrict: 'A', // only activate on element attribute\n           require: '?ngModel', // get a hold of NgModelController\n           link: function(scope, element, attrs, ngModel) {\n             if(!ngModel) return; // do nothing if no ng-model\n\n             // Specify how UI should be updated\n             ngModel.$render = function() {\n               element.html(ngModel.$viewValue || '');\n             };\n\n             // Listen for change events to enable binding\n             element.bind('blur keyup change', function() {\n               scope.$apply(read);\n             });\n             read(); // initialize\n\n             // Write data to the model\n             function read() {\n               ngModel.$setViewValue(element.html());\n             }\n           }\n         };\n       });\n   </file>\n   <file name=\"index.html\">\n     <form name=\"myForm\">\n      <div contenteditable\n           name=\"myWidget\" ng-model=\"userContent\"\n           required>Change me!</div>\n       <span ng-show=\"myForm.myWidget.$error.required\">Required!</span>\n      <hr>\n      <textarea ng-model=\"userContent\"></textarea>\n     </form>\n   </file>\n   <file name=\"scenario.js\">\n     it('should data-bind and become invalid', function() {\n       var contentEditable = element('[contenteditable]');\n\n       expect(contentEditable.text()).toEqual('Change me!');\n       input('userContent').enter('');\n       expect(contentEditable.text()).toEqual('');\n       expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);\n     });\n   </file>\n</example>",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11930,
            "ngdoc": "function",
            "name": "ng.directive:ngModel.NgModelController#$render",
            "methodof": "ng.directive:ngModel.NgModelController",
            "description": "Called when the view needs to be updated. It is expected that the user of the ng-model\ndirective will implement this method.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 11958,
            "ngdoc": "function",
            "name": "ng.directive:ngModel.NgModelController#$setValidity",
            "methodof": "ng.directive:ngModel.NgModelController",
            "description": "Change the validity state, and notifies the form when the control changes validity. (i.e. it\ndoes not notify form if given validator is already marked as invalid).\n\nThis method should be called by validators - i.e. the parser or formatter functions.",
            "params": [
                {
                    "name": "validationErrorKey",
                    "description": "Name of the validator. the `validationErrorKey` will assign\n       to `$error[validationErrorKey]=isValid` so that it is available for data-binding.\n       The `validationErrorKey` should be in camelCase and will get converted into dash-case\n       for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`\n       class and can be bound to as  `{{someForm.someControl.$error.myError}}` .",
                    "type": "String"
                },
                {
                    "name": "isValid",
                    "description": "Whether the current state is valid (true) or invalid (false).",
                    "type": "Boolean"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12000,
            "ngdoc": "function",
            "name": "ng.directive:ngModel.NgModelController#$setViewValue",
            "methodof": "ng.directive:ngModel.NgModelController",
            "description": "Read a value from view.\n\nThis method should be called from within a DOM event handler.\nFor example {@link ng.directive:input input} or\n{@link ng.directive:select select} directives call it.\n\nIt internally calls all `formatters` and if resulted value is valid, updates the model and\ncalls all registered change listeners.",
            "params": [
                {
                    "name": "value",
                    "description": "Value from the view.",
                    "type": "String"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12071,
            "ngdoc": "directive",
            "name": "ng.directive:ngModel",
            "element": "input",
            "description": "Is directive that tells Angular to do two-way data binding. It works together with `input`,\n`select`, `textarea`. You can easily write your own directives to use `ngModel` as well.\n\n`ngModel` is responsible for:\n\n- binding the view into the model, which other directives such as `input`, `textarea` or `select`\n  require,\n- providing validation behavior (i.e. required, number, email, url),\n- keeping state of the control (valid/invalid, dirty/pristine, validation errors),\n- setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),\n- register the control with parent {@link ng.directive:form form}.\n\nFor basic examples, how to use `ngModel`, see:\n\n - {@link ng.directive:input input}\n   - {@link ng.directive:input.text text}\n   - {@link ng.directive:input.checkbox checkbox}\n   - {@link ng.directive:input.radio radio}\n   - {@link ng.directive:input.number number}\n   - {@link ng.directive:input.email email}\n   - {@link ng.directive:input.url url}\n - {@link ng.directive:select select}\n - {@link ng.directive:textarea textarea}",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12123,
            "ngdoc": "directive",
            "name": "ng.directive:ngChange",
            "restrict": "E",
            "description": "Evaluate given expression when user changes the input.\nThe expression is not evaluated when the value change is coming from the model.\n\nNote, this directive requires `ngModel` to be present.",
            "element": "input",
            "example": [
                "\n<doc:example>\n  <doc:source>\n    <script>\n      function Controller($scope) {\n        $scope.counter = 0;\n        $scope.change = function() {\n          $scope.counter++;\n        };\n      }\n    </script>\n    <div ng-controller=\"Controller\">\n      <input type=\"checkbox\" ng-model=\"confirmed\" ng-change=\"change()\" id=\"ng-change-example1\" />\n      <input type=\"checkbox\" ng-model=\"confirmed\" id=\"ng-change-example2\" />\n      <label for=\"ng-change-example2\">Confirmed</label><br />\n      debug = {{confirmed}}<br />\n      counter = {{counter}}\n    </div>\n  </doc:source>\n  <doc:scenario>\n    it('should evaluate the expression if changing from view', function() {\n      expect(binding('counter')).toEqual('0');\n      element('#ng-change-example1').click();\n      expect(binding('counter')).toEqual('1');\n      expect(binding('confirmed')).toEqual('true');\n    });\n\n    it('should not evaluate the expression if changing from model', function() {\n      element('#ng-change-example2').click();\n      expect(binding('counter')).toEqual('0');\n      expect(binding('confirmed')).toEqual('true');\n    });\n  </doc:scenario>\n</doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12209,
            "ngdoc": "directive",
            "name": "ng.directive:ngList",
            "description": "Text input that converts between comma-separated string into an array of strings.",
            "element": "input",
            "params": [
                {
                    "name": "ngList",
                    "description": "optional delimiter that should be used to split the value. If\n  specified in form `/something/` then the value will be converted into a regular expression.",
                    "type": "String="
                }
            ],
            "example": [
                "\n   <doc:example>\n     <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.names = ['igor', 'misko', 'vojta'];\n        }\n      </script>\n      <form name=\"myForm\" ng-controller=\"Ctrl\">\n        List: <input name=\"namesInput\" ng-model=\"names\" ng-list required>\n        <span class=\"error\" ng-show=\"myForm.list.$error.required\">\n          Required!</span>\n        <tt>names = {{names}}</tt><br/>\n        <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>\n        <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>\n        <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n        <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n       </form>\n     </doc:source>\n     <doc:scenario>\n       it('should initialize to model', function() {\n         expect(binding('names')).toEqual('[\"igor\",\"misko\",\"vojta\"]');\n         expect(binding('myForm.namesInput.$valid')).toEqual('true');\n       });\n\n       it('should be invalid if empty', function() {\n         input('names').enter('');\n         expect(binding('names')).toEqual('[]');\n         expect(binding('myForm.namesInput.$valid')).toEqual('false');\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12306,
            "ngdoc": "directive",
            "name": "ng.directive:ngBind",
            "description": "The `ngBind` attribute tells Angular to replace the text content of the specified HTML element\nwith the value of a given expression, and to update the text content when the value of that\nexpression changes.\n\nTypically, you don't use `ngBind` directly, but instead you use the double curly markup like\n`{{ expression }}` which is similar but less verbose.\n\nOnce scenario in which the use of `ngBind` is prefered over `{{ expression }}` binding is when\nit's desirable to put bindings into template that is momentarily displayed by the browser in its\nraw state before Angular compiles it. Since `ngBind` is an element attribute, it makes the\nbindings invisible to the user while the page is loading.\n\nAn alternative solution to this problem would be using the\n{@link ng.directive:ngCloak ngCloak} directive.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngBind",
                    "description": "{@link guide/expression Expression} to evaluate.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nEnter a name in the Live Preview text box; the greeting below the text box changes instantly.\n  <doc:example>\n    <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.name = 'Whirled';\n        }\n      </script>\n      <div ng-controller=\"Ctrl\">\n        Enter name: <input type=\"text\" ng-model=\"name\"><br>\n        Hello <span ng-bind=\"name\"></span>!\n      </div>\n    </doc:source>\n    <doc:scenario>\n      it('should check ng-bind', function() {\n        expect(using('.doc-example-live').binding('name')).toBe('Whirled');\n        using('.doc-example-live').input('name').enter('world');\n        expect(using('.doc-example-live').binding('name')).toBe('world');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12361,
            "ngdoc": "directive",
            "name": "ng.directive:ngBindTemplate",
            "description": "The `ngBindTemplate` directive specifies that the element\ntext should be replaced with the template in ngBindTemplate.\nUnlike ngBind the ngBindTemplate can contain multiple `{{` `}}`\nexpressions. (This is required since some HTML elements\ncan not have SPAN elements such as TITLE, or OPTION to name a few.)",
            "element": "ANY",
            "params": [
                {
                    "name": "ngBindTemplate",
                    "description": "template of form\n  <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.",
                    "type": "String"
                }
            ],
            "example": [
                "\nTry it here: enter text in text box and watch the greeting change.\n  <doc:example>\n    <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.salutation = 'Hello';\n          $scope.name = 'World';\n        }\n      </script>\n      <div ng-controller=\"Ctrl\">\n       Salutation: <input type=\"text\" ng-model=\"salutation\"><br>\n       Name: <input type=\"text\" ng-model=\"name\"><br>\n       <pre ng-bind-template=\"{{salutation}} {{name}}!\"></pre>\n      </div>\n    </doc:source>\n    <doc:scenario>\n      it('should check ng-bind', function() {\n        expect(using('.doc-example-live').binding('salutation')).\n          toBe('Hello');\n        expect(using('.doc-example-live').binding('name')).\n          toBe('World');\n        using('.doc-example-live').input('salutation').enter('Greetings');\n        using('.doc-example-live').input('name').enter('user');\n        expect(using('.doc-example-live').binding('salutation')).\n          toBe('Greetings');\n        expect(using('.doc-example-live').binding('name')).\n          toBe('user');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12420,
            "ngdoc": "directive",
            "name": "ng.directive:ngBindHtmlUnsafe",
            "description": "Creates a binding that will innerHTML the result of evaluating the `expression` into the current\nelement. *The innerHTML-ed content will not be sanitized!* You should use this directive only if\n{@link ngSanitize.directive:ngBindHtml ngBindHtml} directive is too\nrestrictive and when you absolutely trust the source of the content you are binding to.\n\nSee {@link ngSanitize.$sanitize $sanitize} docs for examples.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngBindHtmlUnsafe",
                    "description": "{@link guide/expression Expression} to evaluate.",
                    "type": "Expression"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12501,
            "ngdoc": "directive",
            "name": "ng.directive:ngClass",
            "description": "The `ngClass` allows you to set CSS class on HTML element dynamically by databinding an\nexpression that represents all classes to be added.\n\nThe directive won't add duplicate classes if a particular class was already set.\n\nWhen the expression changes, the previously added classes are removed and only then the\nnew classes are added.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngClass",
                    "description": "{@link guide/expression Expression} to eval. The result\n  of the evaluation can be a string representing space delimited class\n  names, an array, or a map of class names to boolean values.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <example>\n    <file name=\"index.html\">\n     <input type=\"button\" value=\"set\" ng-click=\"myVar='my-class'\">\n     <input type=\"button\" value=\"clear\" ng-click=\"myVar=''\">\n     <br>\n     <span ng-class=\"myVar\">Sample Text</span>\n    </file>\n    <file name=\"style.css\">\n      .my-class {\n        color: red;\n      }\n    </file>\n    <file name=\"scenario.js\">\n      it('should check ng-class', function() {\n        expect(element('.doc-example-live span').prop('className')).not().\n          toMatch(/my-class/);\n\n        using('.doc-example-live').element(':button:first').click();\n\n        expect(element('.doc-example-live span').prop('className')).\n          toMatch(/my-class/);\n\n        using('.doc-example-live').element(':button:last').click();\n\n        expect(element('.doc-example-live span').prop('className')).not().\n          toMatch(/my-class/);\n      });\n    </file>\n  </example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12552,
            "ngdoc": "directive",
            "name": "ng.directive:ngClassOdd",
            "description": "The `ngClassOdd` and `ngClassEven` directives work exactly as\n{@link ng.directive:ngClass ngClass}, except it works in\nconjunction with `ngRepeat` and takes affect only on odd (even) rows.\n\nThis directive can be applied only within a scope of an\n{@link ng.directive:ngRepeat ngRepeat}.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngClassOdd",
                    "description": "{@link guide/expression Expression} to eval. The result\n  of the evaluation can be a string representing space delimited class names or an array.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <example>\n    <file name=\"index.html\">\n       <ol ng-init=\"names=['John', 'Mary', 'Cate', 'Suz']\">\n         <li ng-repeat=\"name in names\">\n          <span ng-class-odd=\"'odd'\" ng-class-even=\"'even'\">\n            {{name}}\n          </span>\n         </li>\n       </ol>\n    </file>\n    <file name=\"style.css\">\n      .odd {\n        color: red;\n      }\n      .even {\n        color: blue;\n      }\n    </file>\n    <file name=\"scenario.js\">\n      it('should check ng-class-odd and ng-class-even', function() {\n        expect(element('.doc-example-live li:first span').prop('className')).\n          toMatch(/odd/);\n        expect(element('.doc-example-live li:last span').prop('className')).\n          toMatch(/even/);\n      });\n    </file>\n  </example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12599,
            "ngdoc": "directive",
            "name": "ng.directive:ngClassEven",
            "description": "The `ngClassOdd` and `ngClassEven` works exactly as\n{@link ng.directive:ngClass ngClass}, except it works in\nconjunction with `ngRepeat` and takes affect only on odd (even) rows.\n\nThis directive can be applied only within a scope of an\n{@link ng.directive:ngRepeat ngRepeat}.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngClassEven",
                    "description": "{@link guide/expression Expression} to eval. The\n  result of the evaluation can be a string representing space delimited class names or an array.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <example>\n    <file name=\"index.html\">\n       <ol ng-init=\"names=['John', 'Mary', 'Cate', 'Suz']\">\n         <li ng-repeat=\"name in names\">\n          <span ng-class-odd=\"'odd'\" ng-class-even=\"'even'\">\n            {{name}} &nbsp; &nbsp; &nbsp;\n          </span>\n         </li>\n       </ol>\n    </file>\n    <file name=\"style.css\">\n      .odd {\n        color: red;\n      }\n      .even {\n        color: blue;\n      }\n    </file>\n    <file name=\"scenario.js\">\n      it('should check ng-class-odd and ng-class-even', function() {\n        expect(element('.doc-example-live li:first span').prop('className')).\n          toMatch(/odd/);\n        expect(element('.doc-example-live li:last span').prop('className')).\n          toMatch(/even/);\n      });\n    </file>\n  </example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12646,
            "ngdoc": "directive",
            "name": "ng.directive:ngCloak",
            "description": "The `ngCloak` directive is used to prevent the Angular html template from being briefly\ndisplayed by the browser in its raw (uncompiled) form while your application is loading. Use this\ndirective to avoid the undesirable flicker effect caused by the html template display.\n\nThe directive can be applied to the `<body>` element, but typically a fine-grained application is\nprefered in order to benefit from progressive rendering of the browser view.\n\n`ngCloak` works in cooperation with a css rule that is embedded within `angular.js` and\n `angular.min.js` files. Following is the css rule:\n\n<pre>\n[ng\\:cloak], [ng-cloak], .ng-cloak {\n  display: none;\n}\n</pre>\n\nWhen this css rule is loaded by the browser, all html elements (including their children) that\nare tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive\nduring the compilation of the template it deletes the `ngCloak` element attribute, which\nmakes the compiled element visible.\n\nFor the best result, `angular.js` script must be loaded in the head section of the html file;\nalternatively, the css rule (above) must be included in the external stylesheet of the\napplication.\n\nLegacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they\ncannot match the `[ng\\:cloak]` selector. To work around this limitation, you must add the css\nclass `ngCloak` in addition to `ngCloak` directive as shown in the example below.",
            "element": "ANY",
            "example": [
                "\n  <doc:example>\n    <doc:source>\n       <div id=\"template1\" ng-cloak>{{ 'hello' }}</div>\n       <div id=\"template2\" ng-cloak class=\"ng-cloak\">{{ 'hello IE7' }}</div>\n    </doc:source>\n    <doc:scenario>\n      it('should remove the template directive and css class', function() {\n        expect(element('.doc-example-live #template1').attr('ng-cloak')).\n          not().toBeDefined();\n        expect(element('.doc-example-live #template2').attr('ng-cloak')).\n          not().toBeDefined();\n      });\n    </doc:scenario>\n  </doc:example>\n"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12706,
            "ngdoc": "directive",
            "name": "ng.directive:ngController",
            "description": "The `ngController` directive assigns behavior to a scope. This is a key aspect of how angular\nsupports the principles behind the Model-View-Controller design pattern.\n\nMVC components in angular:\n\n* Model — The Model is data in scope properties; scopes are attached to the DOM.\n* View — The template (HTML with data bindings) is rendered into the View.\n* Controller — The `ngController` directive specifies a Controller class; the class has\n  methods that typically express the business logic behind the application.\n\nNote that an alternative way to define controllers is via the `{@link ng.$route}`\nservice.",
            "element": "ANY",
            "scope": "",
            "params": [
                {
                    "name": "ngController",
                    "description": "Name of a globally accessible constructor function or an\n    {@link guide/expression expression} that on the current scope evaluates to a\n    constructor function.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nHere is a simple form for editing user contact information. Adding, removing, clearing, and\ngreeting are methods declared on the controller (see source tab). These methods can\neasily be called from the angular markup. Notice that the scope becomes the `this` for the\ncontroller's instance. This allows for easy access to the view data from the controller. Also\nnotice that any changes to the data are automatically reflected in the View without the need\nfor a manual update.\n  <doc:example>\n    <doc:source>\n     <script>\n       function SettingsController($scope) {\n         $scope.name = \"John Smith\";\n         $scope.contacts = [\n           {type:'phone', value:'408 555 1212'},\n           {type:'email', value:'john.smith@example.org'} ];\n\n         $scope.greet = function() {\n          alert(this.name);\n         };\n\n         $scope.addContact = function() {\n          this.contacts.push({type:'email', value:'yourname@example.org'});\n         };\n\n         $scope.removeContact = function(contactToRemove) {\n          var index = this.contacts.indexOf(contactToRemove);\n          this.contacts.splice(index, 1);\n         };\n\n         $scope.clearContact = function(contact) {\n          contact.type = 'phone';\n          contact.value = '';\n         };\n       }\n     </script>\n     <div ng-controller=\"SettingsController\">\n       Name: <input type=\"text\" ng-model=\"name\"/>\n       [ <a href=\"\" ng-click=\"greet()\">greet</a> ]<br/>\n       Contact:\n       <ul>\n         <li ng-repeat=\"contact in contacts\">\n           <select ng-model=\"contact.type\">\n              <option>phone</option>\n              <option>email</option>\n           </select>\n           <input type=\"text\" ng-model=\"contact.value\"/>\n           [ <a href=\"\" ng-click=\"clearContact(contact)\">clear</a>\n           | <a href=\"\" ng-click=\"removeContact(contact)\">X</a> ]\n         </li>\n         <li>[ <a href=\"\" ng-click=\"addContact()\">add</a> ]</li>\n      </ul>\n     </div>\n    </doc:source>\n    <doc:scenario>\n      it('should check controller', function() {\n        expect(element('.doc-example-live div>:input').val()).toBe('John Smith');\n        expect(element('.doc-example-live li:nth-child(1) input').val())\n          .toBe('408 555 1212');\n        expect(element('.doc-example-live li:nth-child(2) input').val())\n          .toBe('john.smith@example.org');\n\n        element('.doc-example-live li:first a:contains(\"clear\")').click();\n        expect(element('.doc-example-live li:first input').val()).toBe('');\n\n        element('.doc-example-live li:last a:contains(\"add\")').click();\n        expect(element('.doc-example-live li:nth-child(3) input').val())\n          .toBe('yourname@example.org');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12808,
            "ngdoc": "directive",
            "name": "ng.directive:ngCsp",
            "priority": "1000",
            "description": "Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.\nThis directive should be used on the root element of the application (typically the `<html>`\nelement or other element with the {@link ng.directive:ngApp ngApp}\ndirective).\n\nIf enabled the performance of template expression evaluator will suffer slightly, so don't enable\nthis mode unless you need it.",
            "element": "html",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12834,
            "ngdoc": "directive",
            "name": "ng.directive:ngClick",
            "description": "The ngClick allows you to specify custom behavior when\nelement is clicked.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngClick",
                    "description": "{@link guide/expression Expression} to evaluate upon\nclick. (Event object is available as `$event`)",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <doc:example>\n    <doc:source>\n     <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\n       Increment\n     </button>\n     count: {{count}}\n    </doc:source>\n    <doc:scenario>\n      it('should check ng-click', function() {\n        expect(binding('count')).toBe('0');\n        element('.doc-example-live :button').click();\n        expect(binding('count')).toBe('1');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12887,
            "ngdoc": "directive",
            "name": "ng.directive:ngDblclick",
            "description": "The `ngDblclick` directive allows you to specify custom behavior on dblclick event.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngDblclick",
                    "description": "{@link guide/expression Expression} to evaluate upon\ndblclick. (Event object is available as `$event`)",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nSee {@link ng.directive:ngClick ngClick}"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12903,
            "ngdoc": "directive",
            "name": "ng.directive:ngMousedown",
            "description": "The ngMousedown directive allows you to specify custom behavior on mousedown event.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngMousedown",
                    "description": "{@link guide/expression Expression} to evaluate upon\nmousedown. (Event object is available as `$event`)",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nSee {@link ng.directive:ngClick ngClick}"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12919,
            "ngdoc": "directive",
            "name": "ng.directive:ngMouseup",
            "description": "Specify custom behavior on mouseup event.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngMouseup",
                    "description": "{@link guide/expression Expression} to evaluate upon\nmouseup. (Event object is available as `$event`)",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nSee {@link ng.directive:ngClick ngClick}"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12934,
            "ngdoc": "directive",
            "name": "ng.directive:ngMouseover",
            "description": "Specify custom behavior on mouseover event.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngMouseover",
                    "description": "{@link guide/expression Expression} to evaluate upon\nmouseover. (Event object is available as `$event`)",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nSee {@link ng.directive:ngClick ngClick}"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12950,
            "ngdoc": "directive",
            "name": "ng.directive:ngMouseenter",
            "description": "Specify custom behavior on mouseenter event.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngMouseenter",
                    "description": "{@link guide/expression Expression} to evaluate upon\nmouseenter. (Event object is available as `$event`)",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nSee {@link ng.directive:ngClick ngClick}"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12966,
            "ngdoc": "directive",
            "name": "ng.directive:ngMouseleave",
            "description": "Specify custom behavior on mouseleave event.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngMouseleave",
                    "description": "{@link guide/expression Expression} to evaluate upon\nmouseleave. (Event object is available as `$event`)",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nSee {@link ng.directive:ngClick ngClick}"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12982,
            "ngdoc": "directive",
            "name": "ng.directive:ngMousemove",
            "description": "Specify custom behavior on mousemove event.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngMousemove",
                    "description": "{@link guide/expression Expression} to evaluate upon\nmousemove. (Event object is available as `$event`)",
                    "type": "Expression"
                }
            ],
            "example": [
                "\nSee {@link ng.directive:ngClick ngClick}"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 12998,
            "ngdoc": "directive",
            "name": "ng.directive:ngSubmit",
            "description": "Enables binding angular expressions to onsubmit events.\n\nAdditionally it prevents the default action (which for form means sending the request to the\nserver and reloading the current page).",
            "element": "form",
            "params": [
                {
                    "name": "ngSubmit",
                    "description": "{@link guide/expression Expression} to eval.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <doc:example>\n    <doc:source>\n     <script>\n       function Ctrl($scope) {\n         $scope.list = [];\n         $scope.text = 'hello';\n         $scope.submit = function() {\n           if (this.text) {\n             this.list.push(this.text);\n             this.text = '';\n           }\n         };\n       }\n     </script>\n     <form ng-submit=\"submit()\" ng-controller=\"Ctrl\">\n       Enter text and hit enter:\n       <input type=\"text\" ng-model=\"text\" name=\"text\" />\n       <input type=\"submit\" id=\"submit\" value=\"Submit\" />\n       <pre>list={{list}}</pre>\n     </form>\n    </doc:source>\n    <doc:scenario>\n      it('should check ng-submit', function() {\n        expect(binding('list')).toBe('[]');\n        element('.doc-example-live #submit').click();\n        expect(binding('list')).toBe('[\"hello\"]');\n        expect(input('text').val()).toBe('');\n      });\n      it('should ignore empty strings', function() {\n        expect(binding('list')).toBe('[]');\n        element('.doc-example-live #submit').click();\n        element('.doc-example-live #submit').click();\n        expect(binding('list')).toBe('[\"hello\"]');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13055,
            "ngdoc": "directive",
            "name": "ng.directive:ngInclude",
            "restrict": "ECA",
            "description": "Fetches, compiles and includes an external HTML fragment.\n\nKeep in mind that Same Origin Policy applies to included resources\n(e.g. ngInclude won't work for cross-domain requests on all browsers and for\n file:// access on some browsers).",
            "scope": "",
            "params": [
                {
                    "name": "ngInclude|src",
                    "description": "angular expression evaluating to URL. If the source is a string constant,\n                make sure you wrap it in quotes, e.g. `src=\"'myPartialTemplate.html'\"`.",
                    "type": "String"
                },
                {
                    "name": "onload",
                    "description": "Expression to evaluate when a new partial is loaded.",
                    "type": "String="
                },
                {
                    "name": "autoscroll",
                    "description": "Whether `ngInclude` should call {@link ng.$anchorScroll\n                 $anchorScroll} to scroll the viewport after the content is loaded.\n\n                 - If the attribute is not set, disable scrolling.\n                 - If the attribute is set without value, enable scrolling.\n                 - Otherwise enable scrolling only if the expression evaluates to truthy value.",
                    "type": "String="
                }
            ],
            "example": [
                "\n <example>\n   <file name=\"index.html\">\n    <div ng-controller=\"Ctrl\">\n      <select ng-model=\"template\" ng-options=\"t.name for t in templates\">\n       <option value=\"\">(blank)</option>\n      </select>\n      url of the template: <tt>{{template.url}}</tt>\n      <hr/>\n      <div ng-include src=\"template.url\"></div>\n    </div>\n   </file>\n   <file name=\"script.js\">\n     function Ctrl($scope) {\n       $scope.templates =\n         [ { name: 'template1.html', url: 'template1.html'}\n         , { name: 'template2.html', url: 'template2.html'} ];\n       $scope.template = $scope.templates[0];\n     }\n    </file>\n   <file name=\"template1.html\">\n     Content of template1.html\n   </file>\n   <file name=\"template2.html\">\n     Content of template2.html\n   </file>\n   <file name=\"scenario.js\">\n     it('should load template1.html', function() {\n      expect(element('.doc-example-live [ng-include]').text()).\n        toMatch(/Content of template1.html/);\n     });\n     it('should load template2.html', function() {\n      select('template').option('1');\n      expect(element('.doc-example-live [ng-include]').text()).\n        toMatch(/Content of template2.html/);\n     });\n     it('should change to blank', function() {\n      select('template').option('');\n      expect(element('.doc-example-live [ng-include]').text()).toEqual('');\n     });\n   </file>\n </example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13125,
            "ngdoc": "event",
            "name": "ng.directive:ngInclude#$includeContentLoaded",
            "eventof": "ng.directive:ngInclude",
            "eventtype": "emit on the current ngInclude scope",
            "description": "Emitted every time the ngInclude content is reloaded.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13185,
            "ngdoc": "directive",
            "name": "ng.directive:ngInit",
            "description": "The `ngInit` directive specifies initialization tasks to be executed\n before the template enters execution mode during bootstrap.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngInit",
                    "description": "{@link guide/expression Expression} to eval.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <doc:example>\n    <doc:source>\n   <div ng-init=\"greeting='Hello'; person='World'\">\n     {{greeting}} {{person}}!\n   </div>\n    </doc:source>\n    <doc:scenario>\n      it('should check greeting', function() {\n        expect(binding('greeting')).toBe('Hello');\n        expect(binding('person')).toBe('World');\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13221,
            "ngdoc": "directive",
            "name": "ng.directive:ngNonBindable",
            "priority": "1000",
            "description": "Sometimes it is necessary to write code which looks like bindings but which should be left alone\nby angular. Use `ngNonBindable` to make angular ignore a chunk of HTML.",
            "element": "ANY",
            "example": [
                "\nIn this example there are two location where a simple binding (`{{}}`) is present, but the one\nwrapped in `ngNonBindable` is left alone.",
                "\n   <doc:example>\n     <doc:source>\n       <div>Normal: {{1 + 2}}</div>\n       <div ng-non-bindable>Ignored: {{1 + 2}}</div>\n     </doc:source>\n     <doc:scenario>\n      it('should check ng-non-bindable', function() {\n        expect(using('.doc-example-live').binding('1 + 2')).toBe('3');\n        expect(using('.doc-example-live').element('div:last').text()).\n          toMatch(/1 \\+ 2/);\n      });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13253,
            "ngdoc": "directive",
            "name": "ng.directive:ngPluralize",
            "restrict": "EA",
            "description": "# Overview\n`ngPluralize` is a directive that displays messages according to en-US localization rules.\nThese rules are bundled with angular.js and the rules can be overridden\n(see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive\nby specifying the mappings between\n{@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\nplural categories} and the strings to be displayed.\n\n# Plural categories and explicit number rules\nThere are two\n{@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\nplural categories} in Angular's default en-US locale: \"one\" and \"other\".\n\nWhile a pural category may match many numbers (for example, in en-US locale, \"other\" can match\nany number that is not 1), an explicit number rule can only match one number. For example, the\nexplicit number rule for \"3\" matches the number 3. You will see the use of plural categories\nand explicit number rules throughout later parts of this documentation.\n\n# Configuring ngPluralize\nYou configure ngPluralize by providing 2 attributes: `count` and `when`.\nYou can also provide an optional attribute, `offset`.\n\nThe value of the `count` attribute can be either a string or an {@link guide/expression\nAngular expression}; these are evaluated on the current scope for its bound value.\n\nThe `when` attribute specifies the mappings between plural categories and the actual\nstring to be displayed. The value of the attribute should be a JSON object so that Angular\ncan interpret it correctly.\n\nThe following example shows how to configure ngPluralize:\n\n<pre>\n<ng-pluralize count=\"personCount\"\n                when=\"{'0': 'Nobody is viewing.',\n                     'one': '1 person is viewing.',\n                     'other': '{} people are viewing.'}\">\n</ng-pluralize>\n</pre>\n\nIn the example, `\"0: Nobody is viewing.\"` is an explicit number rule. If you did not\nspecify this rule, 0 would be matched to the \"other\" category and \"0 people are viewing\"\nwould be shown instead of \"Nobody is viewing\". You can specify an explicit number rule for\nother numbers, for example 12, so that instead of showing \"12 people are viewing\", you can\nshow \"a dozen people are viewing\".\n\nYou can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted\ninto pluralized strings. In the previous example, Angular will replace `{}` with\n<span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder\nfor <span ng-non-bindable>{{numberExpression}}</span>.\n\n# Configuring ngPluralize with offset\nThe `offset` attribute allows further customization of pluralized text, which can result in\na better user experience. For example, instead of the message \"4 people are viewing this document\",\nyou might display \"John, Kate and 2 others are viewing this document\".\nThe offset attribute allows you to offset a number by any desired value.\nLet's take a look at an example:\n\n<pre>\n<ng-pluralize count=\"personCount\" offset=2\n              when=\"{'0': 'Nobody is viewing.',\n                     '1': '{{person1}} is viewing.',\n                     '2': '{{person1}} and {{person2}} are viewing.',\n                     'one': '{{person1}}, {{person2}} and one other person are viewing.',\n                     'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\n</ng-pluralize>\n</pre>\n\nNotice that we are still using two plural categories(one, other), but we added\nthree explicit number rules 0, 1 and 2.\nWhen one person, perhaps John, views the document, \"John is viewing\" will be shown.\nWhen three people view the document, no explicit number rule is found, so\nan offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.\nIn this case, plural category 'one' is matched and \"John, Marry and one other person are viewing\"\nis shown.\n\nNote that when you specify offsets, you must provide explicit number rules for\nnumbers from 0 up to and including the offset. If you use an offset of 3, for example,\nyou must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for\nplural categories \"one\" and \"other\".",
            "params": [
                {
                    "name": "count",
                    "description": "The variable to be bounded to.",
                    "type": "String|expression"
                },
                {
                    "name": "when",
                    "description": "The mapping between plural category to its correspoding strings.",
                    "type": "String"
                },
                {
                    "name": "offset",
                    "description": "Offset to deduct from the total number.",
                    "type": "Number="
                }
            ],
            "example": [
                "\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.person1 = 'Igor';\n           $scope.person2 = 'Misko';\n           $scope.personCount = 1;\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         Person 1:<input type=\"text\" ng-model=\"person1\" value=\"Igor\" /><br/>\n         Person 2:<input type=\"text\" ng-model=\"person2\" value=\"Misko\" /><br/>\n         Number of People:<input type=\"text\" ng-model=\"personCount\" value=\"1\" /><br/>\n\n         <!--- Example with simple pluralization rules for en locale --->\n         Without Offset:\n         <ng-pluralize count=\"personCount\"\n                       when=\"{'0': 'Nobody is viewing.',\n                              'one': '1 person is viewing.',\n                              'other': '{} people are viewing.'}\">\n         </ng-pluralize><br>\n\n         <!--- Example with offset --->\n         With Offset(2):\n         <ng-pluralize count=\"personCount\" offset=2\n                       when=\"{'0': 'Nobody is viewing.',\n                              '1': '{{person1}} is viewing.',\n                              '2': '{{person1}} and {{person2}} are viewing.',\n                              'one': '{{person1}}, {{person2}} and one other person are viewing.',\n                              'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\n         </ng-pluralize>\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should show correct pluralized string', function() {\n         expect(element('.doc-example-live ng-pluralize:first').text()).\n                                            toBe('1 person is viewing.');\n         expect(element('.doc-example-live ng-pluralize:last').text()).\n                                               toBe('Igor is viewing.');\n\n         using('.doc-example-live').input('personCount').enter('0');\n         expect(element('.doc-example-live ng-pluralize:first').text()).\n                                              toBe('Nobody is viewing.');\n         expect(element('.doc-example-live ng-pluralize:last').text()).\n                                             toBe('Nobody is viewing.');\n\n         using('.doc-example-live').input('personCount').enter('2');\n         expect(element('.doc-example-live ng-pluralize:first').text()).\n                                           toBe('2 people are viewing.');\n         expect(element('.doc-example-live ng-pluralize:last').text()).\n                             toBe('Igor and Misko are viewing.');\n\n         using('.doc-example-live').input('personCount').enter('3');\n         expect(element('.doc-example-live ng-pluralize:first').text()).\n                                           toBe('3 people are viewing.');\n         expect(element('.doc-example-live ng-pluralize:last').text()).\n                             toBe('Igor, Misko and one other person are viewing.');\n\n         using('.doc-example-live').input('personCount').enter('4');\n         expect(element('.doc-example-live ng-pluralize:first').text()).\n                                           toBe('4 people are viewing.');\n         expect(element('.doc-example-live ng-pluralize:last').text()).\n                             toBe('Igor, Misko and 2 other people are viewing.');\n       });\n\n       it('should show data-binded names', function() {\n         using('.doc-example-live').input('personCount').enter('4');\n         expect(element('.doc-example-live ng-pluralize:last').text()).\n             toBe('Igor, Misko and 2 other people are viewing.');\n\n         using('.doc-example-live').input('person1').enter('Di');\n         using('.doc-example-live').input('person2').enter('Vojta');\n         expect(element('.doc-example-live ng-pluralize:last').text()).\n             toBe('Di, Vojta and 2 other people are viewing.');\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13459,
            "ngdoc": "directive",
            "name": "ng.directive:ngRepeat",
            "description": "The `ngRepeat` directive instantiates a template once per item from a collection. Each template\ninstance gets its own scope, where the given loop variable is set to the current collection item,\nand `$index` is set to the item index or key.\n\nSpecial properties are exposed on the local scope of each template instance, including:\n\n  * `$index` – `{number}` – iterator offset of the repeated element (0..length-1)\n  * `$first` – `{boolean}` – true if the repeated element is first in the iterator.\n  * `$middle` – `{boolean}` – true if the repeated element is between the first and last in the iterator.\n  * `$last` – `{boolean}` – true if the repeated element is last in the iterator.",
            "element": "ANY",
            "scope": "",
            "priority": "1000",
            "params": [
                {
                    "name": "ngRepeat",
                    "description": "The expression indicating how to enumerate a collection. Two\n  formats are currently supported:\n\n  * `variable in expression` – where variable is the user defined loop variable and `expression`\n    is a scope expression giving the collection to enumerate.\n\n    For example: `track in cd.tracks`.\n\n  * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,\n    and `expression` is the scope expression giving the collection to enumerate.\n\n    For example: `(name, age) in {'adam':10, 'amalie':12}`.",
                    "type": "Repeat_expression"
                }
            ],
            "example": [
                "\nThis example initializes the scope to a list of names and\nthen uses `ngRepeat` to display every person:\n   <doc:example>\n     <doc:source>\n       <div ng-init=\"friends = [{name:'John', age:25}, {name:'Mary', age:28}]\">\n         I have {{friends.length}} friends. They are:\n         <ul>\n           <li ng-repeat=\"friend in friends\">\n             [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.\n           </li>\n         </ul>\n       </div>\n     </doc:source>\n     <doc:scenario>\n        it('should check ng-repeat', function() {\n          var r = using('.doc-example-live').repeater('ul li');\n          expect(r.count()).toBe(2);\n          expect(r.row(0)).toEqual([\"1\",\"John\",\"25\"]);\n          expect(r.row(1)).toEqual([\"2\",\"Mary\",\"28\"]);\n        });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13647,
            "ngdoc": "directive",
            "name": "ng.directive:ngShow",
            "description": "The `ngShow` and `ngHide` directives show or hide a portion of the DOM tree (HTML)\nconditionally.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngShow",
                    "description": "If the {@link guide/expression expression} is truthy\n    then the element is shown or hidden respectively.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <doc:example>\n    <doc:source>\n       Click me: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n       Show: <span ng-show=\"checked\">I show up when your checkbox is checked.</span> <br/>\n       Hide: <span ng-hide=\"checked\">I hide when your checkbox is checked.</span>\n    </doc:source>\n    <doc:scenario>\n      it('should check ng-show / ng-hide', function() {\n        expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);\n        expect(element('.doc-example-live span:last:visible').count()).toEqual(1);\n\n        input('checked').check();\n\n        expect(element('.doc-example-live span:first:visible').count()).toEqual(1);\n        expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13687,
            "ngdoc": "directive",
            "name": "ng.directive:ngHide",
            "description": "The `ngHide` and `ngShow` directives hide or show a portion of the DOM tree (HTML)\nconditionally.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngHide",
                    "description": "If the {@link guide/expression expression} is truthy then\n    the element is shown or hidden respectively.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <doc:example>\n    <doc:source>\n       Click me: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n       Show: <span ng-show=\"checked\">I show up when you checkbox is checked?</span> <br/>\n       Hide: <span ng-hide=\"checked\">I hide when you checkbox is checked?</span>\n    </doc:source>\n    <doc:scenario>\n      it('should check ng-show / ng-hide', function() {\n        expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);\n        expect(element('.doc-example-live span:last:visible').count()).toEqual(1);\n\n        input('checked').check();\n\n        expect(element('.doc-example-live span:first:visible').count()).toEqual(1);\n        expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);\n      });\n    </doc:scenario>\n  </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13726,
            "ngdoc": "directive",
            "name": "ng.directive:ngStyle",
            "description": "The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.",
            "element": "ANY",
            "params": [
                {
                    "name": "ngStyle",
                    "description": "{@link guide/expression Expression} which evals to an\n     object whose keys are CSS style names and values are corresponding values for those CSS\n     keys.",
                    "type": "Expression"
                }
            ],
            "example": [
                "\n  <example>\n    <file name=\"index.html\">\n       <input type=\"button\" value=\"set\" ng-click=\"myStyle={color:'red'}\">\n       <input type=\"button\" value=\"clear\" ng-click=\"myStyle={}\">\n       <br/>\n       <span ng-style=\"myStyle\">Sample Text</span>\n       <pre>myStyle={{myStyle}}</pre>\n    </file>\n    <file name=\"style.css\">\n      span {\n        color: black;\n      }\n    </file>\n    <file name=\"scenario.js\">\n      it('should check ng-style', function() {\n        expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');\n        element('.doc-example-live :button[value=set]').click();\n        expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');\n        element('.doc-example-live :button[value=clear]').click();\n        expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');\n      });\n    </file>\n  </example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13772,
            "ngdoc": "directive",
            "name": "ng.directive:ngSwitch",
            "restrict": "EA",
            "description": "Conditionally change the DOM structure.",
            "usagecontent": "<ANY ng-switch-when=\"matchValue1\">...</ANY>\n  <ANY ng-switch-when=\"matchValue2\">...</ANY>\n  ...\n  <ANY ng-switch-default>...</ANY>",
            "scope": "",
            "params": [
                {
                    "name": "ngSwitch|on",
                    "description": "expression to match against <tt>ng-switch-when</tt>.",
                    "type": "*"
                }
            ],
            "paramdescription": "On child elments add:\n\n* `ngSwitchWhen`: the case statement to match against. If match then this\n  case will be displayed.\n* `ngSwitchDefault`: the default case when no other casses match.",
            "example": [
                "\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.items = ['settings', 'home', 'other'];\n           $scope.selection = $scope.items[0];\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <select ng-model=\"selection\" ng-options=\"item for item in items\">\n         </select>\n         <tt>selection={{selection}}</tt>\n         <hr/>\n         <div ng-switch on=\"selection\" >\n           <div ng-switch-when=\"settings\">Settings Div</div>\n           <span ng-switch-when=\"home\">Home Span</span>\n           <span ng-switch-default>default</span>\n         </div>\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should start in settings', function() {\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);\n       });\n       it('should change to home', function() {\n        select('selection').option('home');\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);\n       });\n       it('should select deafault', function() {\n        select('selection').option('other');\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);\n       });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13885,
            "ngdoc": "directive",
            "name": "ng.directive:ngTransclude",
            "description": "Insert the transcluded DOM here.",
            "element": "ANY",
            "example": [
                "\n  <doc:example module=\"transclude\">\n    <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.title = 'Lorem Ipsum';\n          $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';\n        }\n\n        angular.module('transclude', [])\n         .directive('pane', function(){\n            return {\n              restrict: 'E',\n              transclude: true,\n              scope: 'isolate',\n              locals: { title:'bind' },\n              template: '<div style=\"border: 1px solid black;\">' +\n                          '<div style=\"background-color: gray\">{{title}}</div>' +\n                          '<div ng-transclude></div>' +\n                        '</div>'\n            };\n        });\n      </script>\n      <div ng-controller=\"Ctrl\">\n        <input ng-model=\"title\"><br>\n        <textarea ng-model=\"text\"></textarea> <br/>\n        <pane title=\"{{title}}\">{{text}}</pane>\n      </div>\n    </doc:source>\n    <doc:scenario>\n       it('should have transcluded', function() {\n         input('title').enter('TITLE');\n         input('text').enter('TEXT');\n         expect(binding('title')).toEqual('TITLE');\n         expect(binding('text')).toEqual('TEXT');\n       });\n    </doc:scenario>\n  </doc:example>\n"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 13942,
            "ngdoc": "directive",
            "name": "ng.directive:ngView",
            "restrict": "ECA",
            "description": "# Overview\n`ngView` is a directive that complements the {@link ng.$route $route} service by\nincluding the rendered template of the current route into the main layout (`index.html`) file.\nEvery time the current route changes, the included view changes with it according to the\nconfiguration of the `$route` service.",
            "scope": "",
            "example": [
                "\n   <example module=\"ngView\">\n     <file name=\"index.html\">\n       <div ng-controller=\"MainCntl\">\n         Choose:\n         <a href=\"Book/Moby\">Moby</a> |\n         <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n         <a href=\"Book/Gatsby\">Gatsby</a> |\n         <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n         <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n         <div ng-view></div>\n         <hr />\n\n         <pre>$location.path() = {{$location.path()}}</pre>\n         <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n         <pre>$route.current.params = {{$route.current.params}}</pre>\n         <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n         <pre>$routeParams = {{$routeParams}}</pre>\n       </div>\n     </file>\n\n     <file name=\"book.html\">\n       controller: {{name}}<br />\n       Book Id: {{params.bookId}}<br />\n     </file>\n\n     <file name=\"chapter.html\">\n       controller: {{name}}<br />\n       Book Id: {{params.bookId}}<br />\n       Chapter Id: {{params.chapterId}}\n     </file>\n\n     <file name=\"script.js\">\n       angular.module('ngView', [], function($routeProvider, $locationProvider) {\n         $routeProvider.when('/Book/:bookId', {\n           templateUrl: 'book.html',\n           controller: BookCntl\n         });\n         $routeProvider.when('/Book/:bookId/ch/:chapterId', {\n           templateUrl: 'chapter.html',\n           controller: ChapterCntl\n         });\n\n         // configure html5 to get links working on jsfiddle\n         $locationProvider.html5Mode(true);\n       });\n\n       function MainCntl($scope, $route, $routeParams, $location) {\n         $scope.$route = $route;\n         $scope.$location = $location;\n         $scope.$routeParams = $routeParams;\n       }\n\n       function BookCntl($scope, $routeParams) {\n         $scope.name = \"BookCntl\";\n         $scope.params = $routeParams;\n       }\n\n       function ChapterCntl($scope, $routeParams) {\n         $scope.name = \"ChapterCntl\";\n         $scope.params = $routeParams;\n       }\n     </file>\n\n     <file name=\"scenario.js\">\n       it('should load and compile correct template', function() {\n         element('a:contains(\"Moby: Ch1\")').click();\n         var content = element('.doc-example-live [ng-view]').text();\n         expect(content).toMatch(/controller\\: ChapterCntl/);\n         expect(content).toMatch(/Book Id\\: Moby/);\n         expect(content).toMatch(/Chapter Id\\: 1/);\n\n         element('a:contains(\"Scarlet\")').click();\n         content = element('.doc-example-live [ng-view]').text();\n         expect(content).toMatch(/controller\\: BookCntl/);\n         expect(content).toMatch(/Book Id\\: Scarlet/);\n       });\n     </file>\n   </example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 14038,
            "ngdoc": "event",
            "name": "ng.directive:ngView#$viewContentLoaded",
            "eventof": "ng.directive:ngView",
            "eventtype": "emit on the current ngView scope",
            "description": "Emitted every time the ngView content is reloaded.",
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 14106,
            "ngdoc": "directive",
            "name": "ng.directive:script",
            "description": "Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the\ntemplate can be used by `ngInclude`, `ngView` or directive templates.",
            "restrict": "E",
            "params": [
                {
                    "name": "type",
                    "description": "must be set to `'text/ng-template'`",
                    "type": "'text/ng-template'"
                }
            ],
            "example": [
                "\n <doc:example>\n   <doc:source>\n     <script type=\"text/ng-template\" id=\"/tpl.html\">\n       Content of the template.\n     </script>\n\n     <a ng-click=\"currentTpl='/tpl.html'\" id=\"tpl-link\">Load inlined template</a>\n     <div id=\"tpl-content\" ng-include src=\"currentTpl\"></div>\n   </doc:source>\n   <doc:scenario>\n     it('should load template defined inside script tag', function() {\n       element('#tpl-link').click();\n       expect(element('#tpl-content').text()).toMatch(/Content of the template/);\n     });\n   </doc:scenario>\n </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\angular\\impl\\angular.js",
            "line": 14151,
            "ngdoc": "directive",
            "name": "ng.directive:select",
            "restrict": "E",
            "description": "HTML `SELECT` element with angular data-binding.\n\n# `ngOptions`\n\nOptionally `ngOptions` attribute can be used to dynamically generate a list of `<option>`\nelements for a `<select>` element using an array or an object obtained by evaluating the\n`ngOptions` expression.\n˝˝\nWhen an item in the select menu is select, the value of array element or object property\nrepresented by the selected option will be bound to the model identified by the `ngModel`\ndirective of the parent select element.\n\nOptionally, a single hard-coded `<option>` element, with the value set to an empty string, can\nbe nested into the `<select>` element. This element will then represent `null` or \"not selected\"\noption. See example below for demonstration.\n\nNote: `ngOptions` provides iterator facility for `<option>` element which should be used instead\nof {@link ng.directive:ngRepeat ngRepeat} when you want the\n`select` model to be bound to a non-string value. This is because an option element can currently\nbe bound to string values only.",
            "params": [
                {
                    "name": "name",
                    "description": "assignable expression to data-bind to.",
                    "type": "String"
                },
                {
                    "name": "required",
                    "description": "The control is considered valid only if value is entered.",
                    "type": "String="
                },
                {
                    "name": "ngRequired",
                    "description": "Adds `required` attribute and `required` validation constraint to\n   the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   `required` when you want to data-bind to the `required` attribute.",
                    "type": "String="
                },
                {
                    "name": "ngOptions",
                    "description": "in one of the following forms:\n\n  * for array data sources:\n    * `label` **`for`** `value` **`in`** `array`\n    * `select` **`as`** `label` **`for`** `value` **`in`** `array`\n    * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`\n    * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array`\n  * for object data sources:\n    * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`\n    * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`\n    * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`\n    * `select` **`as`** `label` **`group by`** `group`\n        **`for` `(`**`key`**`,`** `value`**`) in`** `object`\n\nWhere:\n\n  * `array` / `object`: an expression which evaluates to an array / object to iterate over.\n  * `value`: local variable which will refer to each item in the `array` or each property value\n     of `object` during iteration.\n  * `key`: local variable which will refer to a property name in `object` during iteration.\n  * `label`: The result of this expression will be the label for `<option>` element. The\n    `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).\n  * `select`: The result of this expression will be bound to the model of the parent `<select>`\n     element. If not specified, `select` expression will default to `value`.\n  * `group`: The result of this expression will be used to group options using the `<optgroup>`\n     DOM element.",
                    "type": "Comprehension_expression="
                }
            ],
            "example": [
                "\n   <doc:example>\n     <doc:source>\n       <script>\n       function MyCntrl($scope) {\n         $scope.colors = [\n           {name:'black', shade:'dark'},\n           {name:'white', shade:'light'},\n           {name:'red', shade:'dark'},\n           {name:'blue', shade:'dark'},\n           {name:'yellow', shade:'light'}\n         ];\n         $scope.color = $scope.colors[2]; // red\n       }\n       </script>\n       <div ng-controller=\"MyCntrl\">\n         <ul>\n           <li ng-repeat=\"color in colors\">\n             Name: <input ng-model=\"color.name\">\n             [<a href ng-click=\"colors.splice($index, 1)\">X</a>]\n           </li>\n           <li>\n             [<a href ng-click=\"colors.push({})\">add</a>]\n           </li>\n         </ul>\n         <hr/>\n         Color (null not allowed):\n         <select ng-model=\"color\" ng-options=\"c.name for c in colors\"></select><br>\n\n         Color (null allowed):\n         <span  class=\"nullable\">\n           <select ng-model=\"color\" ng-options=\"c.name for c in colors\">\n             <option value=\"\">-- chose color --</option>\n           </select>\n         </span><br/>\n\n         Color grouped by shade:\n         <select ng-model=\"color\" ng-options=\"c.name group by c.shade for c in colors\">\n         </select><br/>\n\n\n         Select <a href ng-click=\"color={name:'not in list'}\">bogus</a>.<br>\n         <hr/>\n         Currently selected: {{ {selected_color:color}  }}\n         <div style=\"border:solid 1px black; height:20px\"\n              ng-style=\"{'background-color':color.name}\">\n         </div>\n       </div>\n     </doc:source>\n     <doc:scenario>\n        it('should check ng-options', function() {\n          expect(binding('{selected_color:color}')).toMatch('red');\n          select('color').option('0');\n          expect(binding('{selected_color:color}')).toMatch('black');\n          using('.nullable').select('color').option('');\n          expect(binding('{selected_color:color}')).toMatch('null');\n        });\n     </doc:scenario>\n   </doc:example>"
            ],
            "class": ""
        },
        {
            "file": "lib\\jquery\\impl\\jquery-1.9.1.js",
            "line": 3837,
            "description": "For feature detection",
            "params": [
                {
                    "name": "fn",
                    "description": "The function to test for native support",
                    "type": "Function"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\jquery\\impl\\jquery-1.9.1.js",
            "line": 3845,
            "description": "Create key-value caches of limited size",
            "return": {
                "description": "Returns the Object data after storing it on itself with\n\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n\tdeleting the oldest entry",
                "type": "Function(string, Object)"
            },
            "class": ""
        },
        {
            "file": "lib\\jquery\\impl\\jquery-1.9.1.js",
            "line": 3865,
            "description": "Mark a function for special use by Sizzle",
            "params": [
                {
                    "name": "fn",
                    "description": "The function to mark",
                    "type": "Function"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\jquery\\impl\\jquery-1.9.1.js",
            "line": 3874,
            "description": "Support testing using an element",
            "params": [
                {
                    "name": "fn",
                    "description": "Passed the created div and expects a boolean result",
                    "type": "Function"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\jquery\\impl\\jquery-1.9.1.js",
            "line": 4001,
            "description": "Detect xml",
            "params": [
                {
                    "name": "elem",
                    "description": "An element or a document",
                    "type": "Element|Object"
                }
            ],
            "class": ""
        },
        {
            "file": "lib\\jquery\\impl\\jquery-1.9.1.js",
            "line": 4012,
            "description": "Sets document-related variables once based on the current document",
            "params": [
                {
                    "name": "doc",
                    "description": "An element or document object to use to set the document",
                    "type": "Element|Object",
                    "optional": true
                }
            ],
            "return": {
                "description": "Returns the current document",
                "type": "Object"
            },
            "class": ""
        },
        {
            "file": "lib\\jquery\\impl\\jquery-1.9.1.js",
            "line": 4505,
            "description": "Utility function for retrieving the text value of an array of DOM nodes",
            "params": [
                {
                    "name": "elem",
                    "description": "",
                    "type": "Array|Element"
                }
            ],
            "class": ""
        }
    ],
    "warnings": [
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:5"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:5"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " build\\src\\route.js:5"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:21"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:21"
        },
        {
            "message": "unknown tag: methodof",
            "line": " build\\src\\route.js:21"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " build\\src\\route.js:21"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:50"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:50"
        },
        {
            "message": "unknown tag: methodof",
            "line": " build\\src\\route.js:50"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " build\\src\\route.js:50"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:150"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:150"
        },
        {
            "message": "unknown tag: methodof",
            "line": " build\\src\\route.js:150"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " build\\src\\route.js:150"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:391"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:391"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:515"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:515"
        },
        {
            "message": "unknown tag: eventof",
            "line": " build\\src\\route.js:515"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " build\\src\\route.js:515"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:530"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:530"
        },
        {
            "message": "unknown tag: eventof",
            "line": " build\\src\\route.js:530"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " build\\src\\route.js:530"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:543"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:543"
        },
        {
            "message": "unknown tag: eventof",
            "line": " build\\src\\route.js:543"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " build\\src\\route.js:543"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\src\\route.js:555"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\src\\route.js:555"
        },
        {
            "message": "unknown tag: eventof",
            "line": " build\\src\\route.js:555"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " build\\src\\route.js:555"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:23"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:23"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " build\\angular-routing.js:23"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:39"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:39"
        },
        {
            "message": "unknown tag: methodof",
            "line": " build\\angular-routing.js:39"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " build\\angular-routing.js:39"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:68"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:68"
        },
        {
            "message": "unknown tag: methodof",
            "line": " build\\angular-routing.js:68"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " build\\angular-routing.js:68"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:168"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:168"
        },
        {
            "message": "unknown tag: methodof",
            "line": " build\\angular-routing.js:168"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " build\\angular-routing.js:168"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:409"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:409"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:533"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:533"
        },
        {
            "message": "unknown tag: eventof",
            "line": " build\\angular-routing.js:533"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " build\\angular-routing.js:533"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:548"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:548"
        },
        {
            "message": "unknown tag: eventof",
            "line": " build\\angular-routing.js:548"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " build\\angular-routing.js:548"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:561"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:561"
        },
        {
            "message": "unknown tag: eventof",
            "line": " build\\angular-routing.js:561"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " build\\angular-routing.js:561"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " build\\angular-routing.js:573"
        },
        {
            "message": "unknown tag: name",
            "line": " build\\angular-routing.js:573"
        },
        {
            "message": "unknown tag: eventof",
            "line": " build\\angular-routing.js:573"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " build\\angular-routing.js:573"
        },
        {
            "message": "unknown tag: license",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1"
        },
        {
            "message": "unknown tag: fileoverview",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:308"
        },
        {
            "message": "unknown tag: license",
            "line": " lib\\angular\\impl\\angular-bootstrap.js:1"
        },
        {
            "message": "unknown tag: license",
            "line": " lib\\angular\\impl\\angular-mocks.js:1"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:9"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:9"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:18"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:97"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:97"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:121"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular-mocks.js:121"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:136"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:136"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:188"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:188"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:197"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:197"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:234"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:234"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:234"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:285"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:285"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:310"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:310"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:310"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:319"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:319"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular-mocks.js:319"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:328"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:328"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular-mocks.js:328"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:337"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:337"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular-mocks.js:337"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:346"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:346"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular-mocks.js:346"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:357"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:357"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:357"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:426"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:426"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:586"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:586"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:652"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:652"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:914"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:914"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:914"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:914"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:952"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:952"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:952"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:952"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:965"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:965"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:965"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:965"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:978"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:978"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:978"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:978"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:991"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:991"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:991"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:991"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1005"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1005"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1005"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1005"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1019"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1019"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1019"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1019"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1033"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1033"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1033"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1033"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1064"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1064"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1064"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1064"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1077"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1077"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1077"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1077"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1090"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1090"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1090"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1090"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1103"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1103"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1103"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1103"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1117"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1117"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1117"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1117"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1131"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1131"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1131"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1131"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1145"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1145"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1145"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1145"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1159"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1159"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1159"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1187"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1187"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1187"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1209"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1209"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1209"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1230"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1230"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1230"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1349"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1349"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1358"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1358"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1358"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1376"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1376"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1400"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1400"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1413"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1413"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1461"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1461"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1461"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1461"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1485"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1485"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1485"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1485"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1498"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1498"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1498"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1498"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1511"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1511"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1511"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1511"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1524"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1524"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1524"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1524"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1538"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1538"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1538"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1538"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1552"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1552"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1552"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1552"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1566"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1566"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular-mocks.js:1566"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-mocks.js:1566"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1651"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1651"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-mocks.js:1685"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-mocks.js:1685"
        },
        {
            "message": "unknown tag: license",
            "line": " lib\\angular\\impl\\angular-resource.js:1"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-resource.js:9"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-resource.js:9"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular-resource.js:15"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular-resource.js:15"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular-resource.js:15"
        },
        {
            "message": "unknown tag: license",
            "line": " lib\\angular\\impl\\angular.js:1"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:11"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:11"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:23"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:23"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:23"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:23"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:72"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:72"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:72"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:72"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:167"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:176"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:206"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:206"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:206"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:239"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:239"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:239"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:258"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:258"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:258"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:279"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:279"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:279"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:279"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:293"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:293"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:293"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:293"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:307"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:307"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:307"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:307"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:322"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:322"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:322"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:322"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:336"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:336"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:336"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:336"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:350"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:350"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:350"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:350"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:366"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:366"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:366"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:366"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:382"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:382"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:382"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:382"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:396"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:427"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:427"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:427"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:427"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:444"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:478"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:537"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:537"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:537"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:537"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:607"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:607"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:607"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:607"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:678"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:678"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:678"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:678"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:731"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:731"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:731"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:731"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:748"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:748"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:748"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:748"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:776"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:803"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:868"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:868"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:868"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:940"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:940"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:940"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1020"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1020"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1038"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1038"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:1038"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1107"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1107"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular.js:1107"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:1107"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1117"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1117"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular.js:1117"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:1117"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1127"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1127"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1127"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1138"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1138"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1138"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1149"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1149"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1149"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1160"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1160"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1160"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1171"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1171"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1171"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1183"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1183"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1183"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1194"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1194"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1194"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1205"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1205"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1205"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1217"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1217"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1217"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1228"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1228"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:1228"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:1250"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1268"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1268"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:1403"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:1403"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:1403"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:1403"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2162"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2208"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2227"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2271"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2271"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:2271"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2271"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2301"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2301"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2343"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2343"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:2343"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2395"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2395"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2395"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2407"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2407"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2407"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2407"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2422"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2422"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2422"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2422"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2436"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2436"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2436"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2436"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2518"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2518"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2568"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2568"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2568"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2568"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2587"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2587"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2587"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2587"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2602"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2602"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2602"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2602"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2616"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2616"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2616"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2616"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2630"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2630"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2630"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:2630"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2646"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2646"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:2646"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:2873"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2873"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:2940"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3026"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:3026"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3026"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3066"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:3066"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3122"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:3122"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3169"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3187"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:3187"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3187"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3246"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:3246"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3246"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3273"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:3273"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3273"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:3301"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3301"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3301"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:3456"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3456"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:3493"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3493"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:3493"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3493"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:3614"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3614"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:3614"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:3631"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3631"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:3631"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:3631"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3631"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:3682"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:3682"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:3682"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:3682"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3682"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3790"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:3876"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4040"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4354"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4619"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4619"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4631"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4631"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular.js:4631"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4631"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4640"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4640"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:4640"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:4640"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4677"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4677"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4691"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4691"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:4691"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4710"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4710"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4748"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4748"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4763"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4763"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4789"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4789"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:4789"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4802"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4802"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:4802"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4802"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4821"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4821"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:4821"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4821"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4845"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4845"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:4845"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4845"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4933"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4933"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:4933"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4933"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:4950"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:4950"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:4950"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4950"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:4976"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5193"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5193"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5193"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5208"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5208"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5208"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5235"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5235"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5235"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5249"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5249"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5249"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5263"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5263"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5263"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5277"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5277"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5277"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5299"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5299"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5299"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5335"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5335"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5335"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5352"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5352"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5352"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5402"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5402"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5431"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5431"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5441"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5441"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5441"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:5441"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5458"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5458"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5458"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:5458"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5587"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5587"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5623"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5623"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5623"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5633"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5633"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5633"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5643"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5643"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5643"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:5653"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:5653"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:5653"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:6364"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:6515"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:6515"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:6515"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:6515"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:6567"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:6567"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:6725"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:6735"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:6735"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:6735"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:6735"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:6825"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:6825"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:6825"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:6825"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:6873"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:6873"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:6873"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:6873"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:6936"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:6936"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:6936"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:6936"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:6981"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:6981"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:6981"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:6993"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:6993"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:6993"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:6993"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7071"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7071"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7071"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:7071"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7092"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7092"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7217"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7217"
        },
        {
            "message": "unknown tag: eventof",
            "line": " lib\\angular\\impl\\angular.js:7217"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " lib\\angular\\impl\\angular.js:7217"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7233"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7233"
        },
        {
            "message": "unknown tag: eventof",
            "line": " lib\\angular\\impl\\angular.js:7233"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " lib\\angular\\impl\\angular.js:7233"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7247"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7247"
        },
        {
            "message": "unknown tag: eventof",
            "line": " lib\\angular\\impl\\angular.js:7247"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " lib\\angular\\impl\\angular.js:7247"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7260"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7260"
        },
        {
            "message": "unknown tag: eventof",
            "line": " lib\\angular\\impl\\angular.js:7260"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " lib\\angular\\impl\\angular.js:7260"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7275"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7275"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7275"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:7410"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:7428"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7449"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7449"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7504"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7504"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7512"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7512"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7512"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7527"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7527"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7549"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7549"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:7549"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7618"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7618"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular.js:7618"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:7618"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7628"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7628"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7628"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:7628"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:7628"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7687"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7687"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7687"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:7687"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:7687"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7791"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7791"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7791"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:7791"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7916"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7916"
        },
        {
            "message": "unknown tag: eventof",
            "line": " lib\\angular\\impl\\angular.js:7916"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " lib\\angular\\impl\\angular.js:7916"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7926"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7926"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7926"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:7926"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7965"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7965"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7965"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:7965"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:7965"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:7996"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:7996"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:7996"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:7996"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8024"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8024"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8024"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:8024"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8024"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8087"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8087"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8087"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:8087"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8087"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8125"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8125"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8125"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:8125"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8191"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8191"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8191"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:8191"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8294"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8339"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8339"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8366"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8395"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8422"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8499"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8499"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8499"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8896"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8896"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8896"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8896"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8909"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8909"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8909"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8909"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8922"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8922"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8922"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8922"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8935"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8935"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8935"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8935"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8950"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8950"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8950"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8950"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8964"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8964"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:8964"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:8964"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:8979"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:8979"
        },
        {
            "message": "unknown tag: propertyof",
            "line": " lib\\angular\\impl\\angular.js:8979"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9140"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9140"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9281"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9281"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9358"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9358"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:9358"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9412"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9412"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:9412"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:9412"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9437"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9437"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9485"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9485"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:9485"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9497"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9497"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:9497"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9539"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9539"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:9539"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9702"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9702"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:9702"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:9702"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9753"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9753"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:9753"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:9753"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:9952"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:9952"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:9952"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:9952"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10100"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10100"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:10100"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:10100"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10135"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10135"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:10135"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10146"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10146"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:10146"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10156"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10156"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:10156"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:10156"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10242"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10242"
        },
        {
            "message": "replacing incorrect tag: function with method",
            "line": " lib\\angular\\impl\\angular.js:10242"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\angular\\impl\\angular.js:10242"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10388"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10388"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10388"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10431"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10431"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10431"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:10431"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10511"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10511"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10511"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:10511"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10536"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10536"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10536"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:10536"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10575"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10575"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10575"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:10575"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10605"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10605"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10605"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:10605"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10641"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10641"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10641"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:10641"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10671"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10671"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10671"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:10671"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10756"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10756"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10871"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10871"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10871"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:10886"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:10886"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:10886"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11042"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11042"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11111"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11111"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11182"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11182"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11250"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11250"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11316"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11316"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11357"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11357"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11673"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11673"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:11673"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11701"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11701"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:11701"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11814"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11814"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11930"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11930"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:11930"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:11958"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:11958"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:11958"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12000"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12000"
        },
        {
            "message": "unknown tag: methodof",
            "line": " lib\\angular\\impl\\angular.js:12000"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12071"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12071"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12071"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12123"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12123"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:12123"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12123"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12209"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12209"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12209"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12306"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12306"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12306"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12361"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12361"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12361"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12420"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12420"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12420"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12501"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12501"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12501"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12552"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12552"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12552"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12599"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12599"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12599"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12646"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12646"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12646"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12706"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12706"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12706"
        },
        {
            "message": "unknown tag: scope",
            "line": " lib\\angular\\impl\\angular.js:12706"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12808"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12808"
        },
        {
            "message": "unknown tag: priority",
            "line": " lib\\angular\\impl\\angular.js:12808"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12808"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12834"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12834"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12834"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12887"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12887"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12887"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12903"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12903"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12903"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12919"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12919"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12919"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12934"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12934"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12934"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12950"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12950"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12950"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12966"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12966"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12966"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12982"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12982"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12982"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:12998"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:12998"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:12998"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13055"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13055"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:13055"
        },
        {
            "message": "unknown tag: scope",
            "line": " lib\\angular\\impl\\angular.js:13055"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13125"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13125"
        },
        {
            "message": "unknown tag: eventof",
            "line": " lib\\angular\\impl\\angular.js:13125"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " lib\\angular\\impl\\angular.js:13125"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13185"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13185"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:13185"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13221"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13221"
        },
        {
            "message": "unknown tag: priority",
            "line": " lib\\angular\\impl\\angular.js:13221"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:13221"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13253"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13253"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:13253"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13459"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13459"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:13459"
        },
        {
            "message": "unknown tag: scope",
            "line": " lib\\angular\\impl\\angular.js:13459"
        },
        {
            "message": "unknown tag: priority",
            "line": " lib\\angular\\impl\\angular.js:13459"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13647"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13647"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:13647"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13687"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13687"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:13687"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13726"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13726"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:13726"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13772"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13772"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:13772"
        },
        {
            "message": "unknown tag: usagecontent",
            "line": " lib\\angular\\impl\\angular.js:13772"
        },
        {
            "message": "unknown tag: scope",
            "line": " lib\\angular\\impl\\angular.js:13772"
        },
        {
            "message": "unknown tag: paramdescription",
            "line": " lib\\angular\\impl\\angular.js:13772"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13885"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13885"
        },
        {
            "message": "unknown tag: element",
            "line": " lib\\angular\\impl\\angular.js:13885"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:13942"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:13942"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:13942"
        },
        {
            "message": "unknown tag: scope",
            "line": " lib\\angular\\impl\\angular.js:13942"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:14038"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:14038"
        },
        {
            "message": "unknown tag: eventof",
            "line": " lib\\angular\\impl\\angular.js:14038"
        },
        {
            "message": "unknown tag: eventtype",
            "line": " lib\\angular\\impl\\angular.js:14038"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:14106"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:14106"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:14106"
        },
        {
            "message": "unknown tag: ngdoc",
            "line": " lib\\angular\\impl\\angular.js:14151"
        },
        {
            "message": "unknown tag: name",
            "line": " lib\\angular\\impl\\angular.js:14151"
        },
        {
            "message": "unknown tag: restrict",
            "line": " lib\\angular\\impl\\angular.js:14151"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:3845"
        },
        {
            "message": "replacing incorrect tag: returns with return",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:4012"
        },
        {
            "message": "Missing item type\nAdds a new converter or overwrites an existing one.\n\nBy default the folowing converters are precent:\n - `` - default Converter, used on all parameters that doesn't specify a converter.\n   Matches any input.\n\n - `num` - number converter, used to only mach numeric values.\n\n - `regex` - regular expressions converter, used to match a parameter agains a regular\n   expression.",
            "line": " build\\src\\route.js:21"
        },
        {
            "message": "Missing item type\nAdds a new route definition to the `$route` service.",
            "line": " build\\src\\route.js:50"
        },
        {
            "message": "Missing item type\nSets route definition that will be used on route change when no other route definition\nis matched.",
            "line": " build\\src\\route.js:150"
        },
        {
            "message": "Missing item type\nBroadcasted before a route change. At this  point the route services starts\nresolving all of the dependencies needed for the route change to occurs.\nTypically this involves fetching the view template as well as any dependencies\ndefined in `resolve` route property. Once  all of the dependencies are resolved\n`$routeChangeSuccess` is fired.",
            "line": " build\\src\\route.js:515"
        },
        {
            "message": "Missing item type\nBroadcasted after a route dependencies are resolved.\n{@link ng.directive:ngView ngView} listens for the directive\nto instantiate the controller and render the view.",
            "line": " build\\src\\route.js:530"
        },
        {
            "message": "Missing item type\nBroadcasted if any of the resolve promises are rejected.",
            "line": " build\\src\\route.js:543"
        },
        {
            "message": "Missing item type\nThe `reloadOnSearch` property has been set to false, and we are reusing the same\ninstance of the Controller.",
            "line": " build\\src\\route.js:555"
        },
        {
            "message": "Missing item type\nAdds a new converter or overwrites an existing one.\n\nBy default the folowing converters are precent:\n - `` - default Converter, used on all parameters that doesn't specify a converter.\n   Matches any input.\n\n - `num` - number converter, used to only mach numeric values.\n\n - `regex` - regular expressions converter, used to match a parameter agains a regular\n   expression.",
            "line": " build\\angular-routing.js:39"
        },
        {
            "message": "Missing item type\nAdds a new route definition to the `$route` service.",
            "line": " build\\angular-routing.js:68"
        },
        {
            "message": "Missing item type\nSets route definition that will be used on route change when no other route definition\nis matched.",
            "line": " build\\angular-routing.js:168"
        },
        {
            "message": "Missing item type\nBroadcasted before a route change. At this  point the route services starts\nresolving all of the dependencies needed for the route change to occurs.\nTypically this involves fetching the view template as well as any dependencies\ndefined in `resolve` route property. Once  all of the dependencies are resolved\n`$routeChangeSuccess` is fired.",
            "line": " build\\angular-routing.js:533"
        },
        {
            "message": "Missing item type\nBroadcasted after a route dependencies are resolved.\n{@link ng.directive:ngView ngView} listens for the directive\nto instantiate the controller and render the view.",
            "line": " build\\angular-routing.js:548"
        },
        {
            "message": "Missing item type\nBroadcasted if any of the resolve promises are rejected.",
            "line": " build\\angular-routing.js:561"
        },
        {
            "message": "Missing item type\nThe `reloadOnSearch` property has been set to false, and we are reusing the same\ninstance of the Controller.",
            "line": " build\\angular-routing.js:573"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1"
        },
        {
            "message": "Missing item type\nhttp://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\nhttp://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:28"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:308"
        },
        {
            "message": "Missing item type\nSplit {@code prettyPrint} into multiple timeouts so as not to interfere with\nUI events.\nIf set to {@code false}, {@code prettyPrint()} is synchronous.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:350"
        },
        {
            "message": "Missing item type\nFind all the {@code <pre>} and {@code <code>} tags in the DOM with\n{@code class=prettyprint} and prettify them.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:357"
        },
        {
            "message": "Missing item type\nPretty print a chunk of code.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:365"
        },
        {
            "message": "Missing item type\nGiven a group of {@link RegExp}s, returns a {@code RegExp} that globally\nmatches the union of the sets of strings matched by the input RegExp.\nSince it matches globally, if the input strings have a start-of-input\nanchor (/^.../), it is ignored for the purposes of unioning.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:524"
        },
        {
            "message": "Missing item type\nSplit markup into a string of source code and an array mapping ranges in\nthat string to the text nodes in which they appear.\n\n<p>\nThe HTML DOM structure:</p>\n<pre>\n(Element   \"p\"\n  (Element \"b\"\n    (Text  \"print \"))       ; #1\n  (Text    \"'Hello '\")      ; #2\n  (Element \"br\")            ; #3\n  (Text    \"  + 'World';\")) ; #4\n</pre>\n<p>\ncorresponds to the HTML\n{@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n\n<p>\nIt will produce the output:</p>\n<pre>\n{\n  sourceCode: \"print 'Hello '\\n  + 'World';\",\n  //                     1          2\n  //           012345678901234 5678901234567\n  spans: [0, #1, 6, #2, 14, #3, 15, #4]\n}\n</pre>\n<p>\nwhere #1 is a reference to the {@code \"print \"} text node above, and so\non for the other text nodes.\n</p>\n\n<p>\nThe {@code} spans array is an array of pairs.  Even elements are the start\nindices of substrings, and odd elements are the text nodes (or BR elements)\nthat contain the text for those substrings.\nSubstrings continue until the next index or the end of the source.\n</p>",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:766"
        },
        {
            "message": "Missing item type\nApply the given language handler to sourceCode and add the resulting\ndecorations to out.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:860"
        },
        {
            "message": "Missing item type\nGiven an element, if it contains only one child element and any text nodes\nit contains contain only space characters, return the sole child element.\nOtherwise returns undefined.\n<p>\nThis is meant to return the CODE element in {@code <pre><code ...>} when\nthere is a single child element that contains all the non-space textual\ncontent, but not to return anything where there are multiple child elements\nas in {@code <pre><code>...</code><code>...</code></pre>} or when there\nis textual content.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:878"
        },
        {
            "message": "Missing item type\nThe lexing function interprets the patterns to find token boundaries and\nreturns a decoration list of the form\n[index_0, style_0, index_1, style_1, ..., index_n, style_n]\nwhere index_n is an index into the sourceCode, and style_n is a style\nconstant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\nall characters in sourceCode[index_n-1:index_n].\n\nThe stylePatterns is a list whose elements have the form\n[style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n\nStyle is a style constant like PR_PLAIN, or can be a string of the\nform 'lang-FOO', where FOO is a language extension describing the\nlanguage of the portion of the token in $1 after pattern executes.\nE.g., if style is 'lang-lisp', and group 1 contains the text\n'(hello (world))', then that portion of the token will be passed to the\nregistered lisp handler for formatting.\nThe text before and after group 1 will be restyled using this decorator\nso decorators should take care that this doesn't result in infinite\nrecursion.  For example, the HTML lexer rule for SCRIPT elements looks\nsomething like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n'<script>foo()<\\/script>', which would cause the current decorator to\nbe called with '<script>' which would not match the same rule since\ngroup 1 must not be empty, so it would be instead styled as PR_TAG by\nthe generic tag rule.  The handler registered for the 'js' extension would\nthen be called with 'foo()', and finally, the current decorator would\nbe called with '<\\/script>' which would not match the original rule and\nso the generic tag rule would identify it as a tag.\n\nPattern must only match prefixes, and if it matches a prefix, then that\nmatch is considered a token with the same style.\n\nContext is applied to the last non-whitespace, non-comment token\nrecognized.\n\nShortcut is an optional string of characters, any of which, if the first\ncharacter, gurantee that this pattern and only this pattern matches.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:902"
        },
        {
            "message": "Missing item type\nLexes job.sourceCode and produces an output array job.decorations of\nstyle classes preceded by the position at which they start in\njob.sourceCode in order.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:976"
        },
        {
            "message": "Missing item type\nare style markers (e.g., PR_COMMENT) that run from that position until\nthe end.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:989"
        },
        {
            "message": "Missing item type\nThis code treats \", ', and ` as string delimiters, and \\ as a string\n escape.  It does not recognize perl's qq() style strings.\n It has no special handling for double delimiter escapes as in basic, or\n the tripled delimiters used in python, but should work on those regardless\n although in those cases a single string literal may be broken up into\n multiple adjacent string literals.\nIt recognizes C, C++, and shell style comments.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1076"
        },
        {
            "message": "Missing item type\nGiven a DOM subtree, wraps it in a list, and puts each line into its own\nlist item.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1211"
        },
        {
            "message": "Missing item type\nBreaks {@code job.sourceCode} around style boundaries in\n{@code job.decorations} and modifies {@code job.sourceNode} in place.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1350"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1474"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1476"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1618"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1637"
        },
        {
            "message": "Missing item type\nContains functions for creating and registering new language handlers.",
            "line": " lib\\angular\\impl\\angular-bootstrap-prettify.js:1788"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-bootstrap.js:1"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-mocks.js:1"
        },
        {
            "message": "Missing item type\nNamespace from 'angular-mocks.js' which contains testing related code.",
            "line": " lib\\angular\\impl\\angular-mocks.js:9"
        },
        {
            "message": "Missing item type\nThis service is a mock implementation of {@link ng.$browser}. It provides fake\nimplementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,\ncookies, etc...\n\nThe api of this service is the same as that of the real {@link ng.$browser $browser}, except\nthat there are several helper methods available which can be used in tests.",
            "line": " lib\\angular\\impl\\angular-mocks.js:18"
        },
        {
            "message": "Missing item type\nFlushes all pending requests and executes the defer callbacks.",
            "line": " lib\\angular\\impl\\angular-mocks.js:97"
        },
        {
            "message": "Missing item type\nCurrent milliseconds mock time.",
            "line": " lib\\angular\\impl\\angular-mocks.js:121"
        },
        {
            "message": "Missing item type\nrun all fns in pollFns",
            "line": " lib\\angular\\impl\\angular-mocks.js:136"
        },
        {
            "message": "Missing item type\nConfigures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors passed\ninto the `$exceptionHandler`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:188"
        },
        {
            "message": "Missing item type\nMock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed\ninto it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration\ninformation.\n\n\n<pre>\n  describe('$exceptionHandlerProvider', function() {\n\n    it('should capture log messages and exceptions', function() {\n\n      module(function($exceptionHandlerProvider) {\n        $exceptionHandlerProvider.mode('log');\n      });\n\n      inject(function($log, $exceptionHandler, $timeout) {\n        $timeout(function() { $log.log(1); });\n        $timeout(function() { $log.log(2); throw 'banana peel'; });\n        $timeout(function() { $log.log(3); });\n        expect($exceptionHandler.errors).toEqual([]);\n        expect($log.assertEmpty());\n        $timeout.flush();\n        expect($exceptionHandler.errors).toEqual(['banana peel']);\n        expect($log.log.logs).toEqual([[1], [2], [3]]);\n      });\n    });\n  });\n</pre>",
            "line": " lib\\angular\\impl\\angular-mocks.js:197"
        },
        {
            "message": "Missing item type\nSets the logging mode.",
            "line": " lib\\angular\\impl\\angular-mocks.js:234"
        },
        {
            "message": "Missing item type\nMock implementation of {@link ng.$log} that gathers all logged messages in arrays\n(one array per logging level). These arrays are exposed as `logs` property of each of the\nlevel-specific log function, e.g. for level `error` the array is exposed as `$log.error.logs`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:285"
        },
        {
            "message": "Missing item type\nReset all of the logging arrays to empty.",
            "line": " lib\\angular\\impl\\angular-mocks.js:310"
        },
        {
            "message": "Missing item type\nArray of logged messages.",
            "line": " lib\\angular\\impl\\angular-mocks.js:319"
        },
        {
            "message": "Missing item type\nArray of logged messages.",
            "line": " lib\\angular\\impl\\angular-mocks.js:328"
        },
        {
            "message": "Missing item type\nArray of logged messages.",
            "line": " lib\\angular\\impl\\angular-mocks.js:337"
        },
        {
            "message": "Missing item type\nArray of logged messages.",
            "line": " lib\\angular\\impl\\angular-mocks.js:346"
        },
        {
            "message": "Missing item type\nAssert that the all of the logging methods have no logged messages. If messages present, an exception is thrown.",
            "line": " lib\\angular\\impl\\angular-mocks.js:357"
        },
        {
            "message": "Missing item type\n*NOTE*: this is not an injectable instance, just a globally available mock class of `Date`.\n\nMock of the Date type which has its timezone specified via constroctor arg.\n\nThe main purpose is to create Date-like instances with timezone fixed to the specified timezone\noffset, so that we can test code that depends on local timezone settings without dependency on\nthe time zone settings of the machine where the code is running.",
            "line": " lib\\angular\\impl\\angular-mocks.js:426"
        },
        {
            "message": "Missing item type\n*NOTE*: this is not an injectable instance, just a globally available function.\n\nMethod for serializing common angular objects (scope, elements, etc..) into strings, useful for debugging.\n\nThis method is also available on window, where it can be used to display objects on debug console.",
            "line": " lib\\angular\\impl\\angular-mocks.js:586"
        },
        {
            "message": "Missing item type\nFake HTTP backend implementation suitable for unit testing application that use the\n{@link ng.$http $http service}.\n\n*Note*: For fake http backend implementation suitable for end-to-end testing or backend-less\ndevelopment please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.\n\nDuring unit testing, we want our unit tests to run quickly and have no external dependencies so\nwe don’t want to send {@link https://developer.mozilla.org/en/xmlhttprequest XHR} or\n{@link http://en.wikipedia.org/wiki/JSONP JSONP} requests to a real server. All we really need is\nto verify whether a certain request has been sent or not, or alternatively just let the\napplication make requests, respond with pre-trained responses and assert that the end result is\nwhat we expect it to be.\n\nThis mock implementation can be used to respond with static or dynamic responses via the\n`expect` and `when` apis and their shortcuts (`expectGET`, `whenPOST`, etc).\n\nWhen an Angular application needs some data from a server, it calls the $http service, which\nsends the request to a real server using $httpBackend service. With dependency injection, it is\neasy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify\nthe requests and respond with some testing data without sending a request to real server.\n\nThere are two ways to specify what test data should be returned as http responses by the mock\nbackend when the code under test makes http requests:\n\n- `$httpBackend.expect` - specifies a request expectation\n- `$httpBackend.when` - specifies a backend definition\n\n\n# Request Expectations vs Backend Definitions\n\nRequest expectations provide a way to make assertions about requests made by the application and\nto define responses for those requests. The test will fail if the expected requests are not made\nor they are made in the wrong order.\n\nBackend definitions allow you to define a fake backend for your application which doesn't assert\nif a particular request was made or not, it just returns a trained response if a request is made.\nThe test will pass whether or not the request gets made during testing.\n\n\n<table class=\"table\">\n  <tr><th width=\"220px\"></th><th>Request expectations</th><th>Backend definitions</th></tr>\n  <tr>\n    <th>Syntax</th>\n    <td>.expect(...).respond(...)</td>\n    <td>.when(...).respond(...)</td>\n  </tr>\n  <tr>\n    <th>Typical usage</th>\n    <td>strict unit tests</td>\n    <td>loose (black-box) unit testing</td>\n  </tr>\n  <tr>\n    <th>Fulfills multiple requests</th>\n    <td>NO</td>\n    <td>YES</td>\n  </tr>\n  <tr>\n    <th>Order of requests matters</th>\n    <td>YES</td>\n    <td>NO</td>\n  </tr>\n  <tr>\n    <th>Request required</th>\n    <td>YES</td>\n    <td>NO</td>\n  </tr>\n  <tr>\n    <th>Response required</th>\n    <td>optional (see below)</td>\n    <td>YES</td>\n  </tr>\n</table>\n\nIn cases where both backend definitions and request expectations are specified during unit\ntesting, the request expectations are evaluated first.\n\nIf a request expectation has no response specified, the algorithm will search your backend\ndefinitions for an appropriate response.\n\nIf a request didn't match any expectation or if the expectation doesn't have the response\ndefined, the backend definitions are evaluated in sequential order to see if any of them match\nthe request. The response from the first matched definition is returned.\n\n\n# Flushing HTTP requests\n\nThe $httpBackend used in production, always responds to requests with responses asynchronously.\nIf we preserved this behavior in unit testing, we'd have to create async unit tests, which are\nhard to write, follow and maintain. At the same time the testing mock, can't respond\nsynchronously because that would change the execution of the code under test. For this reason the\nmock $httpBackend has a `flush()` method, which allows the test to explicitly flush pending\nrequests and thus preserving the async api of the backend, while allowing the test to execute\nsynchronously.\n\n\n# Unit testing with mock $httpBackend\n\n<pre>\n  // controller\n  function MyController($scope, $http) {\n    $http.get('/auth.py').success(function(data) {\n      $scope.user = data;\n    });\n\n    this.saveMessage = function(message) {\n      $scope.status = 'Saving...';\n      $http.post('/add-msg.py', message).success(function(response) {\n        $scope.status = '';\n      }).error(function() {\n        $scope.status = 'ERROR!';\n      });\n    };\n  }\n\n  // testing controller\n  var $httpBackend;\n\n  beforeEach(inject(function($injector) {\n    $httpBackend = $injector.get('$httpBackend');\n\n    // backend definition common for all tests\n    $httpBackend.when('GET', '/auth.py').respond({userId: 'userX'}, {'A-Token': 'xxx'});\n  }));\n\n\n  afterEach(function() {\n    $httpBackend.verifyNoOutstandingExpectation();\n    $httpBackend.verifyNoOutstandingRequest();\n  });\n\n\n  it('should fetch authentication token', function() {\n    $httpBackend.expectGET('/auth.py');\n    var controller = scope.$new(MyController);\n    $httpBackend.flush();\n  });\n\n\n  it('should send msg to server', function() {\n    // now you don’t care about the authentication, but\n    // the controller will still send the request and\n    // $httpBackend will respond without you having to\n    // specify the expectation and response for this request\n    $httpBackend.expectPOST('/add-msg.py', 'message content').respond(201, '');\n\n    var controller = scope.$new(MyController);\n    $httpBackend.flush();\n    controller.saveMessage('message content');\n    expect(controller.status).toBe('Saving...');\n    $httpBackend.flush();\n    expect(controller.status).toBe('');\n  });\n\n\n  it('should send auth header', function() {\n    $httpBackend.expectPOST('/add-msg.py', undefined, function(headers) {\n      // check if the header was send, if it wasn't the expectation won't\n      // match the request and the test will fail\n      return headers['Authorization'] == 'xxx';\n    }).respond(201, '');\n\n    var controller = scope.$new(MyController);\n    controller.saveMessage('whatever');\n    $httpBackend.flush();\n  });\n  </pre>",
            "line": " lib\\angular\\impl\\angular-mocks.js:652"
        },
        {
            "message": "Missing item type\nGeneral factory function for $httpBackend mock.\nReturns instance for unit testing (when no arguments specified):\n  - passing through is disabled\n  - auto flushing is disabled\n\nReturns instance for e2e testing (when `$delegate` and `$browser` specified):\n  - passing through (delegating request to real backend) is enabled\n  - auto flushing is enabled",
            "line": " lib\\angular\\impl\\angular-mocks.js:827"
        },
        {
            "message": "Missing item type\nCreates a new backend definition.",
            "line": " lib\\angular\\impl\\angular-mocks.js:914"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for GET requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:952"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for HEAD requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:965"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for DELETE requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:978"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for POST requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:991"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for PUT requests.  For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1005"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for JSONP requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1019"
        },
        {
            "message": "Missing item type\nCreates a new request expectation.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1033"
        },
        {
            "message": "Missing item type\nCreates a new request expectation for GET requests. For more info see `expect()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1064"
        },
        {
            "message": "Missing item type\nCreates a new request expectation for HEAD requests. For more info see `expect()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1077"
        },
        {
            "message": "Missing item type\nCreates a new request expectation for DELETE requests. For more info see `expect()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1090"
        },
        {
            "message": "Missing item type\nCreates a new request expectation for POST requests. For more info see `expect()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1103"
        },
        {
            "message": "Missing item type\nCreates a new request expectation for PUT requests. For more info see `expect()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1117"
        },
        {
            "message": "Missing item type\nCreates a new request expectation for PATCH requests. For more info see `expect()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1131"
        },
        {
            "message": "Missing item type\nCreates a new request expectation for JSONP requests. For more info see `expect()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1145"
        },
        {
            "message": "Missing item type\nFlushes all pending requests using the trained responses.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1159"
        },
        {
            "message": "Missing item type\nVerifies that all of the requests defined via the `expect` api were made. If any of the\nrequests were not made, verifyNoOutstandingExpectation throws an exception.\n\nTypically, you would call this method following each test case that asserts requests using an\n\"afterEach\" clause.\n\n<pre>\n  afterEach($httpBackend.verifyExpectations);\n</pre>",
            "line": " lib\\angular\\impl\\angular-mocks.js:1187"
        },
        {
            "message": "Missing item type\nVerifies that there are no outstanding requests that need to be flushed.\n\nTypically, you would call this method following each test case that asserts requests using an\n\"afterEach\" clause.\n\n<pre>\n  afterEach($httpBackend.verifyNoOutstandingRequest);\n</pre>",
            "line": " lib\\angular\\impl\\angular-mocks.js:1209"
        },
        {
            "message": "Missing item type\nResets all request expectations, but preserves all backend definitions. Typically, you would\ncall resetExpectations during a multiple-phase test when you want to reuse the same instance of\n$httpBackend mock.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1230"
        },
        {
            "message": "Missing item type\nThis service is just a simple decorator for {@link ng.$timeout $timeout} service\nthat adds a \"flush\" method.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1349"
        },
        {
            "message": "Missing item type\nFlushes the queue of pending tasks.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1358"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-mocks.js:1367"
        },
        {
            "message": "Missing item type\nThe `ngMock` is an angular module which is used with `ng` module and adds unit-test configuration as well as useful\nmocks to the {@link AUTO.$injector $injector}.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1376"
        },
        {
            "message": "Missing item type\nThe `ngMockE2E` is an angular module which contains mocks suitable for end-to-end testing.\nCurrently there is only one mock present in this module -\nthe {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1400"
        },
        {
            "message": "Missing item type\nFake HTTP backend implementation suitable for end-to-end testing or backend-less development of\napplications that use the {@link ng.$http $http service}.\n\n*Note*: For fake http backend implementation suitable for unit testing please see\n{@link ngMock.$httpBackend unit-testing $httpBackend mock}.\n\nThis implementation can be used to respond with static or dynamic responses via the `when` api\nand its shortcuts (`whenGET`, `whenPOST`, etc) and optionally pass through requests to the\nreal $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch\ntemplates from a webserver).\n\nAs opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application\nis being developed with the real backend api replaced with a mock, it is often desirable for\ncertain category of requests to bypass the mock and issue a real http request (e.g. to fetch\ntemplates or static files from the webserver). To configure the backend with this behavior\nuse the `passThrough` request handler of `when` instead of `respond`.\n\nAdditionally, we don't want to manually have to flush mocked out requests like we do during unit\ntesting. For this reason the e2e $httpBackend automatically flushes mocked out requests\nautomatically, closely simulating the behavior of the XMLHttpRequest object.\n\nTo setup the application to run with this http backend, you have to create a module that depends\non the `ngMockE2E` and your application modules and defines the fake backend:\n\n<pre>\n  myAppDev = angular.module('myAppDev', ['myApp', 'ngMockE2E']);\n  myAppDev.run(function($httpBackend) {\n    phones = [{name: 'phone1'}, {name: 'phone2'}];\n\n    // returns the current list of phones\n    $httpBackend.whenGET('/phones').respond(phones);\n\n    // adds a new phone to the phones array\n    $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\n      phones.push(angular.fromJSON(data));\n    });\n    $httpBackend.whenGET(/^\\/templates\\//).passThrough();\n    //...\n  });\n</pre>\n\nAfterwards, bootstrap your app with this new module.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1413"
        },
        {
            "message": "Missing item type\nCreates a new backend definition.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1461"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for GET requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1485"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for HEAD requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1498"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for DELETE requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1511"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for POST requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1524"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for PUT requests.  For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1538"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for PATCH requests.  For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1552"
        },
        {
            "message": "Missing item type\nCreates a new backend definition for JSONP requests. For more info see `when()`.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1566"
        },
        {
            "message": "Missing item type\nGlobal method to output any number of objects into JSTD console. Useful for debugging.",
            "line": " lib\\angular\\impl\\angular-mocks.js:1597"
        },
        {
            "message": "Missing item type\n*NOTE*: This is function is also published on window for easy access.<br>\n*NOTE*: Only available with {@link http://pivotal.github.com/jasmine/ jasmine}.\n\nThis function registers a module configuration code. It collects the configuration information\nwhich will be used when the injector is created by {@link angular.mock.inject inject}.\n\nSee {@link angular.mock.inject inject} for usage example",
            "line": " lib\\angular\\impl\\angular-mocks.js:1651"
        },
        {
            "message": "Missing item type\n*NOTE*: This is function is also published on window for easy access.<br>\n*NOTE*: Only available with {@link http://pivotal.github.com/jasmine/ jasmine}.\n\nThe inject function wraps a function into an injectable function. The inject() creates new\ninstance of {@link AUTO.$injector $injector} per test, which is then used for\nresolving references.\n\nSee also {@link angular.mock.module module}\n\nExample of what a typical jasmine tests looks like with the inject method.\n<pre>\n\n  angular.module('myApplicationModule', [])\n      .value('mode', 'app')\n      .value('version', 'v1.0.1');\n\n\n  describe('MyApp', function() {\n\n    // You need to load modules that you want to test,\n    // it loads only the \"ng\" module by default.\n    beforeEach(module('myApplicationModule'));\n\n\n    // inject() is used to inject arguments of all given functions\n    it('should provide a version', inject(function(mode, version) {\n      expect(version).toEqual('v1.0.1');\n      expect(mode).toEqual('app');\n    }));\n\n\n    // The inject and module method can also be used inside of the it or beforeEach\n    it('should override a version and test the new version is injected', function() {\n      // module() takes functions or strings (module aliases)\n      module(function($provide) {\n        $provide.value('version', 'overridden'); // override version here\n      });\n\n      inject(function(version) {\n        expect(version).toEqual('overridden');\n      });\n    ));\n  });\n\n</pre>",
            "line": " lib\\angular\\impl\\angular-mocks.js:1685"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-resource.js:1"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular-resource.js:9"
        },
        {
            "message": "Missing item type\nA factory which creates a resource object that lets you interact with\n[RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n\nThe returned resource object has action methods which provide high-level behaviors without\nthe need to interact with the low level {@link ng.$http $http} service.",
            "line": " lib\\angular\\impl\\angular-resource.js:15"
        },
        {
            "message": "Missing item type\nWe need our custom method because encodeURIComponent is too aggressive and doesn't follow\nhttp://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\nsegments:\n   segment       = *pchar\n   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
            "line": " lib\\angular\\impl\\angular-resource.js:235"
        },
        {
            "message": "Missing item type\nThis method is intended for encoding *key* or *value* parts of query component. We need a custom\nmethod becuase encodeURIComponent is too agressive and encodes stuff that doesn't have to be\nencoded per http://tools.ietf.org/html/rfc3986:\n   query       = *( pchar / \"/\" / \"?\" )\n   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
            "line": " lib\\angular\\impl\\angular-resource.js:254"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:1"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:66"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:101"
        },
        {
            "message": "Missing item type\nwhen using forEach the params are value, key, but it is often useful to have key, value.",
            "line": " lib\\angular\\impl\\angular.js:167"
        },
        {
            "message": "Missing item type\nA consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric\ncharacters such as '012ABC'. The reason why we are not using simply a number counter is that\nthe number string gets longer over time, and it can also overflow, where as the nextId\nwill grow much slower, it is a string, and it will never overflow.",
            "line": " lib\\angular\\impl\\angular.js:176"
        },
        {
            "message": "Missing item type\nChecks if `obj` is a window object.",
            "line": " lib\\angular\\impl\\angular.js:396"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:444"
        },
        {
            "message": "Missing item type\nDetermines the number of elements in an array, the number of properties an object has, or\nthe length of a string.\n\nNote: This function is used to augment the Object type in Angular expressions. See\n{@link angular.Object} for more information about Angular arrays.",
            "line": " lib\\angular\\impl\\angular.js:478"
        },
        {
            "message": "Missing item type\nCreate a shallow copy of an object",
            "line": " lib\\angular\\impl\\angular.js:591"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:776"
        },
        {
            "message": "Missing item type\nParses an escaped url query string into key-value pairs.",
            "line": " lib\\angular\\impl\\angular.js:803"
        },
        {
            "message": "Missing item type\nWe need our custom method because encodeURIComponent is too agressive and doesn't follow\nhttp://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\nsegments:\n   segment       = *pchar\n   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
            "line": " lib\\angular\\impl\\angular.js:828"
        },
        {
            "message": "Missing item type\nThis method is intended for encoding *key* or *value* parts of query component. We need a custom\nmethod becuase encodeURIComponent is too agressive and encodes stuff that doesn't have to be\nencoded per http://tools.ietf.org/html/rfc3986:\n   query       = *( pchar / \"/\" / \"?\" )\n   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n   pct-encoded   = \"%\" HEXDIG HEXDIG\n   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n                    / \"*\" / \"+\" / \",\" / \";\" / \"=\"",
            "line": " lib\\angular\\impl\\angular.js:847"
        },
        {
            "message": "Missing item type\nUse this directive to auto-bootstrap on application. Only\none directive can be used per HTML document. The directive\ndesignates the root of the application and is typically placed\nat the root of the page.\n\nIn the example below if the `ngApp` directive would not be placed\non the `html` element then the document would not be compiled\nand the `{{ 1+2 }}` would not be resolved to `3`.\n\n`ngApp` is the easiest way to bootstrap an application.\n\n<doc:example>\n  <doc:source>\n   I can add: 1 + 2 =  {{ 1+2 }}\n  </doc:source>\n</doc:example>",
            "line": " lib\\angular\\impl\\angular.js:868"
        },
        {
            "message": "Missing item type\nUse this function to manually start up angular application.\n\nSee: {@link guide/bootstrap Bootstrap}",
            "line": " lib\\angular\\impl\\angular.js:940"
        },
        {
            "message": "Missing item type\nthrow error of the argument is falsy.",
            "line": " lib\\angular\\impl\\angular.js:1000"
        },
        {
            "message": "Missing item type\nInterface for configuring angular {@link angular.module modules}.",
            "line": " lib\\angular\\impl\\angular.js:1020"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:1035"
        },
        {
            "message": "Missing item type\nThe `angular.module` is a global place for creating and registering Angular modules. All\nmodules (angular core or 3rd party) that should be available to an application must be\nregistered using this mechanism.\n\n\n# Module\n\nA module is a collocation of services, directives, filters, and configuration information. Module\nis used to configure the {@link AUTO.$injector $injector}.\n\n<pre>\n// Create a new module\nvar myModule = angular.module('myModule', []);\n\n// register a new service\nmyModule.value('appName', 'MyCoolApp');\n\n// configure existing services inside initialization blocks.\nmyModule.config(function($locationProvider) {\n  // Configure existing providers\n  $locationProvider.hashPrefix('!');\n});\n</pre>\n\nThen you can create an injector and load your modules like this:\n\n<pre>\nvar injector = angular.injector(['ng', 'MyModule'])\n</pre>\n\nHowever it's more likely that you'll just use\n{@link ng.directive:ngApp ngApp} or\n{@link angular.bootstrap} to simplify this process for you.",
            "line": " lib\\angular\\impl\\angular.js:1038"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:1093"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:1096"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:1101"
        },
        {
            "message": "Missing item type\nHolds the list of modules which the injector will load before the current module is loaded.",
            "line": " lib\\angular\\impl\\angular.js:1107"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:1117"
        },
        {
            "message": "Missing item type\nSee {@link AUTO.$provide#provider $provide.provider()}.",
            "line": " lib\\angular\\impl\\angular.js:1127"
        },
        {
            "message": "Missing item type\nSee {@link AUTO.$provide#factory $provide.factory()}.",
            "line": " lib\\angular\\impl\\angular.js:1138"
        },
        {
            "message": "Missing item type\nSee {@link AUTO.$provide#service $provide.service()}.",
            "line": " lib\\angular\\impl\\angular.js:1149"
        },
        {
            "message": "Missing item type\nSee {@link AUTO.$provide#value $provide.value()}.",
            "line": " lib\\angular\\impl\\angular.js:1160"
        },
        {
            "message": "Missing item type\nBecause the constant are fixed, they get applied before other provide methods.\nSee {@link AUTO.$provide#constant $provide.constant()}.",
            "line": " lib\\angular\\impl\\angular.js:1171"
        },
        {
            "message": "Missing item type\nSee {@link ng.$filterProvider#register $filterProvider.register()}.",
            "line": " lib\\angular\\impl\\angular.js:1183"
        },
        {
            "message": "Missing item type\nSee {@link ng.$controllerProvider#register $controllerProvider.register()}.",
            "line": " lib\\angular\\impl\\angular.js:1194"
        },
        {
            "message": "Missing item type\nSee {@link ng.$compileProvider#directive $compileProvider.directive()}.",
            "line": " lib\\angular\\impl\\angular.js:1205"
        },
        {
            "message": "Missing item type\nUse this method to register work which needs to be performed on module loading.",
            "line": " lib\\angular\\impl\\angular.js:1217"
        },
        {
            "message": "Missing item type\nUse this method to register work which should be performed when the injector is done\nloading all modules.",
            "line": " lib\\angular\\impl\\angular.js:1228"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:1250"
        },
        {
            "message": "Missing item type\nAn object that contains information about the current AngularJS version. This object has the\nfollowing properties:\n\n- `full` – `{string}` – Full version string, such as \"0.9.18\".\n- `major` – `{number}` – Major version number, such as \"0\".\n- `minor` – `{number}` – Minor version number, such as \"9\".\n- `dot` – `{number}` – Dot version number, such as \"18\".\n- `codeName` – `{string}` – Code name of the release, such as \"jiggling-armfat\".",
            "line": " lib\\angular\\impl\\angular.js:1268"
        },
        {
            "message": "Missing item type\nConverts snake_case to camelCase.\nAlso there is special case for Moz prefix starting with upper case letter.",
            "line": " lib\\angular\\impl\\angular.js:1490"
        },
        {
            "message": "Missing item type\nProperties: writes return selection, reads return first value",
            "line": " lib\\angular\\impl\\angular.js:1885"
        },
        {
            "message": "Missing item type\nchaining functions",
            "line": " lib\\angular\\impl\\angular.js:2142"
        },
        {
            "message": "Missing item type\nComputes a hash of an 'obj'.\nHash of a:\n string is string\n number is number as string\n object is either result of calling $$hashKey function on the object or uniquely generated id,\n        that is also assigned to the $$hashKey property of the object.",
            "line": " lib\\angular\\impl\\angular.js:2162"
        },
        {
            "message": "Missing item type\nHashMap which can use objects as keys",
            "line": " lib\\angular\\impl\\angular.js:2192"
        },
        {
            "message": "Missing item type\nStore key value pair",
            "line": " lib\\angular\\impl\\angular.js:2199"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:2208"
        },
        {
            "message": "Missing item type\nRemove the key/value pair",
            "line": " lib\\angular\\impl\\angular.js:2216"
        },
        {
            "message": "Missing item type\nA map where multiple values can be added to the same key such that they form a queue.",
            "line": " lib\\angular\\impl\\angular.js:2227"
        },
        {
            "message": "Missing item type\nSame as array push, but using an array as the value for the hash",
            "line": " lib\\angular\\impl\\angular.js:2233"
        },
        {
            "message": "Missing item type\nSame as array shift, but using an array as the value for the hash",
            "line": " lib\\angular\\impl\\angular.js:2245"
        },
        {
            "message": "Missing item type\nreturn the first item without deleting it",
            "line": " lib\\angular\\impl\\angular.js:2260"
        },
        {
            "message": "Missing item type\nImplicit module which gets automatically added to each {@link AUTO.$injector $injector}.",
            "line": " lib\\angular\\impl\\angular.js:2301"
        },
        {
            "message": "Missing item type\nReturn an instance of the service.",
            "line": " lib\\angular\\impl\\angular.js:2395"
        },
        {
            "message": "Missing item type\nInvoke the method and supply the method arguments from the `$injector`.",
            "line": " lib\\angular\\impl\\angular.js:2407"
        },
        {
            "message": "Missing item type\nCreate a new instance of JS type. The method takes a constructor function invokes the new operator and supplies\nall of the arguments to the constructor function as specified by the constructor annotation.",
            "line": " lib\\angular\\impl\\angular.js:2422"
        },
        {
            "message": "Missing item type\nReturns an array of service names which the function is requesting for injection. This API is used by the injector\nto determine which services need to be injected into the function when the function is invoked. There are three\nways in which the function can be annotated with the needed dependencies.\n\n# Argument names\n\nThe simplest form is to extract the dependencies from the arguments of the function. This is done by converting\nthe function into a string using `toString()` method and extracting the argument names.\n<pre>\n  // Given\n  function MyController($scope, $route) {\n    // ...\n  }\n\n  // Then\n  expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\n</pre>\n\nThis method does not work with code minfication / obfuscation. For this reason the following annotation strategies\nare supported.\n\n# The `$inject` property\n\nIf a function has an `$inject` property and its value is an array of strings, then the strings represent names of\nservices to be injected into the function.\n<pre>\n  // Given\n  var MyController = function(obfuscatedScope, obfuscatedRoute) {\n    // ...\n  }\n  // Define function dependencies\n  MyController.$inject = ['$scope', '$route'];\n\n  // Then\n  expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\n</pre>\n\n# The array notation\n\nIt is often desirable to inline Injected functions and that's when setting the `$inject` property is very\ninconvenient. In these situations using the array notation to specify the dependencies in a way that survives\nminification is a better choice:\n\n<pre>\n  // We wish to write this (not minification / obfuscation safe)\n  injector.invoke(function($compile, $rootScope) {\n    // ...\n  });\n\n  // We are forced to write break inlining\n  var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {\n    // ...\n  };\n  tmpFn.$inject = ['$compile', '$rootScope'];\n  injector.invoke(tempFn);\n\n  // To better support inline function the inline annotation is supported\n  injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {\n    // ...\n  }]);\n\n  // Therefore\n  expect(injector.annotate(\n     ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])\n   ).toEqual(['$compile', '$rootScope']);\n</pre>",
            "line": " lib\\angular\\impl\\angular.js:2436"
        },
        {
            "message": "Missing item type\nUse `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.\nThe providers share the same name as the instance they create with the `Provider` suffixed to them.\n\nA provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of\na service. The Provider can have additional methods which would allow for configuration of the provider.\n\n<pre>\n  function GreetProvider() {\n    var salutation = 'Hello';\n\n    this.salutation = function(text) {\n      salutation = text;\n    };\n\n    this.$get = function() {\n      return function (name) {\n        return salutation + ' ' + name + '!';\n      };\n    };\n  }\n\n  describe('Greeter', function(){\n\n    beforeEach(module(function($provide) {\n      $provide.provider('greet', GreetProvider);\n    });\n\n    it('should greet', inject(function(greet) {\n      expect(greet('angular')).toEqual('Hello angular!');\n    }));\n\n    it('should allow configuration of salutation', function() {\n      module(function(greetProvider) {\n        greetProvider.salutation('Ahoj');\n      });\n      inject(function(greet) {\n        expect(greet('angular')).toEqual('Ahoj angular!');\n      });\n    )};\n\n  });\n</pre>",
            "line": " lib\\angular\\impl\\angular.js:2518"
        },
        {
            "message": "Missing item type\nRegister a provider for a service. The providers can be retrieved and can have additional configuration methods.",
            "line": " lib\\angular\\impl\\angular.js:2568"
        },
        {
            "message": "Missing item type\nA short hand for configuring services if only `$get` method is required.",
            "line": " lib\\angular\\impl\\angular.js:2587"
        },
        {
            "message": "Missing item type\nA short hand for registering service of given class.",
            "line": " lib\\angular\\impl\\angular.js:2602"
        },
        {
            "message": "Missing item type\nA short hand for configuring services if the `$get` method is a constant.",
            "line": " lib\\angular\\impl\\angular.js:2616"
        },
        {
            "message": "Missing item type\nA constant value, but unlike {@link AUTO.$provide#value value} it can be injected\ninto configuration function (other modules) and it is not interceptable by\n{@link AUTO.$provide#decorator decorator}.",
            "line": " lib\\angular\\impl\\angular.js:2630"
        },
        {
            "message": "Missing item type\nDecoration of service, allows the decorator to intercept the service instance creation. The\nreturned instance may be the original instance, or a new instance which delegates to the\noriginal instance.",
            "line": " lib\\angular\\impl\\angular.js:2646"
        },
        {
            "message": "Missing item type\nWhen called, it checks current value of `$location.hash()` and scroll to related element,\naccording to rules specified in\n{@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.\n\nIt also watches the `$location.hash()` and scroll whenever it changes to match any anchor.\nThis can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.",
            "line": " lib\\angular\\impl\\angular.js:2873"
        },
        {
            "message": "Missing item type\nThis object has two goals:\n\n- hide all the global state in the browser caused by the window object\n- abstract away all the browser specific features and inconsistencies\n\nFor tests we provide {@link ngMock.$browser mock implementation} of the `$browser`\nservice, which can be used for convenient testing of the application without the interaction with\nthe real browser apis.",
            "line": " lib\\angular\\impl\\angular.js:2940"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:2955"
        },
        {
            "message": "Missing item type\nExecutes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`\ncounter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.",
            "line": " lib\\angular\\impl\\angular.js:2980"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:3001"
        },
        {
            "message": "Missing item type\nAdds a function to the list of functions that poller periodically executes,\nand starts polling if not started yet.",
            "line": " lib\\angular\\impl\\angular.js:3026"
        },
        {
            "message": "Missing item type\nConfigures the poller to run in the specified intervals, using the specified\nsetTimeout fn and kicks it off.",
            "line": " lib\\angular\\impl\\angular.js:3044"
        },
        {
            "message": "Missing item type\nGETTER:\nWithout any argument, this method just returns current value of location.href.\n\nSETTER:\nWith at least one argument, this method sets url to new value.\nIf html5 history api supported, pushState/replaceState is used, otherwise\nlocation.href/location.replace is used.\nReturns its own instance to allow chaining\n\nNOTE: this api is intended for use only by the $location service. Please use the\n{@link ng.$location $location service} to change url.",
            "line": " lib\\angular\\impl\\angular.js:3066"
        },
        {
            "message": "Missing item type\nRegister callback function that will be called, when url changes.\n\nIt's only called when the url is changed by outside of angular:\n- user types different url into address bar\n- user clicks on history (forward/back) button\n- user clicks on a link\n\nIt's not called when url is changed by $browser.url() method\n\nThe listener gets called with new url as parameter.\n\nNOTE: this api is intended for use only by the $location service. Please use the\n{@link ng.$location $location service} to monitor url changes in angular apps.",
            "line": " lib\\angular\\impl\\angular.js:3122"
        },
        {
            "message": "Missing item type\nReturns current <base href>\n(always relative - without domain)",
            "line": " lib\\angular\\impl\\angular.js:3169"
        },
        {
            "message": "Missing item type\nThe cookies method provides a 'private' low level access to browser cookies.\nIt is not meant to be used directly, use the $cookie service instead.\n\nThe return values vary depending on the arguments that the method was called with as follows:\n<ul>\n  <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>\n  <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>\n  <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>\n</ul>",
            "line": " lib\\angular\\impl\\angular.js:3187"
        },
        {
            "message": "Missing item type\nExecutes a fn asynchroniously via `setTimeout(fn, delay)`.\n\nUnlike when calling `setTimeout` directly, in test this function is mocked and instead of using\n`setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed\nvia `$browser.defer.flush()`.",
            "line": " lib\\angular\\impl\\angular.js:3246"
        },
        {
            "message": "Missing item type\nCancels a defered task identified with `deferId`.",
            "line": " lib\\angular\\impl\\angular.js:3273"
        },
        {
            "message": "Missing item type\nFactory that constructs cache objects.",
            "line": " lib\\angular\\impl\\angular.js:3301"
        },
        {
            "message": "Missing item type\nmakes the `entry` the freshEnd of the LRU linked list",
            "line": " lib\\angular\\impl\\angular.js:3407"
        },
        {
            "message": "Missing item type\nbidirectionally links two entries of the LRU linked list",
            "line": " lib\\angular\\impl\\angular.js:3426"
        },
        {
            "message": "Missing item type\nCache used for storing html templates.\n\nSee {@link ng.$cacheFactory $cacheFactory}.",
            "line": " lib\\angular\\impl\\angular.js:3456"
        },
        {
            "message": "Missing item type\nSet a normalized attribute on the element in a way such that all directives\ncan share the attribute. This function properly handles boolean attributes.",
            "line": " lib\\angular\\impl\\angular.js:3727"
        },
        {
            "message": "Missing item type\nObserve an interpolated attribute.\nThe observer will never be called, if given attribute is not interpolated.",
            "line": " lib\\angular\\impl\\angular.js:3790"
        },
        {
            "message": "Missing item type\nCompile function matches each node in nodeList against the directives. Once all directives\nfor a particular node are collected their compile functions are executed. The compile\nfunctions return values - the linking functions - are combined into a composite linking\nfunction, which is the a linking function for the node.",
            "line": " lib\\angular\\impl\\angular.js:3876"
        },
        {
            "message": "Missing item type\nLooks for directives on the given node and adds them to the directive collection which is\nsorted.",
            "line": " lib\\angular\\impl\\angular.js:3963"
        },
        {
            "message": "Missing item type\nOnce the directives have been collected their compile functions is executed. This method\nis responsible for inlining directive templates as well as terminating the application\nof the directives if the terminal directive has been reached..",
            "line": " lib\\angular\\impl\\angular.js:4040"
        },
        {
            "message": "Missing item type\nlooks up the directive and decorates it with exception handling and proper parameters. We\ncall this the boundDirective.",
            "line": " lib\\angular\\impl\\angular.js:4354"
        },
        {
            "message": "Missing item type\nWhen the element is replaced with HTML template then the new attributes\non the template need to be merged with the existing attributes in the DOM.\nThe desired effect is to have both of the attributes present.",
            "line": " lib\\angular\\impl\\angular.js:4387"
        },
        {
            "message": "Missing item type\nSorting function for bound directives.",
            "line": " lib\\angular\\impl\\angular.js:4505"
        },
        {
            "message": "Missing item type\nThis is a special jqLite.replaceWith, which can replace items which\nhave no parents, provided that the containing jqLite collection is provided.",
            "line": " lib\\angular\\impl\\angular.js:4569"
        },
        {
            "message": "Missing item type\nConverts all accepted directives format into proper directive name.\nAll of these will become 'myDirective':\n  my:DiRective\n  my-directive\n  x-my-directive\n  data-my:directive\n\nAlso there is special case for Moz prefix starting with upper case letter.",
            "line": " lib\\angular\\impl\\angular.js:4604"
        },
        {
            "message": "Missing item type\nA shared object between directive compile / linking functions which contains normalized DOM element\nattributes. The the values reflect current binding state `{{ }}`. The normalization is needed\nsince all of these are treated as equivalent in Angular:\n\n         <span ng:bind=\"a\" ng-bind=\"a\" data-ng-bind=\"a\" x-ng-bind=\"a\">",
            "line": " lib\\angular\\impl\\angular.js:4619"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:4631"
        },
        {
            "message": "Missing item type\nClosure compiler type information",
            "line": " lib\\angular\\impl\\angular.js:4658"
        },
        {
            "message": "Missing item type\nThe {@link ng.$controller $controller service} is used by Angular to create new\ncontrollers.\n\nThis provider allows controller registration via the\n{@link ng.$controllerProvider#register register} method.",
            "line": " lib\\angular\\impl\\angular.js:4677"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:4691"
        },
        {
            "message": "Missing item type\n`$controller` service is responsible for instantiating controllers.\n\nIt's just simple call to {@link AUTO.$injector $injector}, but extracted into\na service, so that one can override this service with {@link https://gist.github.com/1649788\nBC version}.",
            "line": " lib\\angular\\impl\\angular.js:4710"
        },
        {
            "message": "Missing item type\nA {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`\nelement.",
            "line": " lib\\angular\\impl\\angular.js:4748"
        },
        {
            "message": "Missing item type\nAny uncaught exception in angular expressions is delegated to this service.\nThe default implementation simply delegates to `$log.error` which logs it into\nthe browser console.\n\nIn unit tests, if `angular-mocks.js` is loaded, this service is overridden by\n{@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.",
            "line": " lib\\angular\\impl\\angular.js:4763"
        },
        {
            "message": "Missing item type\nSymbol to denote start of expression in the interpolated string. Defaults to `{{`.",
            "line": " lib\\angular\\impl\\angular.js:4802"
        },
        {
            "message": "Missing item type\nSymbol to denote the end of expression in the interpolated string. Defaults to `}}`.",
            "line": " lib\\angular\\impl\\angular.js:4821"
        },
        {
            "message": "Missing item type\nSymbol to denote the start of expression in the interpolated string. Defaults to `{{`.\n\nUse {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change\nthe symbol.",
            "line": " lib\\angular\\impl\\angular.js:4933"
        },
        {
            "message": "Missing item type\nSymbol to denote the end of expression in the interpolated string. Defaults to `}}`.\n\nUse {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change\nthe symbol.",
            "line": " lib\\angular\\impl\\angular.js:4950"
        },
        {
            "message": "Missing item type\nEncode path using encodeUriSegment, ignoring forward slashes",
            "line": " lib\\angular\\impl\\angular.js:4976"
        },
        {
            "message": "Missing item type\nLocationUrl represents an url\nThis object is exposed as $location service when HTML5 mode is enabled and supported",
            "line": " lib\\angular\\impl\\angular.js:5068"
        },
        {
            "message": "Missing item type\nParse given html5 (regular) url string into properties",
            "line": " lib\\angular\\impl\\angular.js:5079"
        },
        {
            "message": "Missing item type\nCompose url and update `absUrl` property",
            "line": " lib\\angular\\impl\\angular.js:5098"
        },
        {
            "message": "Missing item type\nLocationHashbangUrl represents url\nThis object is exposed as $location service when html5 history api is disabled or not supported",
            "line": " lib\\angular\\impl\\angular.js:5123"
        },
        {
            "message": "Missing item type\nParse given hashbang url into properties",
            "line": " lib\\angular\\impl\\angular.js:5134"
        },
        {
            "message": "Missing item type\nCompose hashbang url and update `absUrl` property",
            "line": " lib\\angular\\impl\\angular.js:5161"
        },
        {
            "message": "Missing item type\nHas any change been replacing ?",
            "line": " lib\\angular\\impl\\angular.js:5187"
        },
        {
            "message": "Missing item type\nThis method is getter only.\n\nReturn full url representation with all segments encoded according to rules specified in\n{@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.",
            "line": " lib\\angular\\impl\\angular.js:5193"
        },
        {
            "message": "Missing item type\nThis method is getter / setter.\n\nReturn url (e.g. `/path?a=b#hash`) when called without any parameter.\n\nChange path, search and hash, when called with parameter and return `$location`.",
            "line": " lib\\angular\\impl\\angular.js:5208"
        },
        {
            "message": "Missing item type\nThis method is getter only.\n\nReturn protocol of current url.",
            "line": " lib\\angular\\impl\\angular.js:5235"
        },
        {
            "message": "Missing item type\nThis method is getter only.\n\nReturn host of current url.",
            "line": " lib\\angular\\impl\\angular.js:5249"
        },
        {
            "message": "Missing item type\nThis method is getter only.\n\nReturn port of current url.",
            "line": " lib\\angular\\impl\\angular.js:5263"
        },
        {
            "message": "Missing item type\nThis method is getter / setter.\n\nReturn path of current url when called without any parameter.\n\nChange path when called with parameter and return `$location`.\n\nNote: Path should always begin with forward slash (/), this method will add the forward slash\nif it is missing.",
            "line": " lib\\angular\\impl\\angular.js:5277"
        },
        {
            "message": "Missing item type\nThis method is getter / setter.\n\nReturn search part (as object) of current url when called without any parameter.\n\nChange search part when called with parameter and return `$location`.",
            "line": " lib\\angular\\impl\\angular.js:5299"
        },
        {
            "message": "Missing item type\nThis method is getter / setter.\n\nReturn hash fragment when called without any parameter.\n\nChange hash fragment when called with parameter and return `$location`.",
            "line": " lib\\angular\\impl\\angular.js:5335"
        },
        {
            "message": "Missing item type\nIf called, all changes to $location during current `$digest` will be replacing current history\nrecord, instead of adding new one.",
            "line": " lib\\angular\\impl\\angular.js:5352"
        },
        {
            "message": "Missing item type\nThe $location service parses the URL in the browser address bar (based on the\n{@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL\navailable to your application. Changes to the URL in the address bar are reflected into\n$location service and changes to $location are reflected into the browser address bar.\n\n**The $location service:**\n\n- Exposes the current URL in the browser address bar, so you can\n  - Watch and observe the URL.\n  - Change the URL.\n- Synchronizes the URL with the browser when the user\n  - Changes the address bar.\n  - Clicks the back or forward button (or clicks a History link).\n  - Clicks on a link.\n- Represents the URL object as a set of methods (protocol, host, port, path, search, hash).\n\nFor more information see {@link guide/dev_guide.services.$location Developer Guide: Angular\nServices: Using $location}",
            "line": " lib\\angular\\impl\\angular.js:5402"
        },
        {
            "message": "Missing item type\nUse the `$locationProvider` to configure how the application deep linking paths are stored.",
            "line": " lib\\angular\\impl\\angular.js:5431"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:5441"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:5458"
        },
        {
            "message": "Missing item type\nSimple service for logging. Default implementation writes the message\ninto the browser's console (if present).\n\nThe main purpose of this service is to simplify debugging and troubleshooting.",
            "line": " lib\\angular\\impl\\angular.js:5587"
        },
        {
            "message": "Missing item type\nWrite a log message",
            "line": " lib\\angular\\impl\\angular.js:5623"
        },
        {
            "message": "Missing item type\nWrite a warning message",
            "line": " lib\\angular\\impl\\angular.js:5633"
        },
        {
            "message": "Missing item type\nWrite an information message",
            "line": " lib\\angular\\impl\\angular.js:5643"
        },
        {
            "message": "Missing item type\nWrite an error message",
            "line": " lib\\angular\\impl\\angular.js:5653"
        },
        {
            "message": "Missing item type\nReturn the value accesible from the object by path. Any undefined traversals are ignored",
            "line": " lib\\angular\\impl\\angular.js:6364"
        },
        {
            "message": "Missing item type\nImplementation of the \"Black Hole\" variant from:\n- http://jsperf.com/angularjs-parse-getter/4\n- http://jsperf.com/path-evaluation-simplified/7",
            "line": " lib\\angular\\impl\\angular.js:6393"
        },
        {
            "message": "Missing item type\nA promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).\n\n[The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an\ninterface for interacting with an object that represents the result of an action that is\nperformed asynchronously, and may or may not be finished at any given point in time.\n\nFrom the perspective of dealing with error handling, deferred and promise APIs are to\nasynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.\n\n<pre>\n  // for the purpose of this example let's assume that variables `$q` and `scope` are\n  // available in the current lexical scope (they could have been injected or passed in).\n\n  function asyncGreet(name) {\n    var deferred = $q.defer();\n\n    setTimeout(function() {\n      // since this fn executes async in a future turn of the event loop, we need to wrap\n      // our code into an $apply call so that the model changes are properly observed.\n      scope.$apply(function() {\n        if (okToGreet(name)) {\n          deferred.resolve('Hello, ' + name + '!');\n        } else {\n          deferred.reject('Greeting ' + name + ' is not allowed.');\n        }\n      });\n    }, 1000);\n\n    return deferred.promise;\n  }\n\n  var promise = asyncGreet('Robin Hood');\n  promise.then(function(greeting) {\n    alert('Success: ' + greeting);\n  }, function(reason) {\n    alert('Failed: ' + reason);\n  });\n</pre>\n\nAt first it might not be obvious why this extra complexity is worth the trouble. The payoff\ncomes in the way of\n[guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).\n\nAdditionally the promise api allows for composition that is very hard to do with the\ntraditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.\nFor more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the\nsection on serial or parallel joining of promises.\n\n\n# The Deferred API\n\nA new instance of deferred is constructed by calling `$q.defer()`.\n\nThe purpose of the deferred object is to expose the associated Promise instance as well as APIs\nthat can be used for signaling the successful or unsuccessful completion of the task.\n\n**Methods**\n\n- `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection\n  constructed via `$q.reject`, the promise will be rejected instead.\n- `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to\n  resolving it with a rejection constructed via `$q.reject`.\n\n**Properties**\n\n- promise – `{Promise}` – promise object associated with this deferred.\n\n\n# The Promise API\n\nA new promise instance is created when a deferred instance is created and can be retrieved by\ncalling `deferred.promise`.\n\nThe purpose of the promise object is to allow for interested parties to get access to the result\nof the deferred task when it completes.\n\n**Methods**\n\n- `then(successCallback, errorCallback)` – regardless of when the promise was or will be resolved\n  or rejected calls one of the success or error callbacks asynchronously as soon as the result\n  is available. The callbacks are called with a single argument the result or rejection reason.\n\n  This method *returns a new promise* which is resolved or rejected via the return value of the\n  `successCallback` or `errorCallback`.\n\n\n# Chaining promises\n\nBecause calling `then` api of a promise returns a new derived promise, it is easily possible\nto create a chain of promises:\n\n<pre>\n  promiseB = promiseA.then(function(result) {\n    return result + 1;\n  });\n\n  // promiseB will be resolved immediately after promiseA is resolved and its value will be\n  // the result of promiseA incremented by 1\n</pre>\n\nIt is possible to create chains of any length and since a promise can be resolved with another\npromise (which will defer its resolution further), it is possible to pause/defer resolution of\nthe promises at any point in the chain. This makes it possible to implement powerful apis like\n$http's response interceptors.\n\n\n# Differences between Kris Kowal's Q and $q\n\n There are three main differences:\n\n- $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation\n  mechanism in angular, which means faster propagation of resolution or rejection into your\n  models and avoiding unnecessary browser repaints, which would result in flickering UI.\n- $q promises are recognized by the templating engine in angular, which means that in templates\n  you can treat promises attached to a scope as if they were the resulting values.\n- Q has many more features that $q, but that comes at a cost of bytes. $q is tiny, but contains\n  all the important functionality needed for common async tasks.\n\n # Testing\n\n <pre>\n   it('should simulate promise', inject(function($q, $rootScope) {\n     var deferred = $q.defer();\n     var promise = deferred.promise;\n     var resolvedValue;\n\n     promise.then(function(value) { resolvedValue = value; });\n     expect(resolvedValue).toBeUndefined();\n\n     // Simulate resolving of promise\n     deferred.resolve(123);\n     // Note that the 'then' function does not get called synchronously.\n     // This is because we want the promise API to always be async, whether or not\n     // it got called synchronously or asynchronously.\n     expect(resolvedValue).toBeUndefined();\n\n     // Propagate promise resolution to 'then' functions using $apply().\n     $rootScope.$apply();\n     expect(resolvedValue).toEqual(123);\n   });\n </pre>",
            "line": " lib\\angular\\impl\\angular.js:6567"
        },
        {
            "message": "Missing item type\nConstructs a promise manager.",
            "line": " lib\\angular\\impl\\angular.js:6725"
        },
        {
            "message": "Missing item type\nCreates a `Deferred` object which represents a task which will finish in the future.",
            "line": " lib\\angular\\impl\\angular.js:6735"
        },
        {
            "message": "Missing item type\nCreates a promise that is resolved as rejected with the specified `reason`. This api should be\nused to forward rejection in a chain of promises. If you are dealing with the last promise in\na promise chain, you don't need to worry about it.\n\nWhen comparing deferreds/promises to the familiar behavior of try/catch/throw, think of\n`reject` as the `throw` keyword in JavaScript. This also means that if you \"catch\" an error via\na promise error callback and you want to forward the error to the promise derived from the\ncurrent promise, you have to \"rethrow\" the error by returning a rejection constructed via\n`reject`.\n\n<pre>\n  promiseB = promiseA.then(function(result) {\n    // success: do something and resolve promiseB\n    //          with the old or a new result\n    return result;\n  }, function(reason) {\n    // error: handle the error if possible and\n    //        resolve promiseB with newPromiseOrValue,\n    //        otherwise forward the rejection to promiseB\n    if (canHandle(reason)) {\n     // handle the error and recover\n     return newPromiseOrValue;\n    }\n    return $q.reject(reason);\n  });\n</pre>",
            "line": " lib\\angular\\impl\\angular.js:6825"
        },
        {
            "message": "Missing item type\nWraps an object that might be a value or a (3rd party) then-able promise into a $q promise.\nThis is useful when you are dealing with an object that might or might not be a promise, or if\nthe promise comes from a source that can't be trusted.",
            "line": " lib\\angular\\impl\\angular.js:6873"
        },
        {
            "message": "Missing item type\nCombines multiple promises into a single promise that is resolved when all of the input\npromises are resolved.",
            "line": " lib\\angular\\impl\\angular.js:6936"
        },
        {
            "message": "Missing item type\nAdds a new route definition to the `$route` service.",
            "line": " lib\\angular\\impl\\angular.js:6993"
        },
        {
            "message": "Missing item type\nSets route definition that will be used on route change when no other route definition\nis matched.",
            "line": " lib\\angular\\impl\\angular.js:7071"
        },
        {
            "message": "Missing item type\nBroadcasted before a route change. At this  point the route services starts\nresolving all of the dependencies needed for the route change to occurs.\nTypically this involves fetching the view template as well as any dependencies\ndefined in `resolve` route property. Once  all of the dependencies are resolved\n`$routeChangeSuccess` is fired.",
            "line": " lib\\angular\\impl\\angular.js:7217"
        },
        {
            "message": "Missing item type\nBroadcasted after a route dependencies are resolved.\n{@link ng.directive:ngView ngView} listens for the directive\nto instantiate the controller and render the view.",
            "line": " lib\\angular\\impl\\angular.js:7233"
        },
        {
            "message": "Missing item type\nBroadcasted if any of the resolve promises are rejected.",
            "line": " lib\\angular\\impl\\angular.js:7247"
        },
        {
            "message": "Missing item type\nThe `reloadOnSearch` property has been set to false, and we are reusing the same\ninstance of the Controller.",
            "line": " lib\\angular\\impl\\angular.js:7260"
        },
        {
            "message": "Missing item type\nCauses `$route` service to reload the current route even if\n{@link ng.$location $location} hasn't changed.\n\nAs a result of that, {@link ng.directive:ngView ngView}\ncreates new scope, reinstantiates the controller.",
            "line": " lib\\angular\\impl\\angular.js:7275"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:7299"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:7410"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:7428"
        },
        {
            "message": "Missing item type\nCurrent set of route parameters. The route parameters are a combination of the\n{@link ng.$location $location} `search()`, and `path()`. The `path` parameters\nare extracted when the {@link ng.$route $route} path is matched.\n\nIn case of parameter name collision, `path` params take precedence over `search` params.\n\nThe service guarantees that the identity of the `$routeParams` object will remain unchanged\n(but its properties will likely change) even when a route change occurs.",
            "line": " lib\\angular\\impl\\angular.js:7449"
        },
        {
            "message": "Missing item type\nDESIGN NOTES\n\nThe design decisions behind the scope ware heavily favored for speed and memory consumption.\n\nThe typical use of scope is to watch the expressions, which most of the time return the same\nvalue as last time so we optimize the operation.\n\nClosures construction is expensive from speed as well as memory:\n  - no closures, instead ups prototypical inheritance for API\n  - Internal state needs to be stored on scope directly, which means that private state is\n    exposed as $$____ properties\n\nLoop operations are optimized by using while(count--) { ... }\n  - this means that in order to keep the same order of execution as addition we have to add\n    items to the array at the begging (shift) instead of at the end (push)\n\nChild scopes are created and removed often\n  - Using array would be slow since inserts in meddle are expensive so we use linked list\n\nThere are few watches then a lot of observers. This is why you don't want the observer to be\nimplemented in the same way as watch. Watch requires return of initialization function which\nare expensive to construct.",
            "line": " lib\\angular\\impl\\angular.js:7478"
        },
        {
            "message": "Missing item type\nProvider for the $rootScope service.",
            "line": " lib\\angular\\impl\\angular.js:7504"
        },
        {
            "message": "Missing item type\nSets the number of digest iteration the scope should attempt to execute before giving up and\nassuming that the model is unstable.\n\nThe current default is 10 iterations.",
            "line": " lib\\angular\\impl\\angular.js:7512"
        },
        {
            "message": "Missing item type\nEvery application has a single root {@link ng.$rootScope.Scope scope}.\nAll other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide\nevent processing life-cycle. See {@link guide/scope developer guide on scopes}.",
            "line": " lib\\angular\\impl\\angular.js:7527"
        },
        {
            "message": "Missing item type\nA root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the\n{@link AUTO.$injector $injector}. Child scopes are created using the\n{@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when\ncompiled HTML template is executed.)\n\nHere is a simple scope snippet to show how you can interact with the scope.\n<pre>\n       angular.injector(['ng']).invoke(function($rootScope) {\n          var scope = $rootScope.$new();\n          scope.salutation = 'Hello';\n          scope.name = 'World';\n\n          expect(scope.greeting).toEqual(undefined);\n\n          scope.$watch('name', function() {\n            scope.greeting = scope.salutation + ' ' + scope.name + '!';\n          }); // initialize the watch\n\n          expect(scope.greeting).toEqual(undefined);\n          scope.name = 'Misko';\n          // still old value, since watches have not been called yet\n          expect(scope.greeting).toEqual(undefined);\n\n          scope.$digest(); // fire all  the watches\n          expect(scope.greeting).toEqual('Hello Misko!');\n       });\n</pre>\n\n# Inheritance\nA scope can inherit from a parent scope, as in this example:\n<pre>\n        var parent = $rootScope;\n        var child = parent.$new();\n\n        parent.salutation = \"Hello\";\n        child.name = \"World\";\n        expect(child.salutation).toEqual('Hello');\n\n        child.salutation = \"Welcome\";\n        expect(child.salutation).toEqual('Welcome');\n        expect(parent.salutation).toEqual('Hello');\n</pre>",
            "line": " lib\\angular\\impl\\angular.js:7549"
        },
        {
            "message": "Missing item type",
            "line": " lib\\angular\\impl\\angular.js:7618"
        },
        {
            "message": "Missing item type\nBroadcasted when a scope and its children are being destroyed.",
            "line": " lib\\angular\\impl\\angular.js:7916"
        },
        {
            "message": "Missing item type\nfunction used as an initial value for watchers.\nbecause it's unique we can easily tell it apart from other values",
            "line": " lib\\angular\\impl\\angular.js:8286"
        },
        {
            "message": "Missing item type\nA reference to the browser's `window` object. While `window`\nis globally available in JavaScript, it causes testability problems, because\nit is a global variable. In angular we always refer to it through the\n`$window` service, so it may be overriden, removed or mocked for testing.\n\nAll expressions are evaluated with respect to current scope so they don't\nsuffer from window globality.",
            "line": " lib\\angular\\impl\\angular.js:8339"
        },
        {
            "message": "Missing item type\nParse headers into key value object",
            "line": " lib\\angular\\impl\\angular.js:8366"
        },
        {
            "message": "Missing item type\nReturns a function that provides access to parsed headers.\n\nHeaders are lazy parsed when first requested.",
            "line": " lib\\angular\\impl\\angular.js:8395"
        },
        {
            "message": "Missing item type\nChain all given functions\n\nThis function is used for both request and response transforming",
            "line": " lib\\angular\\impl\\angular.js:8422"
        },
        {
            "message": "Missing item type\nShortcut method to perform `GET` request",
            "line": " lib\\angular\\impl\\angular.js:8896"
        },
        {
            "message": "Missing item type\nShortcut method to perform `DELETE` request",
            "line": " lib\\angular\\impl\\angular.js:8909"
        },
        {
            "message": "Missing item type\nShortcut method to perform `HEAD` request",
            "line": " lib\\angular\\impl\\angular.js:8922"
        },
        {
            "message": "Missing item type\nShortcut method to perform `JSONP` request",
            "line": " lib\\angular\\impl\\angular.js:8935"
        },
        {
            "message": "Missing item type\nShortcut method to perform `POST` request",
            "line": " lib\\angular\\impl\\angular.js:8950"
        },
        {
            "message": "Missing item type\nShortcut method to perform `PUT` request",
            "line": " lib\\angular\\impl\\angular.js:8964"
        },
        {
            "message": "Missing item type\nRuntime equivalent of the `$httpProvider.defaults` property. Allows configuration of\ndefault headers as well as request and response transformations.\n\nSee \"Setting HTTP Headers\" and \"Transforming Requests and Responses\" sections above.",
            "line": " lib\\angular\\impl\\angular.js:8979"
        },
        {
            "message": "Missing item type\nMakes the request\n\n!!! ACCESSES CLOSURE VARS:\n$httpBackend, $config, $log, $rootScope, defaultCache, $http.pendingRequests",
            "line": " lib\\angular\\impl\\angular.js:9021"
        },
        {
            "message": "Missing item type\nCallback registered to $httpBackend():\n - caches the response if desired\n - resolves the raw $http promise\n - calls $apply",
            "line": " lib\\angular\\impl\\angular.js:9072"
        },
        {
            "message": "Missing item type\nResolves the raw $http promise.",
            "line": " lib\\angular\\impl\\angular.js:9093"
        },
        {
            "message": "Missing item type\nHTTP backend used by the {@link ng.$http service} that delegates to\nXMLHttpRequest object or JSONP and deals with browser incompatibilities.\n\nYou should never need to use this service directly, instead use the higher-level abstractions:\n{@link ng.$http $http} or {@link ngResource.$resource $resource}.\n\nDuring testing this implementation is swapped with {@link ngMock.$httpBackend mock\n$httpBackend} which can be trained with responses.",
            "line": " lib\\angular\\impl\\angular.js:9140"
        },
        {
            "message": "Missing item type\n$locale service provides localization rules for various Angular components. As of right now the\nonly public api is:\n\n* `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)",
            "line": " lib\\angular\\impl\\angular.js:9281"
        },
        {
            "message": "Missing item type\nAngular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch\nblock and delegates any exceptions to\n{@link ng.$exceptionHandler $exceptionHandler} service.\n\nThe return value of registering a timeout function is a promise which will be resolved when\nthe timeout is reached and the timeout function is executed.\n\nTo cancel a the timeout request, call `$timeout.cancel(promise)`.\n\nIn tests you can use {@link ngMock.$timeout `$timeout.flush()`} to\nsynchronously flush the queue of deferred functions.",
            "line": " lib\\angular\\impl\\angular.js:9358"
        },
        {
            "message": "Missing item type\nCancels a task associated with the `promise`. As a result of this the promise will be\nresolved with a rejection.",
            "line": " lib\\angular\\impl\\angular.js:9412"
        },
        {
            "message": "Missing item type\nFilters are just functions which transform input to an output. However filters need to be Dependency Injected. To\nachieve this a filter definition consists of a factory function which is annotated with dependencies and is\nresponsible for creating a the filter function.\n\n<pre>\n  // Filter registration\n  function MyModule($provide, $filterProvider) {\n    // create a service to demonstrate injection (not always needed)\n    $provide.value('greet', function(name){\n      return 'Hello ' + name + '!';\n    });\n\n    // register a filter factory which uses the\n    // greet service to demonstrate DI.\n    $filterProvider.register('greet', function(greet){\n      // return the filter function which uses the greet service\n      // to generate salutation\n      return function(text) {\n        // filters need to be forgiving so check input validity\n        return text && greet(text) || text;\n      };\n    });\n  }\n</pre>\n\nThe filter function is registered with the `$injector` under the filter name suffixe with `Filter`.\n<pre>\n  it('should be the same instance', inject(\n    function($filterProvider) {\n      $filterProvider.register('reverse', function(){\n        return ...;\n      });\n    },\n    function($filter, reverseFilter) {\n      expect($filter('reverse')).toBe(reverseFilter);\n    });\n</pre>\n\n\nFor more information about how angular filters work, and how to create your own filters, see\n{@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer\nGuide.",
            "line": " lib\\angular\\impl\\angular.js:9437"
        },
        {
            "message": "Missing item type\nRegister filter factory function.",
            "line": " lib\\angular\\impl\\angular.js:9485"
        },
        {
            "message": "Missing item type\nModifies the default behavior of html A tag, so that the default action is prevented when href\nattribute is empty.\n\nThe reasoning for this change is to allow easy creation of action links with `ngClick` directive\nwithout changing the location or causing page reloads, e.g.:\n`<a href=\"\" ng-click=\"model.$save()\">Save</a>`",
            "line": " lib\\angular\\impl\\angular.js:10388"
        },
        {
            "message": "Missing item type\nUsing Angular markup like {{hash}} in an href attribute makes\nthe page open to a wrong URL, if the user clicks that link before\nangular has a chance to replace the {{hash}} with actual URL, the\nlink will be broken and will most likely return a 404 error.\nThe `ngHref` directive solves this problem.\n\nThe buggy way to write it:\n<pre>\n<a href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n</pre>\n\nThe correct way to write it:\n<pre>\n<a ng-href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n</pre>",
            "line": " lib\\angular\\impl\\angular.js:10431"
        },
        {
            "message": "Missing item type\nUsing Angular markup like `{{hash}}` in a `src` attribute doesn't\nwork right: The browser will fetch from the URL with the literal\ntext `{{hash}}` until Angular replaces the expression inside\n`{{hash}}`. The `ngSrc` directive solves this problem.\n\nThe buggy way to write it:\n<pre>\n<img src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n</pre>\n\nThe correct way to write it:\n<pre>\n<img ng-src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n</pre>",
            "line": " lib\\angular\\impl\\angular.js:10511"
        },
        {
            "message": "Missing item type\nThe following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:\n<pre>\n<div ng-init=\"scope = { isDisabled: false }\">\n <button disabled=\"{{scope.isDisabled}}\">Disabled</button>\n</div>\n</pre>\n\nThe HTML specs do not require browsers to preserve the special attributes such as disabled.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduce the `ngDisabled` directive.",
            "line": " lib\\angular\\impl\\angular.js:10536"
        },
        {
            "message": "Missing item type\nThe HTML specs do not require browsers to preserve the special attributes such as checked.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduce the `ngChecked` directive.",
            "line": " lib\\angular\\impl\\angular.js:10575"
        },
        {
            "message": "Missing item type\nThe HTML specs do not require browsers to preserve the special attributes such as multiple.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduce the `ngMultiple` directive.",
            "line": " lib\\angular\\impl\\angular.js:10605"
        },
        {
            "message": "Missing item type\nThe HTML specs do not require browsers to preserve the special attributes such as readonly.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduce the `ngReadonly` directive.",
            "line": " lib\\angular\\impl\\angular.js:10641"
        },
        {
            "message": "Missing item type\nThe HTML specs do not require browsers to preserve the special attributes such as selected.\n(The presence of them means true and absence means false)\nThis prevents the angular compiler from correctly retrieving the binding expression.\nTo solve this problem, we introduced the `ngSelected` directive.",
            "line": " lib\\angular\\impl\\angular.js:10671"
        },
        {
            "message": "Missing item type\nNestable alias of {@link ng.directive:form `form`} directive. HTML\ndoes not allow nesting of form elements. It is useful to nest forms, for example if the validity of a\nsub-group of controls needs to be determined.",
            "line": " lib\\angular\\impl\\angular.js:10871"
        },
        {
            "message": "Missing item type\nDirective that instantiates\n{@link ng.directive:form.FormController FormController}.\n\nIf `name` attribute is specified, the form controller is published onto the current scope under\nthis name.\n\n# Alias: {@link ng.directive:ngForm `ngForm`}\n\nIn angular forms can be nested. This means that the outer form is valid when all of the child\nforms are valid as well. However browsers do not allow nesting of `<form>` elements, for this\nreason angular provides {@link ng.directive:ngForm `ngForm`} alias\nwhich behaves identical to `<form>` but allows form nesting.\n\n\n# CSS classes\n - `ng-valid` Is set if the form is valid.\n - `ng-invalid` Is set if the form is invalid.\n - `ng-pristine` Is set if the form is pristine.\n - `ng-dirty` Is set if the form is dirty.\n\n\n# Submitting a form and preventing default action\n\nSince the role of forms in client-side Angular applications is different than in classical\nroundtrip apps, it is desirable for the browser not to translate the form submission into a full\npage reload that sends the data to the server. Instead some javascript logic should be triggered\nto handle the form submission in application specific way.\n\nFor this reason, Angular prevents the default action (form submission to the server) unless the\n`<form>` element has an `action` attribute specified.\n\nYou can use one of the following two ways to specify what javascript method should be called when\na form is submitted:\n\n- {@link ng.directive:ngSubmit ngSubmit} directive on the form element\n- {@link ng.directive:ngClick ngClick} directive on the first\n button or input field of type submit (input[type=submit])\n\nTo prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This\nis because of the following form submission rules coming from the html spec:\n\n- If a form has only one input field then hitting enter in this field triggers form submit\n(`ngSubmit`)\n- if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter\ndoesn't trigger submit\n- if a form has one or more input fields and one or more buttons or input[type=submit] then\nhitting enter in any of the input fields will trigger the click handler on the *first* button or\ninput[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)",
            "line": " lib\\angular\\impl\\angular.js:10886"
        },
        {
            "message": "Missing item type\nStandard HTML text input with angular data binding.",
            "line": " lib\\angular\\impl\\angular.js:11042"
        },
        {
            "message": "Missing item type\nText input with number validation and transformation. Sets the `number` validation\nerror if not a valid number.",
            "line": " lib\\angular\\impl\\angular.js:11111"
        },
        {
            "message": "Missing item type\nText input with URL validation. Sets the `url` validation error key if the content is not a\nvalid URL.",
            "line": " lib\\angular\\impl\\angular.js:11182"
        },
        {
            "message": "Missing item type\nText input with email validation. Sets the `email` validation error key if not a valid email\naddress.",
            "line": " lib\\angular\\impl\\angular.js:11250"
        },
        {
            "message": "Missing item type\nHTML radio button.",
            "line": " lib\\angular\\impl\\angular.js:11316"
        },
        {
            "message": "Missing item type\nHTML checkbox.",
            "line": " lib\\angular\\impl\\angular.js:11357"
        },
        {
            "message": "Missing item type\nHTML textarea element control with angular data-binding. The data-binding and validation\nproperties of this element are exactly the same as those of the\n{@link ng.directive:input input element}.",
            "line": " lib\\angular\\impl\\angular.js:11673"
        },
        {
            "message": "Missing item type\nHTML input element control with angular data-binding. Input control follows HTML5 input types\nand polyfills the HTML5 validation behavior for older browsers.",
            "line": " lib\\angular\\impl\\angular.js:11701"
        },
        {
            "message": "Missing item type\nCalled when the view needs to be updated. It is expected that the user of the ng-model\ndirective will implement this method.",
            "line": " lib\\angular\\impl\\angular.js:11930"
        },
        {
            "message": "Missing item type\nChange the validity state, and notifies the form when the control changes validity. (i.e. it\ndoes not notify form if given validator is already marked as invalid).\n\nThis method should be called by validators - i.e. the parser or formatter functions.",
            "line": " lib\\angular\\impl\\angular.js:11958"
        },
        {
            "message": "Missing item type\nRead a value from view.\n\nThis method should be called from within a DOM event handler.\nFor example {@link ng.directive:input input} or\n{@link ng.directive:select select} directives call it.\n\nIt internally calls all `formatters` and if resulted value is valid, updates the model and\ncalls all registered change listeners.",
            "line": " lib\\angular\\impl\\angular.js:12000"
        },
        {
            "message": "Missing item type\nIs directive that tells Angular to do two-way data binding. It works together with `input`,\n`select`, `textarea`. You can easily write your own directives to use `ngModel` as well.\n\n`ngModel` is responsible for:\n\n- binding the view into the model, which other directives such as `input`, `textarea` or `select`\n  require,\n- providing validation behavior (i.e. required, number, email, url),\n- keeping state of the control (valid/invalid, dirty/pristine, validation errors),\n- setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),\n- register the control with parent {@link ng.directive:form form}.\n\nFor basic examples, how to use `ngModel`, see:\n\n - {@link ng.directive:input input}\n   - {@link ng.directive:input.text text}\n   - {@link ng.directive:input.checkbox checkbox}\n   - {@link ng.directive:input.radio radio}\n   - {@link ng.directive:input.number number}\n   - {@link ng.directive:input.email email}\n   - {@link ng.directive:input.url url}\n - {@link ng.directive:select select}\n - {@link ng.directive:textarea textarea}",
            "line": " lib\\angular\\impl\\angular.js:12071"
        },
        {
            "message": "Missing item type\nEvaluate given expression when user changes the input.\nThe expression is not evaluated when the value change is coming from the model.\n\nNote, this directive requires `ngModel` to be present.",
            "line": " lib\\angular\\impl\\angular.js:12123"
        },
        {
            "message": "Missing item type\nText input that converts between comma-separated string into an array of strings.",
            "line": " lib\\angular\\impl\\angular.js:12209"
        },
        {
            "message": "Missing item type\nThe `ngBind` attribute tells Angular to replace the text content of the specified HTML element\nwith the value of a given expression, and to update the text content when the value of that\nexpression changes.\n\nTypically, you don't use `ngBind` directly, but instead you use the double curly markup like\n`{{ expression }}` which is similar but less verbose.\n\nOnce scenario in which the use of `ngBind` is prefered over `{{ expression }}` binding is when\nit's desirable to put bindings into template that is momentarily displayed by the browser in its\nraw state before Angular compiles it. Since `ngBind` is an element attribute, it makes the\nbindings invisible to the user while the page is loading.\n\nAn alternative solution to this problem would be using the\n{@link ng.directive:ngCloak ngCloak} directive.",
            "line": " lib\\angular\\impl\\angular.js:12306"
        },
        {
            "message": "Missing item type\nThe `ngBindTemplate` directive specifies that the element\ntext should be replaced with the template in ngBindTemplate.\nUnlike ngBind the ngBindTemplate can contain multiple `{{` `}}`\nexpressions. (This is required since some HTML elements\ncan not have SPAN elements such as TITLE, or OPTION to name a few.)",
            "line": " lib\\angular\\impl\\angular.js:12361"
        },
        {
            "message": "Missing item type\nCreates a binding that will innerHTML the result of evaluating the `expression` into the current\nelement. *The innerHTML-ed content will not be sanitized!* You should use this directive only if\n{@link ngSanitize.directive:ngBindHtml ngBindHtml} directive is too\nrestrictive and when you absolutely trust the source of the content you are binding to.\n\nSee {@link ngSanitize.$sanitize $sanitize} docs for examples.",
            "line": " lib\\angular\\impl\\angular.js:12420"
        },
        {
            "message": "Missing item type\nThe `ngClass` allows you to set CSS class on HTML element dynamically by databinding an\nexpression that represents all classes to be added.\n\nThe directive won't add duplicate classes if a particular class was already set.\n\nWhen the expression changes, the previously added classes are removed and only then the\nnew classes are added.",
            "line": " lib\\angular\\impl\\angular.js:12501"
        },
        {
            "message": "Missing item type\nThe `ngClassOdd` and `ngClassEven` directives work exactly as\n{@link ng.directive:ngClass ngClass}, except it works in\nconjunction with `ngRepeat` and takes affect only on odd (even) rows.\n\nThis directive can be applied only within a scope of an\n{@link ng.directive:ngRepeat ngRepeat}.",
            "line": " lib\\angular\\impl\\angular.js:12552"
        },
        {
            "message": "Missing item type\nThe `ngClassOdd` and `ngClassEven` works exactly as\n{@link ng.directive:ngClass ngClass}, except it works in\nconjunction with `ngRepeat` and takes affect only on odd (even) rows.\n\nThis directive can be applied only within a scope of an\n{@link ng.directive:ngRepeat ngRepeat}.",
            "line": " lib\\angular\\impl\\angular.js:12599"
        },
        {
            "message": "Missing item type\nThe `ngCloak` directive is used to prevent the Angular html template from being briefly\ndisplayed by the browser in its raw (uncompiled) form while your application is loading. Use this\ndirective to avoid the undesirable flicker effect caused by the html template display.\n\nThe directive can be applied to the `<body>` element, but typically a fine-grained application is\nprefered in order to benefit from progressive rendering of the browser view.\n\n`ngCloak` works in cooperation with a css rule that is embedded within `angular.js` and\n `angular.min.js` files. Following is the css rule:\n\n<pre>\n[ng\\:cloak], [ng-cloak], .ng-cloak {\n  display: none;\n}\n</pre>\n\nWhen this css rule is loaded by the browser, all html elements (including their children) that\nare tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive\nduring the compilation of the template it deletes the `ngCloak` element attribute, which\nmakes the compiled element visible.\n\nFor the best result, `angular.js` script must be loaded in the head section of the html file;\nalternatively, the css rule (above) must be included in the external stylesheet of the\napplication.\n\nLegacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they\ncannot match the `[ng\\:cloak]` selector. To work around this limitation, you must add the css\nclass `ngCloak` in addition to `ngCloak` directive as shown in the example below.",
            "line": " lib\\angular\\impl\\angular.js:12646"
        },
        {
            "message": "Missing item type\nThe `ngController` directive assigns behavior to a scope. This is a key aspect of how angular\nsupports the principles behind the Model-View-Controller design pattern.\n\nMVC components in angular:\n\n* Model — The Model is data in scope properties; scopes are attached to the DOM.\n* View — The template (HTML with data bindings) is rendered into the View.\n* Controller — The `ngController` directive specifies a Controller class; the class has\n  methods that typically express the business logic behind the application.\n\nNote that an alternative way to define controllers is via the `{@link ng.$route}`\nservice.",
            "line": " lib\\angular\\impl\\angular.js:12706"
        },
        {
            "message": "Missing item type\nEnables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.\nThis directive should be used on the root element of the application (typically the `<html>`\nelement or other element with the {@link ng.directive:ngApp ngApp}\ndirective).\n\nIf enabled the performance of template expression evaluator will suffer slightly, so don't enable\nthis mode unless you need it.",
            "line": " lib\\angular\\impl\\angular.js:12808"
        },
        {
            "message": "Missing item type\nThe ngClick allows you to specify custom behavior when\nelement is clicked.",
            "line": " lib\\angular\\impl\\angular.js:12834"
        },
        {
            "message": "Missing item type\nThe `ngDblclick` directive allows you to specify custom behavior on dblclick event.",
            "line": " lib\\angular\\impl\\angular.js:12887"
        },
        {
            "message": "Missing item type\nThe ngMousedown directive allows you to specify custom behavior on mousedown event.",
            "line": " lib\\angular\\impl\\angular.js:12903"
        },
        {
            "message": "Missing item type\nSpecify custom behavior on mouseup event.",
            "line": " lib\\angular\\impl\\angular.js:12919"
        },
        {
            "message": "Missing item type\nSpecify custom behavior on mouseover event.",
            "line": " lib\\angular\\impl\\angular.js:12934"
        },
        {
            "message": "Missing item type\nSpecify custom behavior on mouseenter event.",
            "line": " lib\\angular\\impl\\angular.js:12950"
        },
        {
            "message": "Missing item type\nSpecify custom behavior on mouseleave event.",
            "line": " lib\\angular\\impl\\angular.js:12966"
        },
        {
            "message": "Missing item type\nSpecify custom behavior on mousemove event.",
            "line": " lib\\angular\\impl\\angular.js:12982"
        },
        {
            "message": "Missing item type\nEnables binding angular expressions to onsubmit events.\n\nAdditionally it prevents the default action (which for form means sending the request to the\nserver and reloading the current page).",
            "line": " lib\\angular\\impl\\angular.js:12998"
        },
        {
            "message": "Missing item type\nFetches, compiles and includes an external HTML fragment.\n\nKeep in mind that Same Origin Policy applies to included resources\n(e.g. ngInclude won't work for cross-domain requests on all browsers and for\n file:// access on some browsers).",
            "line": " lib\\angular\\impl\\angular.js:13055"
        },
        {
            "message": "Missing item type\nEmitted every time the ngInclude content is reloaded.",
            "line": " lib\\angular\\impl\\angular.js:13125"
        },
        {
            "message": "Missing item type\nThe `ngInit` directive specifies initialization tasks to be executed\n before the template enters execution mode during bootstrap.",
            "line": " lib\\angular\\impl\\angular.js:13185"
        },
        {
            "message": "Missing item type\nSometimes it is necessary to write code which looks like bindings but which should be left alone\nby angular. Use `ngNonBindable` to make angular ignore a chunk of HTML.",
            "line": " lib\\angular\\impl\\angular.js:13221"
        },
        {
            "message": "Missing item type\n# Overview\n`ngPluralize` is a directive that displays messages according to en-US localization rules.\nThese rules are bundled with angular.js and the rules can be overridden\n(see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive\nby specifying the mappings between\n{@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\nplural categories} and the strings to be displayed.\n\n# Plural categories and explicit number rules\nThere are two\n{@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\nplural categories} in Angular's default en-US locale: \"one\" and \"other\".\n\nWhile a pural category may match many numbers (for example, in en-US locale, \"other\" can match\nany number that is not 1), an explicit number rule can only match one number. For example, the\nexplicit number rule for \"3\" matches the number 3. You will see the use of plural categories\nand explicit number rules throughout later parts of this documentation.\n\n# Configuring ngPluralize\nYou configure ngPluralize by providing 2 attributes: `count` and `when`.\nYou can also provide an optional attribute, `offset`.\n\nThe value of the `count` attribute can be either a string or an {@link guide/expression\nAngular expression}; these are evaluated on the current scope for its bound value.\n\nThe `when` attribute specifies the mappings between plural categories and the actual\nstring to be displayed. The value of the attribute should be a JSON object so that Angular\ncan interpret it correctly.\n\nThe following example shows how to configure ngPluralize:\n\n<pre>\n<ng-pluralize count=\"personCount\"\n                when=\"{'0': 'Nobody is viewing.',\n                     'one': '1 person is viewing.',\n                     'other': '{} people are viewing.'}\">\n</ng-pluralize>\n</pre>\n\nIn the example, `\"0: Nobody is viewing.\"` is an explicit number rule. If you did not\nspecify this rule, 0 would be matched to the \"other\" category and \"0 people are viewing\"\nwould be shown instead of \"Nobody is viewing\". You can specify an explicit number rule for\nother numbers, for example 12, so that instead of showing \"12 people are viewing\", you can\nshow \"a dozen people are viewing\".\n\nYou can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted\ninto pluralized strings. In the previous example, Angular will replace `{}` with\n<span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder\nfor <span ng-non-bindable>{{numberExpression}}</span>.\n\n# Configuring ngPluralize with offset\nThe `offset` attribute allows further customization of pluralized text, which can result in\na better user experience. For example, instead of the message \"4 people are viewing this document\",\nyou might display \"John, Kate and 2 others are viewing this document\".\nThe offset attribute allows you to offset a number by any desired value.\nLet's take a look at an example:\n\n<pre>\n<ng-pluralize count=\"personCount\" offset=2\n              when=\"{'0': 'Nobody is viewing.',\n                     '1': '{{person1}} is viewing.',\n                     '2': '{{person1}} and {{person2}} are viewing.',\n                     'one': '{{person1}}, {{person2}} and one other person are viewing.',\n                     'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\n</ng-pluralize>\n</pre>\n\nNotice that we are still using two plural categories(one, other), but we added\nthree explicit number rules 0, 1 and 2.\nWhen one person, perhaps John, views the document, \"John is viewing\" will be shown.\nWhen three people view the document, no explicit number rule is found, so\nan offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.\nIn this case, plural category 'one' is matched and \"John, Marry and one other person are viewing\"\nis shown.\n\nNote that when you specify offsets, you must provide explicit number rules for\nnumbers from 0 up to and including the offset. If you use an offset of 3, for example,\nyou must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for\nplural categories \"one\" and \"other\".",
            "line": " lib\\angular\\impl\\angular.js:13253"
        },
        {
            "message": "Missing item type\nThe `ngRepeat` directive instantiates a template once per item from a collection. Each template\ninstance gets its own scope, where the given loop variable is set to the current collection item,\nand `$index` is set to the item index or key.\n\nSpecial properties are exposed on the local scope of each template instance, including:\n\n  * `$index` – `{number}` – iterator offset of the repeated element (0..length-1)\n  * `$first` – `{boolean}` – true if the repeated element is first in the iterator.\n  * `$middle` – `{boolean}` – true if the repeated element is between the first and last in the iterator.\n  * `$last` – `{boolean}` – true if the repeated element is last in the iterator.",
            "line": " lib\\angular\\impl\\angular.js:13459"
        },
        {
            "message": "Missing item type\nThe `ngShow` and `ngHide` directives show or hide a portion of the DOM tree (HTML)\nconditionally.",
            "line": " lib\\angular\\impl\\angular.js:13647"
        },
        {
            "message": "Missing item type\nThe `ngHide` and `ngShow` directives hide or show a portion of the DOM tree (HTML)\nconditionally.",
            "line": " lib\\angular\\impl\\angular.js:13687"
        },
        {
            "message": "Missing item type\nThe `ngStyle` directive allows you to set CSS style on an HTML element conditionally.",
            "line": " lib\\angular\\impl\\angular.js:13726"
        },
        {
            "message": "Missing item type\nConditionally change the DOM structure.",
            "line": " lib\\angular\\impl\\angular.js:13772"
        },
        {
            "message": "Missing item type\nInsert the transcluded DOM here.",
            "line": " lib\\angular\\impl\\angular.js:13885"
        },
        {
            "message": "Missing item type\n# Overview\n`ngView` is a directive that complements the {@link ng.$route $route} service by\nincluding the rendered template of the current route into the main layout (`index.html`) file.\nEvery time the current route changes, the included view changes with it according to the\nconfiguration of the `$route` service.",
            "line": " lib\\angular\\impl\\angular.js:13942"
        },
        {
            "message": "Missing item type\nEmitted every time the ngView content is reloaded.",
            "line": " lib\\angular\\impl\\angular.js:14038"
        },
        {
            "message": "Missing item type\nLoad content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the\ntemplate can be used by `ngInclude`, `ngView` or directive templates.",
            "line": " lib\\angular\\impl\\angular.js:14106"
        },
        {
            "message": "Missing item type\nHTML `SELECT` element with angular data-binding.\n\n# `ngOptions`\n\nOptionally `ngOptions` attribute can be used to dynamically generate a list of `<option>`\nelements for a `<select>` element using an array or an object obtained by evaluating the\n`ngOptions` expression.\n˝˝\nWhen an item in the select menu is select, the value of array element or object property\nrepresented by the selected option will be bound to the model identified by the `ngModel`\ndirective of the parent select element.\n\nOptionally, a single hard-coded `<option>` element, with the value set to an empty string, can\nbe nested into the `<select>` element. This element will then represent `null` or \"not selected\"\noption. See example below for demonstration.\n\nNote: `ngOptions` provides iterator facility for `<option>` element which should be used instead\nof {@link ng.directive:ngRepeat ngRepeat} when you want the\n`select` model to be bound to a non-string value. This is because an option element can currently\nbe bound to string values only.",
            "line": " lib\\angular\\impl\\angular.js:14151"
        },
        {
            "message": "Missing item type\nFor feature detection",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:3837"
        },
        {
            "message": "Missing item type\nCreate key-value caches of limited size",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:3845"
        },
        {
            "message": "Missing item type\nMark a function for special use by Sizzle",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:3865"
        },
        {
            "message": "Missing item type\nSupport testing using an element",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:3874"
        },
        {
            "message": "Missing item type\nDetect xml",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:4001"
        },
        {
            "message": "Missing item type\nSets document-related variables once based on the current document",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:4012"
        },
        {
            "message": "Missing item type\nUtility function for retrieving the text value of an array of DOM nodes",
            "line": " lib\\jquery\\impl\\jquery-1.9.1.js:4505"
        }
    ]
}